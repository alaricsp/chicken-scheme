TODO for trunk								-*- Outline -*-


* bugs

** compiler
*** pre-optimization 
**** changes call-sites and makes them invalid for later pre-optimization

** expander
*** expansion of r5rs_pitfall 4.2 incorrect
    possibly due to a non-aliased implicit "begin" somewhere
*** dirty-macros.scm loops when using `defile'
    possibly due to unrenamed special forms

** modules
*** chicken.import.scm refers to ##sys#chicken-macro-environment
    ... which is only set, if chicken-more-macros.scm is loaded, which
    is of course not the case inside a compiled executable (current
    workaround is to set them to nil by default)
*** same for ##sys#chicken-ffi-macro-environment
*** re-exports of syntax doesn't work
    generating import library requires source
    (compiled-module-registration), but original module is lost after
    importing. Can we simply pull expander closure out of module from which
    we imported?
*** `require-extension' fails in interpreter when extension is .so without import library
    probably because load and import is in same toplevel form, and the
    load is performed after the import (at runtime). A possibly fix
    would be to load the extension immediately (at
    compile-/expansion-time), when import is #t and o import lib
    exists.


* tasks

** branches
*** test irregular branch, merge if performance is acceptable

** expander
*** at some stage disable debug-output in expand.scm

** module issues
*** need a way to omit generating module registration without generating import lib
    for example when compiling static version, where implib already exists
*** code-duplication in compiler and evaluator for ##core#module
*** "scheme" module does not include some special forms ("define-syntax", etc.)
*** import-for-syntax imports value bindings into import-env
    should actually be a distinct meta-import-env.
    (does it work at all?)
*** curried define performs expansion in empty se - problem?
    (as comment in expand.scm indicated (##sys#register-export))
*** checks to be implemented
**** reimport of imported id
**** unused defs?

** compiler
*** remove "custom-declare" + stuff?
*** generate object-files in /tmp (or TMPDIR)?

** csc
*** automatically compile import-libraries?

** setup/install
*** setup-download
**** use HTTP_PROXY env. var
**** handle redirects in http-fetch

** library
*** read-mark list should be stored in read-table

** syntax-error
*** if ##sys#current-module is set, add name to error message?
*** fluidly keep track of expanded forms (extend meaning of culprit) to pprint pruned expr on error

** build
*** rules.make should really be generated by a script
*** need script to process import libraries for generating indices for doc.callcc.org
    then tell Toby about it


* tests

** optional longer run (env. var)
*** syntax-rules-stress-test
*** fully compiled ec-tests


* documentation

** document ("HI/LO") expander (-> wiki, internals)
   will we ever have the time for that?
** document new .meta entries in tutorials on wiki
   depends, test-depends
** chicken.texi needs to be regenerated


* optimizations

** self-recursion optimization
   what MacScheme called "benchmark-mode" (assume self-calls are recursion)
*** needs declaration or option, >= -O2

** when inlining, consing arg-list with "list" may make get-keyword possible foldable

** local flow analysis

** lambda-fusion / "fuse-and-dispatch" (suggested by Alex)
   convert groups of local lambdas referenced to only in operator-position into
   looping lambda + dispatch (static variable can be used), otherwise similar to
   a conditional
*** new forms (after optimization, prepared language)
    [##core#dispatch LAMBDABODY1 ... BODY]
    [##core#call/dispatch {INDEX} ARGUMENT1 ...}

** handle optional args primitively 
   for example, set to distinguished val (checking argc) on C level, core
   primitive for checking this - should be quite simple, but llist processing
   (decompose-lambda-list) will be more expensive and cumbersome.

** pre-hashed symbols (extra symbol slot)
   The memory usage should be acceptable, performance gain is hard to guess.
   Some experiments indicate that hashing the string is cheaper than it appears,
   but low-level hashtables should get the most of this (and thus speed up
   the compiler)
