\input texinfo @c -*-texinfo-*-
@setfilename chicken.info
@settitle CHICKEN - A practical and portable Scheme system. Version 2, Build 401

@ifnottex
@macro pointrightarrow
->
@end macro
@end ifnottex

@iftex
@macro pointrightarrow
@math{@rightarrow{}}
@end macro
@end iftex

@copying
@noindent
Copyright @copyright{} 2000-2006, Felix L. Winkelmann
All rights reserved.

@noindent
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

@itemize
@item Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
@item Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
@item Neither the name of the author nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.  
@end itemize

@
@

@noindent

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE,
DATA, OR PROFITS OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@end copying

@dircategory The Algorithmic Language Scheme
@direntry
* CHICKEN: (chicken).          A pratical and portable Scheme system (Version 2, Build 401).
@end direntry

@titlepage
@title CHICKEN
@subtitle A practical and portable Scheme system
@subtitle User's Manual
@subtitle Version 2, Build 401
@author Felix L. Winkelmann
@end titlepage

@insertcopying
@contents

@syncodeindex vr fn


@ifnottex
@node Top
@top CHICKEN

CHICKEN - A practical and portable Scheme system
User's manual (Version 2, Build 401)

(c) 2000-2006, Felix L. Winkelmann
All rights reserved. Translated to LaTeX by Peter Keller. Translated to texinfo by Linh Dang.

@menu
* Introduction::                
* Basic mode of operation::     
* Using the compiler::          
* Using the interpreter::       
* Supported language::          
* Interface to external functions and variables::  
* chicken-setup::
* Additional files::            
* Data Representation::         
* Bugs and limitations::        
* FAQ::
* Acknowledgements::            
* Bibliography::                
* Index::                       

@detailmenu
 --- The Detailed Node Listing ---

Using the compiler

* Compiler command line format::  
* Runtime options::             
* An example::                  
* Extending the compiler::      
* Distributing compiled C files::  

Using the interpreter

* Interpreter  command line format::  
* Writing Scheme scripts::      
* Toplevel commands::           
* Macros and procedures implemented in the interpreter::  

Supported language

* Deviations from the standard::  
* Extensions to the standard::  
* Non standard read syntax::    
* Non-standard macros and special forms::  
* Pattern Matching::
* Declarations::                
* Parameters::                  
* Unit library::                
* Unit eval::                   
* Unit extras::                 
* Unit srfi-1::                 
* Unit srfi-4::                 
* Unit srfi-13::                
* Unit srfi-14::                
* Unit match::                  
* Unit regex::                  
* Unit srfi-18::                
* Unit posix::                  
* Unit utils::           
* Unit tcp::                    
* Unit lolevel::                
* Unit tinyclos::               

Non-standard macros and special forms 

* Binding forms for optional arguments::  
* Other binding forms::         
* Substitution forms and macros::  
* Conditional forms::           
* Record structures::           
* Other forms::                 

Unit library

* Arithmetic::                  
* File Input/Output::           
* Files::                       
* String ports::                
* Feature identifiers::         
* Keywords::                    
* Exceptions::                  
* Environment information and system interface::  
* Execution time::              
* Interrupts and error-handling::  
* Garbage collection::          
* Other control structures::    
* String utilities::
* Generating uninterned symbols::  
* Standard Input/Output::       
* User-defined named characters::  
* Vectors::                     
* The unspecified value::
* Continuations::
* Setters::

Unit eval

* Loading code::                
* Read-eval-print loop::        
* Macros::                      
* Loading extension libraries::         
* Reader extensions::           
* Eval::                        

Unit extras

* Lists::                       
* String-port extensions::      
* Formatted output::            
* Hash tables::                 
* Queues::                      
* Sorting::                     
* Random numbers::              
* Input/Output extensions::     
* Strings::                     
* Combinators::                 
* Binary searching::            

Unit posix

* Directories::                 
* Pipes::                       
* Fifos::                       
* File descriptors and low-level I/O::  
* Retrieving file attributes::  
* Changing file attributes::    
* Processes::                   
* Hard and symbolic links::              
* Permissions::                 
* Record locking::              
* Signal handling::             
* Environment access::          
* Memory mapped I/O::           
* Date and time routines::               
* Raw exit::                    
* ERRNO values::                
* Finding files::               
* Getting the hostname and system information::  
* Setting the file buffering mode::  
* Terminal ports::              
* How Scheme procedures relate to UNIX C functions::  
* Windows specific notes::

Unit utils

* Pathname operations::         
* Temporary files::             
* Deleting a file without signalling an error::  
* Iterating over input lines and files::  
* Executing shell commands with formatstring and error checking::  

Unit lolevel

* Foreign pointers::            
* Tagged pointers::             
* Extending procedures with data::  
* Bytevectors::                 
* Data in unmanaged memory::    
* Locatives::                   
* Accessing toplevel variables::  
* Low-level data access::       
* Procedure-call- and variable reference hooks::  
* Magic::                       

Unit tinyclos

* Defining forms::              
* Base language::               
* Introspection::               
* Intercessory protocol::       
* Additional protocol::         
* Utility procedures::          
* Builtin classes::             

Interface to external functions and variables

* Accessing external objects::  
* Foreign type specifiers::     
* Embedding::                
* Callbacks::                   
* Locations::                   
* Other support procedures::    
* The Easy Foreign Function Interface::  
* C interface::                 

The @emph{Easy} Foreign Function Interface

* #> ... <# Syntax::            
* General operation::           
* Pseudo declarations::         
* Grammar::                     
* C notes::                     
* C++ notes::

chicken-setup

* Extension libraries::
* Installing extensions::
* Creating extensions::
* Procedures and macros available in setup scripts::

Additional files

* chicken-more-macros.scm::     
* chicken-ffi-macros.scm::      

@end detailmenu
@end menu

@end ifnottex

@node Introduction
@chapter Introduction
CHICKEN is a compiler that translates Scheme source files into C, which in
turn can be fed to a C-compiler to generate a standalone executable. This
principle, which is used by several existing compilers, achieves high
portability because C is implemented on nearly all available platforms.

This package is distributed under the BSD license and as such is free
to use and modify. An interpreter is also available and can be used as
a scripting environment or for testing programs before compilation.

The method of compilation and the design of the runtime-system follow
closely Henry Baker's @cite{CONS Should Not CONS Its Arguments, Part II:
Cheney on the M.T.A.} paper and expose a number of interesting
properties: consing (creation of data on the heap) is relatively
inexpensive, because a generational garbage collection scheme is used,
in which short-lived data structures are reclaimed extremely quickly.
Moreover, @code{call-with-current-continuation} is practically for free
and CHICKEN does not suffer under any performance penalties if
first-class continuations are used in complex ways.  The generated C
code is fully tail-recursive.

Some of the features supported by CHICKEN:
@itemize
@item SRFIs 0, 1, 2, 4, 6, 7, 8, 9, 10, 13, 14, 16, 17, 18, 23, 28, 30, 31, 39, 55, 61 and 62.
@item Lightweight threads based on first-class continuations
@item Pattern matching with Andrew Wright's @code{match} package
@item Record structures
@item An object system with multiple inheritance, multimethods and a
                meta-object protocol
@item Extended comment- and string-literal syntaxes
@item Libraries for regular expressions, string handling
UNIX system calls and extended data structures
@item Create interpreted or compiled shell scripts written in Scheme
                for UNIX or Windows
@item Compiled C files can be easily distributed
@item Allows the creation of fully self-contained statically linked executables
@item On systems that support it, compiled code can be loaded dynamically
@end itemize

This manual is merely a reference for the CHICKEN system and assumes
a working knowledge of Scheme.


@node Basic mode of operation
@chapter Basic mode of operation

The compiler translates Scheme source code into fairly portable C that
can be compiled and linked with most available C compilers. CHICKEN supports
the generation of executables and libraries, linked either statically or
dynamically. Compiled Scheme code can be loaded dynamically, or can be
embedded in applications written in other languages. Separate compilation
of modules is fully supported.

The most portable way of creating separately linkable entities is
supported by so-called @emph{unit}s.  A unit is a single
compiled object module that contains a number of toplevel expressions that
are executed either when the unit is the @emph{main} unit or if the
unit is @emph{used}.  To use a unit, the unit has to be @emph{declare}ed
as used, like this:

@verbatim
(declare (uses UNITNAME))
@end verbatim

The toplevel expressions of used units are executed in the order in
which the units appear in the @code{@b{uses}} declaration. Units
may be used multiple times and @code{@b{uses}} declarations may
be circular (the unit is initialized at most once).  To compile a file
as a unit, add a @code{@b{unit}} declaration:

@verbatim
(declare (unit UNITNAME))
@end verbatim

When compiling different object modules, make sure to have one main
unit. This unit is called initially and initializes all used units
before executing its toplevel expressions. The main-unit has no
@code{@b{unit}} declaration.

Another method of using definitions in separate source files is to
@emph{include} them. This simply inserts the code in a given file into
the current file:

@verbatim
(include "FILENAME")
@end verbatim

Macro definitions are only available when processed
by @code{include}. Macro definitions in separate units are not available, since
they are defined at compile time, i.e the time when that other unit
was compiled (macros can optionally be
available at runtime, see @code{@b{define-macro}} in @ref{Substitution forms and macros}).

On platforms that support dynamic loading of compiled code (like Windows and most ELF based
systems like Linux or BSD) code can be compiled into a shared object (@code{.so}) and loaded 
dynamically into a running application.


@node Using the compiler
@chapter Using the compiler

The interface to @code{chicken} is intentionally simple.  System
dependent makefiles, shell-scripts or batch-files should perform
any necessary steps before and after invocation of @code{chicken}.
A program named @code{csc} provides a much simpler
interface to the Scheme- and C-compilers and linker. Enter

@verbatim
csc -help
@end verbatim

on the command line for more information.

@menu
* Compiler command line format::  
* Runtime options::             
* An example::                  
* Extending the compiler::      
* Distributing compiled C files::  
@end menu

@node Compiler command line format
@section Command line format 

@code{chicken FILENAME @{OPTION@}}

@code{FILENAME} is the complete pathname of the source file that is to
be translated into C. A filename argument of ``@code{-}'' specifies that
the source text should be read from standard input. Note that the filename
has to be the first argument to @code{chicken}.
Possible options are:

@table @code

@item -analyze-only

Stop compilation after first analysis pass.

@item -benchmark-mode

Equivalent to @code{-no-trace -no-lambda-info -optimize-level 3}
@code{-fixnum-arithmetic -disable-interrupts -block -lambda-lift}.

@item -block

Enable block-compilation. When this option is specified, the
compiler assumes that global variables are not modified outside this
compilation-unit.  Specifically, toplevel bindings are not seen by
@code{eval} and unused toplevel bindings are removed.

@item -case-insensitive

Enables the reader to read symbols case insensitive. The default is to read
case sensitive (in violation of R5RS).  This option registers the @code{case-insensitive}
feature identifier.

@item -check-imports
Search for references to undefined global variables. For each library unit accessed
via @code{(declare (uses ...))}, the compiler will search a file named @code{UNITNAME.exports}
in the current include path and load its contents into the ``import-table'' (if found).
Also, export-information for extensions (accessed through @code{(require-extension ...)})
will be searched and stored in the import-table. If a required extensions does not
provide explicit exports-innformation and @code{.exports} file is searched
(as with used units). After the analysis phase of
the compiler, referenced toplevel variables for which no assignment was found will
generate a warning. Also, re-assignments of imported variables will trigger a warning.

@item -check-syntax

Aborts compilation process after macro-expansion and syntax checks.

@item -compress-literals THRESHOLD

Compiles quoted literals that exceed the size @code{THRESHOLD} as strings
and parse the strings at run-time. This reduces the size of the code and
speeds up compile-times of the host C compiler, but has a small run-time
performance penalty. The size of a literal is computed by counting recursively the objects
in the literal, so a vector counts as 1 plus the count of the elements,
a pair counts as the counts of the car and the cdr, respectively.
All other objects count 1.

@item -debug MODES

Enables one or more compiler debugging modes. @code{MODES} is a string
of characters that select debugging information about the compiler that
will be printed to standard output.

@table @kbd
@item t
show time needed for compilation
@item b
show breakdown of time needed for each compiler pass
@item o
show performed optimizations
@item r
show invocation parameters
@item s
show program-size information and other statistics
@item a
show node-matching during simplification
@item p
show execution of compiler sub-passes
@item l
show lambda-lifting information
@item m
show GC statistics during compilation
@item n
print the line-number database 
@item c
print every expression before macro-expansion
@item u
lists all unassigned global variable references
@item x
display information about experimental features
@item D
when printing nodes, use node-tree output
@item N
show the real-name mapping table
@item U
show expressions after the secondary user pass
@item 0
show database before lambda-lifting pass
@item L
show expressions after lambda-lifting
@item F
show output of ``easy'' FFI parser
@item M
show unit-information and syntax-/runtime-requirements
@item 1
show source expressions
@item 2
show canonicalized expressions
@item 3
show expressions converted into CPS
@item 4
show database after each analysis pass
@item 5
show expressions after each optimization pass
@item 6
show expressions after each inlining pass
@item 7
show expressions after complete optimization
@item 8
show database after final analysis
@item 9
show expressions after closure conversion
@end table

@item -debug-level LEVEL

Selects amount of debug-information. @code{LEVEL} should be an integer.

 
@itemize
@item @code{-debug-level 0} is equivalent to @code{-no-trace -no-lambda-info}
@item @code{-debug-level 1} is equivalent to @code{-no-trace}
@item @code{-debug-level 2} does nothing (the default)
@end itemize
 

@item -disable-c-syntax-checks

Disable basic syntax checking of embedded C code fragments.

@item -disable-interrupts

Equivalent to the @code{(disable-interrupts)} declaration. No
interrupt-checks are generated for compiled programs.

@item -disable-stack-overflow-checks

Disables detection of stack overflows. This is equivalent to running the compiled
executable with the @code{-:o} runtime option.

@item -disable-warning CLASS
Disables specific class of warnings, may be given multiple times. The following classes are
defined:

@itemize
@item @code{usage} 
warnings related to command-line arguments
@item @code{type}
warnings related to type-conversion
@item @code{ext}
warnings related to extension libraries
@item @code{var}
warnings related to variable- and syntax-definitions and use
@item @code{const}
warnings related to constant-definitions
@item @code{syntax}
syntax-related warnings
@item @code{redef}
warnings about redefinitions of standard- or extended-bindings
@item @code{call}
warnings related to known procedure calls
@item @code{ffi}
warnings related to the foreign function interface
@end itemize

@item -dynamic

This option should be used when compiling files intended to be loaded dynamically into
a running Scheme program.

@item -epilogue FILENAME
 Includes the file named
@code{FILENAME} at the end of the compiled source file. The include-path
is not searched. This option may be given multiple times.

@item -emit-exports FILENAME
Write exported toplevel variables to @code{FILENAME}.

@item -emit-external-prototypes-first
Emit prototypes for callbacks defined with @code{define-external} before any
other foreign declarations. This is sometimes useful, when C/C++ code embedded into
the a Scheme program has to access the callbacks. By default the prototypes are emitted
after foreign declarations.

@item -explicit-use

Disables automatic use of the units @code{library, eval} and @code{extras}.
Use this option if compiling a library unit instead of an application
unit.

@item -extend FILENAME

Loads a Scheme source file or compiled Scheme program (on systems that
support it) before compilation commences. This feature can be used to
extend the compiler.  This option may be given multiple times.
The file is also searched in the current include path and in the
extension-repository.

@item -extension

Mostly equivalent to @code{-prelude '(define-extension <NAME>)'}, where
@code{<NAME>} is the basename of the currently compiled file.
Note that if you want to compile a file
as a normal (dynamically loadable) extension library, you should also pass the
@code{-shared} option.

@item -feature SYMBOL

Registers @code{SYMBOL} to be a valid feature identifier for
@code{cond-expand}.

@item -ffi

Parse C/C++ code and generate Scheme bindings. This is effectively
equivalent to wrapping the code in @code{#>! ... <#}.

@item -ffi-parse

Parse C/C++ code and embed as if wrapped inside @code{#>? ... <#}.

@item -ffi-define SYMBOL

Defines a macro that will be accessible in @code{foreign-parse}
declarations.

@item -ffi-include-path PATH

Set include path for ``easy'' FFI parser.

@item -ffi-no-include

Don't parse include files when encountered by the FFI parser.

@item -fixnum-arithmetic

Equivalent to @code{(fixnum-arithmetic)} declaration. Assume all
mathematical operations use small integer arguments.

@item -heap-size NUMBER

Sets a fixed heap size of the generated executable to @code{NUMBER}
bytes. The parameter may be followed by a 
@code{M} (@code{m}) or @code{K} (@code{k})
suffix which stand for mega- and kilobytes, respectively.  The default
heap size is 5 kilobytes. Note that only half of it is in use at every
given time.

@item -heap-initial-size NUMBER

Sets the size that the heap of the compiled application should have at
startup time.

@item -heap-growth PERCENTAGE

Sets the heap-growth rate for the compiled program at compile time
(see: @code{-:hg}).

@item -heap-shrinkage PERCENTAGE

Sets the heap-shrinkage rate for the compiled program at compile time
(see: @code{-:hs}).

@item -help

Print a summary of available options and the format of the command line
parameters and exit the compiler.

@item -import FILENAME

Read exports from linked or loaded libraries from given file. See also
@code{-check-imports}. This is equivalent to declaring

@verbatim
(declare (import FILENAME))
@end verbatim

Implies @code{-check-imports}.

@item -include-path PATHNAME

Specifies an additional search path for files included via the
@code{include} special form. This option may be given multiple times. If
the environment variable @code{CHICKEN_INCLUDE_PATH} is set, it
should contain a list of alternative include pathnames separated by
``@code{;}''. The environment variable @code{CHICKEN_HOME} is also
considered as a search path.

@item -inline

Enable procedure inlining for known procedures of a size below the threshold
(which can be set through the @code{-inline-limit} option).

@item -inline-limit THRESHOLD

Sets the maximum size of a potentially inlinable procedure. This option is
only effective when inlining has been enabled with the @code{-inline} option.
The default threshold is @code{10}.

@item -keyword-style STYLE

Enables alternative keyword syntax, where @code{STYLE} may be either
@code{prefix} (as in Common Lisp), @code{suffix} (as in DSSSL) or @code{none}.
Any other value is ignored. The default is @code{suffix}.

@item -lambda-lift

Enable the optimization known as lambda-lifting.

@item -no-lambda-info
Don't emit additional information for each @code{lambda} expression (currently the argument-list,
after alpha-conversion/renaming).

@item -no-trace

Disable generation of tracing information. If a compiled executable should
halt due to a runtime error, then a list of the name and the line-number (if
available) of the last procedure calls is printed, unless @code{-no-trace}
is specified. With this option the generated
code is slightly faster.

@item -no-warnings

Disable generation of compiler warnings.

@item -nursery NUMBER 
@item -stack-size NUMBER

Sets the size of the first heap-generation of the generated executable
to @code{NUMBER} bytes. The parameter may be followed by a @code{M}
(@code{m}) or @code{K} (@code{k}) suffix.  The default stack-size
depends on the target platform.

@item -optimize-leaf-routines

Enable leaf routine optimization.

@item -optimize-level LEVEL

Enables certain sets of optimization options. @code{LEVEL} should be
an integer.


@itemize
@item @code{-optimize-level 0} does nothing.
@item @code{-optimize-level 1} is equivalent to
      @code{-optimize-leaf-routines}
@item @code{-optimize-level 2} is currently the same as @code{-optimize-level 1}
@item @code{-optimize-level 3} is equivalent to
      @code{-optimize-leaf-routines -unsafe}
@end itemize

@item -output-file FILENAME

Specifies the pathname of the generated C file. Default is @code{FILENAME.c}.

@item -postlude EXPRESSIONS

Add @code{EXPRESSIONS} after all other toplevel expressions in the
compiled file.  This option may be given multiple times. Processing of
this option takes place after processing of @code{-epilogue}.

@item -prelude EXPRESSIONS

Add @code{EXPRESSIONS} before all other toplevel expressions in the
compiled file.  This option may be given multiple times. Processing of
this option takes place before processing of @code{-prologue}.

@item -profile
@item -accumulate-profile

Instruments the source code to count procedure calls and execution
times. After the program terminates (either via an explicit @code{exit}
or implicitly), profiling statistics are written to a file named
@code{PROFILE}. Each line of the generated file contains a list with
the procedure name, the number of calls and the time spent executing
it. Use the @code{chicken-profile} program to display the profiling
information in a more user-friendly form. Enter @code{chicken-profile}
with no arguments at the command line to get a list of available options.

The @code{-accumulate-profile} option is similar to @code{-profile}, but
the resulting profile information will be appended to any existing
@code{PROFILE} file. @code{chicken-profile} will merge and sum up the accumulated
timing information, if several entries for the same procedure calls exist.

@item -profile-name FILENAME
Specifies name of the generated profile information (which defaults to
@code{PROFILE}. Implies @code{-profile}.

@item -prologue FILENAME

Includes the file named @code{FILENAME} at the start of the compiled
source file.  The include-path is not searched. This option may be given
multiple times.

@item -quiet

Disables output of compile information.

@item -raw

Disables the generation of any implicit code that uses the Scheme libraries (that
is all runtime system files besides @code{runtime.c} and @code{chicken.h}).

@item -require-extension NAME

Loads the extension @code{NAME} before the compilation process
commences. This is identical to adding @code{(require-extension NAME)} at the start of
the compiled program.

@item -run-time-macros

Makes macros also available
at run-time. By default macros are not available at
run-time.

@item -to-stdout

Write compiled code to standard output instead of creating a @code{.c} file.

@item -unit NAME

Compile this file as a library unit. Equivalent to 

@verbatim
-prelude "(declare (unit NAME))"
@end verbatim

@item -unsafe

Disable runtime safety checks.

@item -unsafe-libraries

Marks the generated file for being linked with the unsafe runtime system. This
should be used when generating shared object files that are to be loaded
dynamically. If the marker is present, any attempt to load code compiled with
this option will signal an error.

@item -uses NAME

Use definitions from the library unit @code{NAME}. This is equivalent to

@verbatim
-prelude "(declare (uses NAME))"
@end verbatim

@item -no-usual-integrations

Specifies that standard procedures and certain internal procedures may
be redefined, and can not be inlined. This is equivalent to declaring
@code{(not usual-integrations)}.

@item -version

Prints the version and some copyright information and exit the compiler.

@item -verbose

Prints progress information to standard output during compilation.

@end table

The environment variable @code{CHICKEN_OPTIONS} can be set to a string
with default command-line options for the compiler.

@node Runtime options
@section Runtime options

After successful compilation a C source file is generated and can be
compiled with a C compiler. Executables generated with CHICKEN (and the
compiler itself) accept a small set of runtime options:

@table @code
@item -:?

Shows a list of the available runtime options and exits the program.

@item -:b

Enter a read-eval-print-loop when an error is encountered.

@item -:c

Forces console mode. Currently this is only used in the interpreter
(@code{csi}) to force output of the @b{#;N>} prompt even if stdin
is not a terminal (for example if running in an @code{emacs} buffer
under Windows).

@item -:d

Prints some debug-information at runtime.

@item -:D

Prints some more debug-information at runtime.

@item -:hNUMBER

Specifies fixed heap size

@item -:hiNUMBER

Specifies the initial heap size

@item -:hgPERCENTAGE

Sets the growth rate of the heap in percent. If the heap is exhausted,
then it will grow by @code{PERCENTAGE}.
The default is 200.

@item -:hmNUMBER

Specifies a maximal heap size. The default is (2GB - 15).

@item -:hsPERCENTAGE

Sets the shrink rate of the heap in percent. If no more than a quarter
of @code{PERCENTAGE} of the heap is used, then it will shrink to
@code{PERCENTAGE}. The default is 50.  Note: If you want to make sure
that the heap never shrinks, specify a value of @code{0}.  (this can
be useful in situations where an optimal heap-size is known in advance).

@item -:o

Disables detection of stack overflows at run-time.

@item -:sNUMBER

Specifies stack size.

@item -:tNUMBER

Specifies symbol table size.

@item -:fNUMBER

Specifies the maximal number of currently pending finalizers before
finalization is forced.

@item -:aNUMBER

Specifies the length of the buffer for recording a trace of the last
invoked procedures. Defaults to 16.

@item -:w

Enables garbage collection of unused symbols. By default unused and
unbound symbols are not garbage collected.

@item -:r

Writes trace output to stderr. This option has no effect with
in files compiled with the @code{-no-trace}
options.

@item -:x

Raises uncaught exceptions of separately spawned threads in primordial thread.
By default uncaught exceptions in separate threads are not handled, unless
the primordial one explicitly joins them. When warnings are enabled (the default)
and @code{-:x} is not given, a warning will be shown, though.

@item -:B

Sounds a bell (ASCII 7) on every major garbage collection.

@end table

The argument values may be given in bytes, in kilobytes (suffixed with
@code{K} or @code{k}), in megabytes (suffixed with @code{M}
or @code{m}), or in gigabytes (suffixed with @code{G}
or @code{g}). Runtime options may be combined, like @code{-:dc},
but everything following a @code{NUMBER} argument is ignored. So
@code{-:wh64m} is OK, but @code{-:h64mw} will not enable GC of
unused symbols.


@node An example
@section An example

To compile a Scheme program (assuming a UNIX-like environment) perform
the following steps:

@itemize

@item Consider this Scheme source file, named @code{foo.scm}
@verbatim
  ;;; foo.scm

  (define (fac n)
    (if (zero? n)
        1
        (* n (fac (- n 1))) ) )

  (write (fac 10))
  (newline)
@end verbatim

@item Compile the file @code{foo.scm}
@verbatim
% csc foo.scm
@end verbatim

@item Start the compiled program
@verbatim
% foo
@end verbatim
@verbatim
3628800
@end verbatim

@end itemize


If multiple bodies of Scheme code are to be combined into a single
executable, then we have to compile each file and link the resulting
object files together with the runtime system: 

@itemize

@item Consider these two Scheme source files, named @code{foo.scm}
and @code{bar.scm}

@verbatim
  ;;; foo.scm

  (declare (uses bar))

  (write (fac 10)) (newline)


  ;;; bar.scm

  (declare (unit bar))

  (define (fac n)
    (if (zero? n)
        1
        (* n (fac (- n 1))) ) )
@end verbatim

@item Compile and link the files @code{foo.scm} and @code{bar.scm}
@verbatim
% csc -c bar.scm
% csc foo.scm bar.o -o foo
@end verbatim

@item Start the compiled program
@verbatim
% foo
3628800

@end verbatim

@end itemize


The declarations specify which of the compiled files is the main
module, and which is the library module. An executable can only have
one main module, since a program has only a single entry-point. In this
case @code{foo.scm} is the main module, because it doesn't have a
@code{unit} declaration.



@node Extending the compiler
@section Extending the compiler


The compiler supplies a couple of hooks to add user-level passes to the
compilation process. Before compilation commences any Scheme source files
or compiled code specified using the @code{-extend} option are loaded
and evaluated.  The parameters @code{user-options-pass, user-read-pass,
user-preprocessor-pass, user-pass, user-pass-2} and @code{user-post-analysis-pass} can be set
to procedures that are called to perform certain compilation passes
instead of the usual processing (for more information about parameters
see: @ref{Parameters}.



@defvr {parameter} user-options-pass
Holds a procedure that will be called with a list of command-line
arguments and should return two values: the source filename and the actual
list of options, where compiler switches have their leading @code{-}
(hyphen) removed and are converted to symbols.  Note that this parameter
is invoked @b{before} processing of the @code{-extend} option,
and so can only be changed in compiled user passes.
@end defvr

@defvr {parameter} user-read-pass
Holds a procedure of three arguments. The first argument is a list
of strings with the code passed to the compiler via @code{-prelude}
options. The second argument is a list of source files including any files
specified by @code{-prologue} and @code{-epilogue}. The third argument
is a list of strings specified using @code{-postlude} options. The
procedure should return a list of toplevel Scheme expressions.
@end defvr

@defvr {parameter} user-preprocessor-pass
Holds a procedure of one argument. This procedure is applied
to each toplevel expression in the source file @b{before}
macro-expansion. The result is macro-expanded and compiled in place of
the original expression.
@end defvr

@defvr {parameter} user-pass
Holds a procedure of one argument. This procedure is applied to each
toplevel expression @b{after} macro-expansion.  The result of the
procedure is then compiled in place of the original expression.
@end defvr

@defvr {parameter} user-pass-2
Holds a procedure of three arguments, which is called with the canonicalized
node-graph as its sole argument. The result is ignored,
so this pass has to mutate the node-structure to cause any effect.
@end defvr

@defvr {parameter} user-post-analysis-pass
Holds a procedure that will be called after the
last performed program analysis. The procedure (when defined) will be
called with three arguments: the program database, a getter and a 
setter-procedure which
can be used to access and manipulate the program database, which
holds various information about the compiled program. The getter procedure
should be called with two arguments: a symbol representing the
binding for which information should be retrieved, and a symbol
that specifies the database-entry. The current value of the database
entry will be returned or @code{#f}, if no such entry is
available. The setter procedure is called with three arguments: the
symbol and key and the new value.

For information about the contents of the program database contact
the author.
@end defvr



Loaded code (via the @code{-extend} option) has access to the library
units @code{extras, srfi-1, srfi-4, utils, regex} and the pattern matching macros. 
Multithreading is not available.


Note that the macroexpansion/canonicalization phase of the compiler adds
certain forms to the source program.  These extra expressions are not
seen by @code{user-preprocessor-pass} but by @code{user-pass}.


@node Distributing compiled C files
@section Distributing compiled C files

It is relatively easy to create distributions of Scheme projects that
have been compiled to C.  The runtime system of CHICKEN consists of only
two handcoded C files (@code{runtime.c} and @code{chicken.h}), plus
the file @code{chicken-config.h}, which is generated by the build process. All
other modules of the runtime system and the extension libraries are just
compiled Scheme code. The following example shows a minimal application, which
should run without changes on the most frequent operating systems, like Windows,
Linux or FreeBSD:

Let's take a simple ``Hello, world!'':

@verbatim
; hello.scm

(print "Hello, world!")
@end verbatim

Compiled to C, we get @code{hello.c}. We need the files @code{chicken.h} and
@code{runtime.c}, which contain the basic runtime system, plus the three basic library
files @code{library.c}, @code{eval.c} and @code{extras.c} which contain the same functionality as the
library linked into a plain CHICKEN-compiled application, or which is available by default in the
interpreter, @code{csi}:

@verbatim
% csc hello.scm -O2 -d1
@end verbatim

A simple makefile is needed as well:

@verbatim
# Makefile for UNIX systems

hello: hello.o runtime.o library.o eval.o extras.o
       $(CC) -o hello hello.o runtime.o library.o eval.o extras.o -lm

hello.o: chicken.h
runtime.o: chicken.h
library.o: chicken.h
eval.o: chicken.h
extras.o: chicken.h
@end verbatim

Now we have all files together, and can create an tarball containing all the files:

@verbatim
% tar cf hello.tar Makefile hello.c runtime.c library.c eval.c extras.c chicken.h
% gzip hello.tar
@end verbatim

This is of naturally rather simplistic. Things like enabling dynamic loading, estimating
the optimal stack-size and selecting supported features of the host system would need
more configuration- and build-time support. All this can be addressed using more
elaborate build-scripts, makefiles or by using autoconf/automake/libtool.

Note also that the size of the application can still be reduced by removing @code{extras} and
@code{eval} and compiling @code{hello.scm} with the @code{-explicit-use} option.

For more information, study the CHICKEN source code
and/or get in contact with the author.


@node Using the interpreter
@chapter Using the interpreter


CHICKEN provides an interpreter named @code{csi} for evaluating Scheme programs
and expressions interactively.

@menu
* Interpreter  command line format::  
* Writing Scheme scripts::      
* Toplevel commands::           
* Macros and procedures implemented in the interpreter::  
@end menu

@node Interpreter  command line format
@section Command line format

@verbatim
  csi {FILENAME|OPTION}
@end verbatim

where @code{FILENAME} specifies a file with Scheme source-code.  If the
extension of the source file is @code{.scm}, it may be omitted. The
runtime options described in @ref{Compiler command line format} are also available
for the interpreter.  If the environment variable @code{CSI_OPTIONS}
is set to a list of options, then these options are additionally passed
to every direct or indirect invocation of @code{csi}. Please note that
runtime options (like @code{-:...}) can not be passed using this method.
The options recognized by the interpreter are:

@table @code

@item --

Ignore everything on the command-line following this marker. Runtime
options (``@code{-:...}'') are still recognized.

@item -i  -case-insensitive

Enables the reader to read symbols case insensitive. The default is to read
case sensitive (in violation of R5RS).  This option registers the @code{case-insensitive}
feature identifier.

@item -b  -batch

Quit the interpreter after processing all command line options.

@item -e  -eval EXPRESSIONS

Evaluate @code{EXPRESSIONS}. This option implies @code{-batch} and @code{-quiet},
so no startup message will be printed and the interpreter exits after processing
all @code{-eval} options and/or loading files given on the command-line.

@item -D  -feature SYMBOL

Registers @code{SYMBOL} to be a valid feature identifier for
@code{cond-expand}.

@item -h  -help

Write a summary of the available command line options to standard output
and exit.

@item -I  -include-path PATHNAME

Specifies an alternative search-path for files included via the
@code{include} special form. This option may be given multiple times. If
the environment variable @code{CHICKEN_INCLUDE_PATH} is set, it
should contain a list of alternative include pathnames separated by
``@b{;}''. The environment variable @code{CHICKEN_HOME} is also
considered as a search path.

@item -k  -keyword-style STYLE

Enables alternative keyword syntax, where @code{STYLE} may be either
@code{prefix} (as in Common Lisp) or @code{suffix} (as in DSSSL).
Any other value is ignored.

@item -n  -no-init

Do not load initialization-file. If this option is not given and the file
@file{./.csirc} or @file{$(HOME)/.csirc} exists, then it is loaded before the read-eval-print
loop commences.

@item -w  -no-warnings

Disables any warnings that might be issued by the reader or evaluated code.

@item -q  -quiet

Do not print a startup message.

@item -s  -script PATHNAME

This is equivalent to @code{-batch -quiet -no-init
PATHNAME}. Arguments following @code{PATHNAME} are available by using
@code{command-line-arguments} and are not processed as interpreter
options. Extra options in the environment variable @code{CSI_OPTIONS}
are ignored.

@item -R  -require-extension NAME

Equivalent to evaluating @code{(require-extension NAME)}.

@item -v  -version

Write the banner with version information to standard output and exit.

@end table

@node Writing Scheme scripts
@section Writing Scheme scripts

@itemize
@item Since UNIX shells use the @code{#!} notation for starting scripts,
anything following the characters @code{#!} is ignored, with the exception of the special
symbols @code{#!optional, #!key, #!rest} and @code{#!eof}.

The easiest way is to use the @code{-script} option like this:

@verbatim
% cat foo
#! /usr/local/bin/csi -script
(print (eval (with-input-from-string
                (car (command-line-arguments))
                 read)))

% chmod +x foo
% foo "(+ 3 4)"
7
@end verbatim

The parameter @code{command-line-arguments} is set to a list of the
parameters that were passed to the Scheme script.  Scripts can be compiled
to standalone executables (don't forget to declare used library units).


@item Windows:

CHICKEN supports writing shell scripts in Scheme for these platforms as well,
using a slightly different approach. The first example would look like
this on Windows:

@verbatim
C:>type foo.bat
@;csibatch %0 %1 %2 %3 %4 %5 %6 %7 %8 %9
(print (eval (with-input-from-string
                (car (command-line-arguments))
                read)))

C:>foo "(+ 3 4)"
7
@end verbatim

Like UNIX scripts, batch files can be compiled. Windows batch scripts do not
accept more than 8 arguments.

@end itemize

@node Toplevel commands
@section Toplevel commands

The toplevel loop understands a number of special commands:

@table @code
@item ,?

Show summary of available toplevel commands.

@item ,l FILENAME ...

Load files with given @code{FILENAME}s

@item ,ln FILENAME ...

Load files and print result(s) of each top-level expression.

@item ,p EXP

Pretty-print evaluated expression @code{EXP}.

@item ,d EXP

Describe result of evaluated expression @code{EXP}.

@item ,du EXP

Dump contents of the result of evaluated expression @code{EXP}.

@item ,dur EXP N

Dump @code{N} bytes of the result of evaluated expression @code{EXP}.

@item ,exn

Describes the last exception that occurred and adds it to the result history
(it can be accessed using the @code{#} notation).

@item ,q

Quit the interpreter.

@item ,r

Show system information.

@item ,s TEXT ...

Execute shell-command.

@item ,t EXP

Evaluate form and print elapsed time.

@item ,x EXP

Pretty-print macroexpanded expression @code{EXP} (the expression is
not evaluated).

@item ,tr SYMBOL ...

Enables tracing of the toplevel procedures with the given names.

@verbatim
#;1> (fac 10)                       ==> 3628800
#;2> ,tr fac
#;3> (fac 3)
|(fac 3)
| (fac 2)
|  (fac 1)
|   (fac 0)
|   fac -> 1 
|  fac -> 1 
| fac -> 2 
|fac -> 6                          ==> 6
#;4> ,utr fac
#;5> (fac 3)                        ==> 6
@end verbatim

@item ,utr SYMBOL ...

Disables tracing of the given toplevel procedures.

@item ,br SYMBOL ...

Sets a breakpoint at the procedures named @code{SYMBOL ...}.

Breakpoint can also be trigged using the @code{breakpoint} procedure.

@item ,ubr SYMBOL ...

Removes breakpoints.

@item ,c

Continues execution from the last invoked breakpoint.

@item ,breakall

Enable breakpoints for all threads (this is the default).

@item ,breakonly THREAD

Enable breakpoints only for the thread returned by the expression @code{THREAD}.

@item ,info

Lists traced procedures and breakpoints.

@item ,step EXPR

Evaluates @code{EXPR} in single-stepping mode. On each procedure call
you will be presented with a menu that allows stepping to the next call,
leaving single-stepping mode or triggering a breakpoint. Note that you will
see some internal calls, and unsafe or heavily optimized compiled code
might not be stepped at all. Single-stepping mode is also possible by
invoking the @code{singlestep} procedure.

@end table

You can define your own toplevel commands using the @code{toplevel-command}
procedure:

@deffn {procedure} toplevel-command
@lisp
(toplevel-command SYMBOL PROC [HELPSTRING])
@end lisp
Defines or defines a toplevel interpreter command the can be invoked by entering
@code{,SYMBOL}. @code{PROC} will be invoked when the command is entered and may
read any required argument via @code{read} (or @code{read-line}). If the optional
argument @code{HELPSTRING} is given, it will be listed by the @code{,?} command.
@end deffn

@node Macros and procedures implemented in the interpreter
@section Macros and procedures implemented in the interpreter

Additional macros and procedures available in the interpreter are:


@deffn {read syntax} #[INDEX]
@lisp
#
#INDEX
@end lisp
Returns the result of entry number @code{INDEX} in the history list. If the expression
for that entry resulted in multiple values, the first result (or an unspecified value for no values)
is returned. If no @code{INDEX} is given (and if a whitespace or closing paranthesis character follows
the @code{#}, then the result of the last expression is returned.
Note that this facility is a reader macro and is implicitly quoted.
@end deffn

@deffn {procedure} set-describer!
@lisp
(set-describer! TAG PROC)
@end lisp
Sets a custom description handler that invokes @code{PROC} when the @code{,d} command is invoked
with a record-type object that has the type @code{TAG} (a symbol). @code{PROC} is called with
two arguments: the object to be described an an output-port and should write a possibly useful
textual description of the object to the passed output-port. For example:

@verbatim
#;1> (define-record point x y)
#;2> (set-describer! 'point (lambda (pt o) (print "a point with x=" (point-x pt) "and y=" (point-y pt))))
#;3> ,d (make-point 1 2)
a point with x=1 and y=2
@end verbatim
@end deffn


@node Supported language
@chapter Supported language

@menu
* Deviations from the standard::  
* Extensions to the standard::  
* Non standard read syntax::    
* Non-standard macros and special forms::
* Pattern Matching::
* Declarations::                
* Parameters::                  
* Unit library::                
* Unit eval::                   
* Unit extras::                 
* Unit srfi-1::                 
* Unit srfi-4::                 
* Unit srfi-13::                
* Unit srfi-14::                
* Unit match::                  
* Unit regex::                  
* Unit srfi-18::                
* Unit posix::                  
* Unit utils::           
* Unit tcp::                    
* Unit lolevel::                
* Unit tinyclos::               
@end menu

@node Deviations from the standard
@section Deviations from the standard

[2] Identifiers are by default case-sensitive.

[4.1.3] The maximal number of arguments that may be passed to a compiled
procedure or macro is 120.  A macro-definition
that has a single rest-parameter can have any number of arguments.

If the @code{libffi} library is available on this platform, and if it
is installed, then CHICKEN can take advantage
of this. See the @code{README} file for more details.

[4.3] @code{syntax-rules} macros are not provided but available separately.

[6.2.4]  The runtime system uses the numerical string-conversion
routines of the underlying C library and so does only understand standard
(C-library) syntax for floating-point constants.

[6.2.5] There is no built-in support for rationals, complex numbers or
extended-precision integers (bignums).
The routines @code{complex?}, @code{real?}
and @code{rational?} are identical to the standard procedure
@code{number?}. The procedures @code{numerator}, @code{denominator},
@code{rationalize}, @code{make-rectangular} and @code{make-polar}
are not implemented.

Support for extended numbers is available as a separate package, provided
the GNU multiprecision library is installed.

[6.2.6] The procedure @code{string->number} does not obey read/write
invariance on inexact numbers.

[6.4] The maximum number of values that can be passed to continuations
captured using @code{call-with-current-continuation} is 120.

[6.5] Code evaluated in @code{scheme-report-environment} or
@code{null-environment} still sees non-standard syntax.

[6.6.2] The procedure @code{char-ready?} always returns
@code{#t} for terminal ports.  The procedure @code{read} does not obey read/write
invariance on inexact numbers.

[6.6.3] The procedures @code{write} and @code{display} do not obey
read/write invariance to inexact numbers.

[6.6.4] The @code{transcript-on} and @code{transcript-off} procedures are
not implemented.


@node Extensions to the standard
@section Extensions to the standard

[2.1] Identifiers may contain special characters if delimited with
@code{| ... |}.

[2.3] The brackets @code{[ ... ]} are provided as an alternative syntax
for @code{( ... )}.  A number of reader extensions is provided. See
@ref{Non standard read syntax}.

[4] Numerous non-standard macros are provided. See @ref{Non-standard
macros and special forms} for more information.

[4.1.4] Extended DSSSL style lambda lists are supported. DSSSL formal argument lists are defined by the following grammar:

@verbatim
<formal-argument-list> ==> <required-formal-argument>*
                           [(#!optional <optional-formal-argument>*)]
                           [(#!rest <rest-formal-argument>)]
                           [(#!key <key-formal-argument>*)]
<required-formal-argument> ==> <ident>
<optional-formal-argument> ==> <ident>
                             | (<ident> <initializer>)
<rest-formal-argument> ==> <ident>
<key-formal-argument> ==> <ident>
                          | (<ident> <initializer>)
<initializer> ==> <expr>
@end verbatim

When a procedure is applied to a list of actual arguments, the formal and actual arguments are processed from left to right as follows:

Variables in required-formal-arguments are bound to successive actual arguments starting with the first actual argument. It shall be an error if there are fewer actual arguments than required-formal-arguments.

Next, variables in optional-formal-arguments are bound to any remaining actual arguments. If there are fewer remaining actual arguments than optional-formal-arguments, then variables are bound to the result of the evaluation of initializer, if one w other@code{#f}. The initializer is evaluated in an environment in which all previous formal arguments have been bound.

If there is a rest-formal-argument, then it is bound to a list of all remaining actual arguments. The remaining actual arguments are also eligible to be bound to keyword-formal-arguments. If there is no rest-formal-argument and there are no keyword- the ibe an error if there are any remaining actual arguments.

If @code{#!key} was specified in the formal-argument-list, there shall be an even number of remaining actual arguments. These are interpreted as a series of pairs, where the first member of each pair is a keyword specifying the argument name, and thorrespalue. It shall be an error if the first member of a pair is not a keyword. It shall be an error if the argument name is not the same as a variable in a keyword-formal-argument, unless there is a rest-formal-argument. If the same argument name occurs more than once in the list of actual arguments, then the first value is used. If there is no actual argument for a particular keyword-formal-argument, then the variable is bound to the result of evaluating initializer if one was specified or @code{#f}. Teiiilzris evaluated in an environment in which all previous formal arguments have been bound. 

It shall be an error for an @code{<ident>} to appear more than once in a formal-argument-list.

Example:

@verbatim
((lambda x x) 3 4 5 6)       => (3 4 5 6)
((lambda (x y #!rest z) z)
 3 4 5 6)                    => (5 6)
((lambda (x y #!optional z #!rest r #!key i (j 1)) 
    (list x y z i: i j: j))
 3 4 5 i: 6 i: 7)            => (3 4 5 i: 6 j: 1)
@end verbatim

[4.1.6] @code{set!} for unbound toplevel variables is allowed. @code{set! (PROCEDURE ...) ...)}
is supported, as CHICKEN implements @uref{http://srfi.schemers.org/srfi-17/srfi-17.html, SRFI-17}.
[4.2.1] The @code{cond} form supports @uref{http://srfi.schemers.org/srfi-61, SRFI-61}.

[4.2.2] It is allowed for initialization values of bindings in a @code{letrec}
construct to refer to previous variables in the same set of bindings, so

@verbatim
(letrec ([foo 123]
         [bar foo] )
  bar)
@end verbatim

is allowed and returns @code{123}.

[4.2.3] @code{(begin)} is allowed in non-toplevel contexts and evaluates
to an unspecified value.

[4.2.5] Delayed expressions may return multiple values.

[5.2.2] CHICKEN extends standard semantics by allowing internal definitions
everywhere, and not only at the beginning of a body. A set of internal definitions
is equivalent to a @code{letrec} form enclosing all following expressions
in the body:

@verbatim
(let ([foo 123])
  (bar)
  (define foo 456)
  (baz foo) )
@end verbatim

expands into

@verbatim
(let ([foo 123])
  (bar)
  (letrec ([foo 456])
    (baz foo) ) )
@end verbatim

[5.2] @code{define} with a single argument is allowed and initializes the toplevel or local binding
to an unspecified value. CHICKEN supports ``curried'' definitions, where the the variable name
may also be a list specifying a name and a nested lambda list. So

@lisp
(define ((make-adder x) y) (+ x y))
@end lisp

is equivalent to

@lisp
(define (make-adder x) (lambda (y) (+ x y)))
@end lisp

[6] CHICKEN provides numerous non-standard procedures. See the manual
sections on library units for more information.

[6.2.4] The special IEEE floating-point numbers ``+nan'', ``+inf'' and ``-inf''
are supported, as is negative zero.

[6.3.4] User defined character names are supported. See
@code{char-name} in @ref{User-defined named characters}. Characters can be given
in hexadecimal notation using the ``#\xXX'' syntax where ``XX'' specifies the 
character code. Character codes above 255 are supported and can be read (and are
written) using the ``#\uXXXX'' and ``#\UXXXXXXXX'' notations.

Non-standard characters names supported are @code{#\tab}, @code{#\linefeed}, @code{#\return}, @code{#\alarm},
@code{#\vtab}, @code{#\nul}, @code{#\page}, @code{#\esc}, @code{#\delete} and @code{#\backspace}.

[6.3.5]  CHICKEN supports special characters preceded with
a backslash ``\'' in quoted string
constants. ``\n'' denotes the newline-character,
``\r'' carriage return, ``\b''
backspace, ``\t'' TAB, ``\v'' vertical TAB, ``\a'' alarm, ``\f'' formfeed,
``\xXX'' a character with the code @code{XX} in hex and 
``\uXXXX'' (and ``\UXXXXXXXX'') a unicode character with the code @code{XXXX}.
The latter is encoded in UTF-8 format.

The third argument to @code{substring} is optional and defaults to the length
of the string.

[6.4] @code{force} called with an argument that is not a promise returns
that object unchanged.  Captured continuations can be safely invoked
inside before- and after-thunks of a @code{dynamic-wind} form and
execute in the outer dynamic context of the @code{dynamic-wind} form.

@b{Implicit} non-multival continuations accept multiple values by discarding all
but the first result. Zero values result in the continuation receiving an
unspecified value. Note that this slight relaxation of the behaviour of
returning mulitple values to non-multival continuations does not apply to
explicit continuations (created with @code{call-with-current-continuation}).

[6.5] The second argument to @code{eval} is optional and
defaults to the value of @code{(interaction-environment)}.
@code{scheme-report-environment} and @code{null-environment} accept
an optional 2nd parameter: if not @code{#f} (which is the default),
toplevel bindings to standard procedures are mutable and new toplevel
bindings may be introduced.

[6.6] The ``tilde'' character (@code{~}) is automatically expanded in pathnames.
Additionally, if a pathname starts with @code{$VARIABLE...}, then the prefix is replaced
by the value of the given environment variable.

[6.6.1] if the procedures @code{current-input-port} and
@code{current-output-port} are called with an argument (which should
be a port), then that argument is selected as the new current input- and
output-port, respectively.  The procedures @code{open-input-file},
@code{open-output-file}, @code{with-input-from-file},
@code{with-output-to-file}, @code{call-with-input-file} and
@code{call-with-output-file} accept an optional second (or third)
argument which should be one or more keywords, if supplied. These
arguments specify the mode in which the file is opened. Possible
values are the keywords @code{#:text}, @code{#:binary} or
@code{#:append}.

@node Non standard read syntax
@section Non standard read syntax 



@deffn {read syntax} {#| @dots{} |#}
A multiline ``block'' comment. May be nested. Implements @uref{http://srfi.schemers.org/srfi-30/srfi-30.html, SRFI-30
})
@end deffn

@deffn {read syntax} {#;EXPRESSION}
Treats @code{EXPRESSION} as a comment.
@end deffn

@deffn {read syntax} {#,(CONSTRUCTORNAME DATUM ...)}
Allows user-defined extension of external representations.
(For more information see the documentation for
@uref{http://srfi.schemers.org/srfi-10/srfi-10.html, SRFI-10 })
@end deffn

@deffn {read syntax} {#'EXPRESSION}
An abbreviation for @code{(syntax EXPRESSION)}.
@end deffn

@deffn {read syntax} {#$EXPRESSION}
An abbreviation for @code{(location EXPRESSION)}.
@end deffn

@deffn {read syntax} {#:SYMBOL}
Syntax for keywords. Keywords are symbols that evaluate to themselves,
and as such don't have to be quoted.
@end deffn

@deffn {read syntax} {#<<TAG}
Specifies a multiline string constant. Anything up to a line equal to
@code{TAG} (or end of file) will be returned as a single string:

@ifhtml
@html
<pre>
(define msg #&lt;&lt;END
"Hello, world!", she said.
END
)
</pre>
@end html
@end ifhtml
@ifnothtml
@verbatim
(define msg #<<END
"Hello, world!", she said.
END
)
@end verbatim
@end ifnothtml

is equivalent to

@verbatim
(define msg "\"Hello, world!\", she said.")
@end verbatim
@end deffn

@deffn {read syntax} #<#TAG
Similar to @code{#<<}, but allows substitution of embedded Scheme
expressions prefixed with @code{#} and optionally enclosed in
@code{@{ @dots{} @}}.  Two consecutive @code{#}s are translated to a
single @code{#}:

@verbatim
(define three 3)
(display #<#EOF
This is a simple string with an embedded `##' character
and substituted expressions: (+ three 99) ==> #(+ three 99)
(three is "#{three}")
EOF
)
@end verbatim

prints

@verbatim
This is a simple string with an embedded `#' character
and substituted expressions: (+ three 99) ==> 102
(three is "3")
@end verbatim
@end deffn

@deffn {read syntax} #> ... <#
Abbreviation for @code{foreign-declare " ... ")}.
@end deffn

@deffn {read syntax} #>? ... <#
Abbreviation for @code{(foreign-parse " ... ")}.
@end deffn

@deffn {read syntax} #>! ... <#
Abbreviation for @code{(foreign-parse(declare " ... ")}.
@end deffn

@deffn {read syntax} #%...
Reads like a normal symbol.
@end deffn

@deffn {read syntax} #!...
Treated as a commment and ignores everything up the end of the current line.
The keywords @code{#!optional, #!rest} and @code{#!key} are handled separately and
returned as normal symbols.
The special (self-evaluating) symbol @code{#!eof} is read as the end-of-file object.
Note that if this constant appears at top-level in a loaded file, it is indistiguishable
from normal end-of-file.
@end deffn

@deffn {read syntax} #cs...
Read the next expression in case-sensitive mode (regardless of the current global setting).
@end deffn

@deffn {read syntax} #ci...
Read the next expression in case-insensitive mode (regardless of the current global setting).
@end deffn

@deffn {read syntax} #+FEATURE EXPR
Equivalent to 

@lisp
(cond-expand (FEATURE EXPR) (else))
@end lisp
@end deffn



@node Non-standard macros and special forms
@section Non-standard macros and special forms 

@menu
* Making extra libraries and extensions available::
* Binding forms for optional arguments::  
* Other binding forms::         
* Substitution forms and macros::  
* Conditional forms::           
* Record structures::           
* Other forms::                 
@end menu


@node Making extra libraries and extensions available
@subsection Making extra libraries and extensions available


@deffn {syntax} require-extension
@deffnx {syntax} use
@lisp
(require-extension ID ...)
(use ID ...)
@end lisp
This form does all necessary steps to make the libraries or extensions given
in @code{ID ...} available. It loads syntactic extension, if needed and generates
code for loading/linking with core library modules or separately installed
extensions. @code{use} is just a shorter alias for @code{require-extension}.
This implementation of @code{require-extension} is compliant to SRFI-55
(see @uref{http://srfi.schemers.org/srfi-16/srfi-16.html, SRFI-55 } for more information).

During interpretation/evaluation @code{require-extension} performs one of the
following:

@itemize
@item If @code{ID} names a built in features @code{chicken srfi-23 srfi-30 srfi-39 srfi-8 srfi-6 srfi-2 srfi-0 srfi-10 
srfi-9 srfi-17 srfi-55}, then nothing is done.
@item If @code{ID} names one of syntactic extensions @code{chicken-more-macros chicken-ffi-macros}, then this extension will be loaded.
@item If @code{ID} names one of the core library units shipped with CHICKEN, then a @code{(load-library 'ID)} will be performed.
@item If @code{ID} names an installed extension with the @code{syntax} or @code{require-at-runtime} attribute, then
the equivalent of @code{(require-for-syntax 'ID)} is performed.
@item Otherwise @code{(require-extension ID)} is equivalent to @code{(require 'ID)}.
@end itemize

During compilation one of the following happens instead:

@itemize
@item If @code{ID} names a built in features @code{chicken srfi-23 srfi-30 srfi-39 srfi-8 srfi-6 srfi-2 srfi-0 srfi-10 
 srfi-9 srfi-17 srfi-55}, then nothing is done.
@item If @code{ID} names one of syntactic extensions @code{chicken-more-macros chicken-ffi-macros}, then this extension will be loaded 
 at compile-time, making the syntactic extensions available in compiled code.
@item If @code{ID} names one of the core library units shipped with CHICKEN, then a @code{(declare (uses ID))} is generated.
@item If @code{ID} names an installed extension with the @code{syntax} or @code{require-at-runtime} attribute, then
 the equivalent of @code{(require-for-syntax 'ID)} is performed.
@item Otherwise @code{(require-extension ID)} is equivalent to @code{(require 'ID)}.
@end itemize

To make long matters short - just use @code{require-extension} and it will normally figure everything out for dynamically
loadable extensions and core library units.

@code{ID} should be a pure extension name and should not contain any path prefixes (for example @code{dir/lib...}) is illegal).

@code{ID} may also be a list that designates an extension-specifier. Currently the following extension specifiers are
defined:

@itemize
@item @code{(srfi NUMBER ...)} is required for SRFI-55 compatibility and is fully implemented
@item @code{(version ID NUMBER)} is equivalent to @code{ID}, but checks at compile-time whether the extension named
@code{ID} is installed and whether its version is equal or higher than @code{NUMBER}. @code{NUMBER} may be a string or a number,
the comparison is done lexicographically (using @code{string>=?}).
@end itemize

See also: @code{set-extension-specifier!}

@end deffn

@deffn {syntax} define-extension
@lisp
(define-extension NAME CLAUSE ...)
@end lisp
This macro simplifies the task of writing extensions that can be linked both statically and dynamically.
If encountered in interpreted code or code that is compiled into a shared object (specifically if compiled
with the feature @code{chicken-compile-shared}, done automatically by @code{csc} when compiling with
the @code{-shared} or @code{-dynamic} option) then the code given by clauses if the form

@verbatim
(dynamic EXPRESSION ...)
@end verbatim

is inserted into the output as a @code{begin} form.

If compiled statically (specifically if the feature @code{chicken-compiled-shared} has not been given), then
this form expands into the following:

@verbatim
(declare (unit NAME))
(provide 'NAME)
@end verbatim

and all clauses of the form

@verbatim
(static EXPRESSION ...)
@end verbatim

all additionally inserted into the expansion.

As a convenience, the clause

@verbatim
(export IDENTIFIER ...)
@end verbatim

is also allowed and is identical to @code{(declare (export IDENTIFIER ...))} (unless the @code{define-extension} form
occurs in interpreted code, in with it is simply ignored).

Note that the compiler option @code{-extension NAME} is equivalent to prefixing the
compiled file with 

@lisp
(define-extension NAME)
@end lisp
@end deffn


@node Binding forms for optional arguments
@subsection Binding forms for optional arguments



@deffn {syntax} :optional
@lisp
(:optional ARGS DEFAULT)
@end lisp
Use this form for procedures that take a single optional argument. If
@code{ARGS} is the empty list @code{DEFAULT} is evaluated and
returned, otherwise the first element of the list @code{ARGS}. It is
an error if @code{ARGS} contains more than one value.

@verbatim
(define (incr x . i) (+ x (:optional i 1)))
(incr 10)                                   ==> 11
(incr 12 5)                                 ==> 17
@end verbatim

@end deffn
@deffn {syntax} case-lambda
@lisp
(case-lambda (LAMBDA-LIST1 EXP1 ...) ...)
@end lisp
SRFI-16. Expands into a lambda that invokes the body following the first
matching lambda-list.

@verbatim
(define plus
  (case-lambda 
    (() 0)
    ((x) x)
    ((x y) (+ x y))
    ((x y z) (+ (+ x y) z))
    (args (apply + args))))

(plus)                      ==> 9
(plus 1)                    ==> 1
(plus 1 2 3)                ==> 6
@end verbatim

For more information see the documentation for
@uref{http://srfi.schemers.org/srfi-16/srfi-16.html, SRFI-16 }

@end deffn
@deffn {syntax} let-optionals
@deffnx {syntax} let-optionals*
@lisp
(let-optionals ARGS ((VAR1 DEFAULT1) ...) BODY ...)
(let-optionals* ARGS ((VAR1 DEFAULT1) ... [RESTVAR]) BODY ...)
@end lisp
Binding constructs for optional procedure arguments. @code{ARGS} should
be a rest-parameter taken from a lambda-list. @code{let-optionals}
binds @code{VAR1 ...} to available arguments in parallel, or
to @code{DEFAULT1 ...} if not enough arguments were provided.
@code{let-optionals*} binds @code{VAR1 ...} sequentially, so every
variable sees the previous ones. If a single variable @code{RESTVAR}
is given, then it is bound to any remaining arguments, otherwise it is
an error if any excess arguments are provided.

@verbatim
(let-optionals '(one two) ((a 1) (b 2) (c 3))
  (list a b c) )                               ==> (one two 3)
(let-optionals* '(one two) ((a 1) (b 2) (c a))
  (list a b c) )                               ==> (one two one)
@end verbatim
@end deffn



@node Other binding forms
@subsection Other binding forms



@deffn {syntax} and-let*
@lisp
(and-let* (BINDING ...) EXP1 EXP2 ...)
@end lisp
SRFI-2. Bind sequentially and execute body. @code{BINDING} can
be a list of a variable and an expression, a list with a single
expression, or a single variable. If the value of an expression
bound to a variable is @code{#f}, the @code{and-let*} form
evaluates to @code{#f} (and the subsequent bindings and the body
are not executed).  Otherwise the next binding is performed. If
all bindings/expressions evaluate to a true result, the body is
executed normally and the result of the last expression is the
result of the @code{and-let*} form. See also the documentation for
@uref{http://srfi.schemers.org/srfi-2/srfi-2.html, SRFI-2 }.

@end deffn

@deffn {syntax} rec
@lisp
(rec NAME EXPRESSION)
(rec (NAME VARIABLE ...) BODY ...)
@end lisp
Allows simple definition of recursive definitions. @code{(rec NAME EXPRESSION)} is
equivalent to @code{(letrec ((NAME EXPRESSION)) NAME)} and @code{(rec (NAME VARIABLE ...) BODY ...)}
is the same as @code{(letrec ((NAME (lambda (VARIABLE ...) BODY ...))) NAME)}.
@end deffn

@deffn {syntax} cut
@deffnx {syntax} cute
@lisp
(cut SLOT ...)
(cute SLOT ...)
@end lisp
@uref{http://srfi.schemers.org/srfi-26/srfi-26.html, Syntactic sugar for specializing parameters.}

@end deffn
@deffn {syntax} define-values
@lisp
(define-values (NAME ...) EXP)
@end lisp
Defines several variables at once, with the result values of expression
@code{EXP}.

@end deffn
@deffn {syntax} fluid-let
@lisp
(fluid-let ((VAR1 X1) ...) BODY ...)
@end lisp
Binds the variables @code{VAR1 ...} dynamically to the values @code{X1 ...} 
during execution of @code{BODY ...}.

@end deffn
@deffn {syntax} let-values
@lisp
(let-values (((NAME ...) EXP) ...) BODY ...)
@end lisp
Binds multiple variables to the result values of @code{EXP ...}.
All variables are bound simultaneously.

@end deffn
@deffn {syntax} let*-values
@lisp
(let*-values (((NAME ...) EXP) ...) BODY ...)
@end lisp
Binds multiple variables to the result values of @code{EXP ...}.
The variables are bound sequentially.
@verbatim
(let*-values (((a b) (values 2 3))
              ((p) (+ a b)) )
  p)                               ==> 5
@end verbatim

@end deffn
@deffn {syntax} letrec-values
@lisp
(letrec-values (((NAME ...) EXP) ...) BODY ...)
@end lisp
Binds the result values of @code{EXP ...} to multiple variables at once.
All variables are mutually recursive.
@verbatim
(letrec-values (((odd even)
                   (values 
                     (lambda (n) (if (zero? n) #f (even (sub1 n))))
                     (lambda (n) (if (zero? n) #t (odd (sub1 n)))) ) ) )
  (odd 17) )                           ==> #t
@end verbatim

@end deffn
@deffn {syntax} parameterize
@lisp
(parameterize ((PARAMETER1 X1) ...) BODY ...)
@end lisp
Binds the parameters @code{PARAMETER1 ...} dynamically to the values
@code{X1 ...} during execution of @code{BODY ...}.  (see also:
@code{make-parameter} in @ref{Parameters}). Note that @code{PARAMETER} may be any
expression that evaluates to a parameter procedure.

@end deffn
@deffn {syntax} receive
@lisp
(receive (NAME1 ... [. NAMEn]) VALUEEXP BODY ...)
(receive VALUEEXP)
@end lisp
SRFI-8. Syntactic sugar for @code{call-with-values}. Binds variables
to the result values of @code{VALUEEXP} and evaluates @code{BODY ...}.

The syntax 

@verbatim
(receive VALUEEXP)
@end verbatim

is equivalent to

@verbatim
(receive _ VALUEEXP _)
@end verbatim

@end deffn
@deffn {syntax} set!-values
@lisp
(set!-values (NAME ...) EXP)
@end lisp
Assigns the result values of expression @code{EXP} to multiple
variables.
@end deffn



@node Substitution forms and macros
@subsection Substitution forms and macros



@deffn {syntax} define-constant
@lisp
(define-constant NAME CONST)
@end lisp
Define a variable with a constant value, evaluated at compile-time. 
Any reference to such a
constant should appear textually @b{after} its definition. This
construct is equivalent to @code{define} when evaluated or interpreted.
Constant definitions should only appear at toplevel. Note that constants
are local to the current compilation unit and are not available outside
of the source file in which they are defined. Names of constants still
exist in the Scheme namespace and can be lexically shadowed.  If the
value is mutable, then the compiler is careful to preserve its identity.
@code{CONST} may be any constant expression, and may also refer to
constants defined via @code{define-constant} previously.
This for should only be used at top-level.

@end deffn
@deffn {syntax} define-inline
@lisp
(define-inline (NAME VAR ... [. VAR]) BODY ...)
(define-inline NAME EXP)
@end lisp
Defines an inline procedure. Any occurrence of @code{NAME} will be
replaced by @code{EXP} or @code{(lambda (VAR ... [. VAR]) BODY ...)}. 
This is similar to a macro, but variable-names and -scope will
be correctly handled.  Inline substitutions take place @b{after}
macro-expansion.  @code{EXP} should be a lambda-expression. Any
reference to @code{NAME} should appear textually @b{after}
its definition. Note that inline procedures are local to the current
compilation unit and are not available outside of the source file in
which they are defined. Names of inline procedures still exist in the
Scheme namespace and can be lexically shadowed.  This construct is
equivalent to @code{define} when evaluated or interpreted. Inline
definitions should only appear at toplevel.

@end deffn
@deffn {syntax} define-macro
@lisp
(define-macro (NAME VAR ... [. VAR]) EXP1 ...)
(define-macro NAME (lambda (VAR ... [. VAR]) EXP1 ...))
(define-macro NAME1 NAME2)
@end lisp
Define a globally visible macro special form. The macro is available
as soon as it is defined, i.e. it is registered at compile-time. If
the file containing this definition invokes @code{eval} and the
declaration @code{run-time-macros} (or the command line option
@code{-run-time-macros}) has been used, then the
macro is visible in evaluated expressions during runtime. The second
possible syntax for @code{define-macro} is allowed for portability
purposes only. In this case the second argument @b{must} be a
lambda-expression or a macro name.  Only global macros can be defined using this form.
@code{(define-macro NAME1 NAME2)} simply copies the macro definition
from @code{NAME2} to @code{NAME1}, creating an alias.

Extended lambda list syntax (@code{#!optional}, etc.) can be used but note
that arguments are source expressions and thus default values for optional
or keyword arguments should take this into consideration.

@end deffn

@deffn {syntax} define-for-syntax
@lisp
(define-for-syntax (NAME VAR ... [. VAR]) EXP1 ...)
(define-for-syntax NAME [VALUE])
@end lisp
Defines the toplevel variable @code{NAME} at macro-expansion time. This can
be helpful when you want to define support procedures for use in macro-transformers,
for example.
@end deffn

@node Conditional forms
@subsection Conditional forms



@deffn {syntax} switch
@lisp
(switch EXP (KEY EXP1 ...) ... [(else EXPn ...)])
@end lisp
This is similar to @code{case}, but a) only a single key is allowed,
and b) the key is evaluated.

@end deffn
@deffn {syntax} unless
@lisp
(unless TEST EXP1 EXP2 ...)
@end lisp
Equivalent to: 
@verbatim
(if (not TEST) (begin EXP1 EXP2 ...))
@end verbatim

@end deffn
@deffn {syntax} when
@lisp
(when TEST EXP1 EXP2 ...)
@end lisp
Equivalent to:
@verbatim
(if TEST (begin EXP1 EXP2 ...))
@end verbatim
@end deffn



@node Record structures
@subsection Record structures



@deffn {syntax} define-record
@lisp
(define-record NAME SLOTNAME ...)
@end lisp
Defines a record type. Call @code{make-NAME} to create an instance
of the structure (with one initialization-argument for each slot).
@code{(NAME? STRUCT)} tests any object for being an instance of this
structure.  Slots are accessed via @code{(NAME-SLOTNAME STRUCT)}
and updated using @code{(NAME-SLOTNAME-set!} @code{STRUCT} @code{VALUE)}.

@verbatim
(define-record point x y)
(define p1 (make-point 123 456))
(point? p1)                      ==> #t
(point-x p1)                     ==> 123
(point-y-set! p1 99)
(point-y p1)                     ==> 99
@end verbatim

@end deffn
@deffn {syntax} define-record-printer
@lisp
(define-record-printer (NAME RECORDVAR PORTVAR) BODY ...)
(define-record-printer NAME PROCEDURE)
@end lisp
Defines a printing method for record of the type @code{NAME} by
associating a procedure with the record type. When a record of this
type is written using @code{display, write} or @code{print}, then
the procedure is called with two arguments: the record to be printed
and an output-port.

@verbatim
(define-record foo x y z)
(define f (make-foo 1 2 3))
(define-record-printer (foo x out)
  (fprintf out "#,(foo ~S ~S ~S)"
           (foo-x x) (foo-y x) (foo-z x)) )
(define-reader-ctor 'foo make-foo)
(define s (with-output-to-string
              (lambda () (write f))))
s                                   ==> "#,(foo 1 2 3)"
(equal? f (with-input-from-string
              s read)))             ==> #t
@end verbatim

@code{define-record-printer} works also with SRFI-9 record types.

@end deffn
@deffn {syntax} define-record-type
@lisp
(define-record-type NAME (CONSTRUCTOR TAG ...) PREDICATE
                    (FIELD ACCESSOR [MODIFIER]) ...)
@end lisp
SRFI-9 record types. For more information see the documentation for
@uref{http://srfi.schemers.org/srfi-9/srfi-9.html, SRFI-9 }.
@end deffn


@node Other forms
@subsection Other forms



@deffn {syntax} assert
@lisp
(assert EXP [STRING ARG ...])
@end lisp
Signals an error if @code{EXP} evaluates to false. An optional message
@code{STRING} and arguments @code{ARG ...} may be supplied to give a
more informative error-message.  If compiled in @emph{unsafe} mode (either
by specifying the @code{-unsafe} compiler option or by declaring
@code{(unsafe)}), then this expression expands to an unspecified value.
The result is the value of @code{EXP}.

@end deffn
@deffn {syntax} cond-expand
@lisp
(cond-expand FEATURE-CLAUSE ...)
@end lisp
SRFI-0. Expands by selecting feature clauses. Predefined
feature-identifiers are @code{srfi-0}, @code{srfi-2}, @code{srfi-6},
@code{srfi-8}, @code{srfi-9}, @code{srfi-10},
 and @code{chicken}. If the source file containing
this form is currently compiled, the feature @code{compiling}
is defined.  For further information, see the documentation for
@uref{http://srfi.schemers.org/srfi-0/srfi-0.html, SRFI-0 } This form
is allowed to appear in non-toplevel expressions.

@end deffn
@deffn {syntax} ensure
@lisp
(ensure PREDICATE EXP [ARGUMENTS ...])
@end lisp
Evaluates the expression @code{EXP} and applies the one-argument
procedure @code{PREDICATE} to the result. If the predicate returns
@code{#f} an error is signaled, otherwise the result of @code{EXP}
is returned.  If compiled in @emph{unsafe} mode (either by specifying
the @code{-unsafe} compiler option or by declaring @code{(unsafe)}),
then this expression expands to an unspecified value.  If specified,
the optional @code{ARGUMENTS} are used as arguments to the invocation
of the error-signalling code, as in @code{(error ARGUMENTS ...)}. If
no @code{ARGUMENTS} are given, a generic error message is displayed
with the offending value and @code{PREDICATE} expression.

@end deffn
@deffn {syntax} eval-when
@lisp
(eval-when (SITUATION ...) EXP ...)
@end lisp
Controls evaluation/compilation of subforms. @code{SITUATION} should
be one of the symbols @code{eval}, @code{compile} or @code{load}.
When encountered in the evaluator, and the situation specifier
@code{eval} is not given, then this form is not evaluated and an
unspecified value is returned.  When encountered while compiling code,
and the situation specifier @code{compile} is given, then this form is
evaluated at compile-time.  When encountered while compiling code, and the
situation specifier @code{load} is not given, then this form is ignored
and an expression resulting into an unspecified value is compiled instead.

The following table should make this clearer:

@multitable {compile} {evaluate at compile time} {In interpreted code}
@item                @tab in compiled code         @tab In interpreted code
@item @code{eval}    @tab ignore                   @tab evaluate 
@item @code{compile} @tab evaluate at compile time @tab ignore 
@item @code{load}    @tab compile as normal        @tab ignore 
@end multitable

The situation specifiers @code{compile-time} and @code{run-time} are also
defined and have the same meaning as @code{compile} and @code{load}, respectively.

@end deffn
@deffn {syntax} include
@lisp
(include STRING)
@end lisp
Include toplevel-expressions from the given source file in the currently
compiled/interpreted program.  If the included file has the extension
@code{.scm}, then it may be omitted.  The file is searched in the
current directory and, if not found, in all directories specified in the
@code{-include-path} option.

@end deffn
@deffn {syntax} nth-value
@lisp
(nth-value N EXP)
@end lisp
Returns the @code{N}th value (counting from zero) of the values returned
by expression @code{EXP}.

@end deffn
@deffn {syntax} time
@lisp
(time EXP1 ...)
@end lisp
Evaluates @code{EXP1 ...} and prints elapsed time and some
values about GC use, like time spent in major GCs, number of minor
and major GCs.
@end deffn


@node Pattern Matching
@section Pattern Matching

(This description has been taken mostly from Andrew Wright's postscript
document)

Pattern matching allows complicated control decisions based on data
structure to be expressed in a concise manner.  Pattern matching is
found in several modern languages, notably Standard ML, Haskell and
Miranda. These syntactic extensions internally use the @code{match}
library unit.

The basic form of pattern matching expression is:
@lisp
(match exp [pat body] ...)
@end lisp

where @code{exp} is an expression, @code{pat} is a pattern, and
@code{body} is one or more expressions
(like the body of a lambda-expression).
The @code{match} form matches its first subexpression against a sequence
of patterns, and branches to the @code{body}
corresponding to the first pattern successfully matched.
For example, the following code defines the usual @code{map} function:

@lisp
(define map
  (lambda (f l)
    (match l
      [() ()]
      [(x . y) (cons (f x) (map f y))])))
@end lisp

The first pattern @code{()} matches the empty list.  The second pattern
@code{(x . y)} matches a pair, binding @code{x} to the first component of
the pair and @code{y} to the second component of the pair.


@subsection Pattern Matching Expressions

The complete syntax of the pattern matching expressions follows:

@verbatim
exp ::= (match exp clause ...)
     |  (match-lambda clause ...)
     |  (match-lambda* clause ...)
     |  (match-let ([pat exp] ...) body)
     |  (match-let* ([pat exp] ...) body)
     |  (match-letrec ([pat exp] ...) body)
     |  (match-let var ([pat exp] ...) body)
     |  (match-define pat exp)

clause ::= [pat body]
        |  [pat (=> identifier) body]

pat ::= identifier           matches anything, and binds identifier as a variable
     |  _                    anything
     |  ()                   itself (the empty list)
     |  #t                   itself
     |  #f                   itself
     |  string               an `equal?' string
     |  number               an `equal?' number
     |  character            an `equal?' character
     |  's-expression        an `equal?' s-expression
     |  (pat-1 ... pat-n)    a proper list of n elements
     |  (pat-1 ... pat-n . pat-n+1)  
                             a list of n or more elements
     |  (pat-1 ... pat-n pat-n+1 ..k)  
                             a proper list of n+k or more elements [1]
     |  #(pat-1 ... pat-n)   a vector of n elements
     |  #(pat-1 ... pat-n pat-n+1 ..k)  
                             a vector of n+k or more elements
     |  ($ struct pat-1 ... pat-n)  
                             a structure
     |  (= field pat)        a field of a structure
     |  (and pat-1 ... pat-n)  
                             if all of pat-1 through pat-n match
     |  (or pat-1 ... pat-n) 
                             if any of pat-1 through pat-n match
     |  (not pat-1 ... pat-n)
                             if none of pat-1 through pat-n match
     |  (? predicate pat-1 ... pat-n)  
                             if predicate true and pat-1 through pat-n all match
     |  (set! identifier)    anything, and binds identifier as a setter
     |  (get! identifier)    anything, and binds identifier as a getter
     |  `qp                  a quasipattern

qp ::= ()                    itself (the empty list)
    |  #t                    itself
    |  #f                    itself
    |  string                an `equal?' string
    |  number                an `equal?' number
    |  character             an `equal?' character
    |  symbol                an `equal?' symbol
    |  (qp-1 ... qp-n)       a proper list of n elements
    |  (qp-1 ... qp-n . qp-n+1)  
                             a list of n or more elements
    |  (qp-1 ... qp-n qp-n+1 ..k)  
                             a proper list of n+k or more elements
    |  #(qp-1 ... qp-n)      a vector of n elements
    |  #(qp-1 ... qp-n qp-n+1 ..k)  
                             a vector of n+k or more elements
    |  ,pat                  a pattern
    |  ,@pat                 a pattern, spliced
@end verbatim

The notation @code{..k} denotes a keyword consisting of
three consecutive dots (ie., ``@code{...}''), 
or two dots and an non-negative integer (eg., ``@code{..1}'', ``@code{..2}''),
or three consecutive underscores (ie., ``@code{___}''),
or two underscores and a non-negative integer.
The keywords ``@code{..k}'' and ``@code{__ k}'' are equivalent.
The keywords ``@code{...}'', ``@code{___}'', ``@code{..0}'', and ``@code{__0}''
are equivalent.

The next subsection describes the various patterns.

The @code{match-lambda} and @code{match-lambda*} forms are convenient
combinations of @code{match} and @code{lambda}, and can be explained
as follows:

@lisp
(match-lambda [pat body] ...)   =  (lambda (x) (match x [pat body] ...))
(match-lambda* [pat body] ...)  =  (lambda x (match x [pat body] ...))
@end lisp

where @code{x} is a unique variable.
The @code{match-lambda} form is convenient when defining a single argument
function that immediately destructures its argument.
The @code{match-lambda*} form constructs a function that accepts any number
of arguments; the patterns of @code{match-lambda*} should be lists.

The @code{match-let}, @code{match-let*}, @code{match-letrec},
and @code{match-define} forms generalize
Scheme's @code{let}, @code{let*}, @code{letrec}, and @code{define}
expressions to allow
patterns in the binding position rather than just variables.
For example, the following expression:

@lisp
(match-let ([(x y z) (list 1 2 3)]) body ...)
@end lisp

binds @code{x} to 1, @code{y} to 2, and @code{z} to 3 in @code{body ...}.
These forms are convenient for destructuring the result
of a function that returns multiple values as a list or vector.
As usual for @code{letrec} and @code{define},
pattern variables bound by @code{match-letrec} and @code{match-define}
should not be used in computing the bound value.

The @code{match}, @code{match-lambda}, and @code{match-lambda*} forms
allow the optional syntax @code{(=> identifier)} between the pattern
and the body of a clause.  When the pattern match for such a clause
succeeds, the @code{identifier} is bound to a `failure
procedure' of zero arguments within the @code{body}.  If this
procedure is invoked, it jumps back to the pattern matching
expression, and resumes the matching process as if the pattern had
failed to match.  The @code{body} must not mutate the object being
matched, otherwise unpredictable behavior may result.


@subsection Patterns

@code{identifier}: (excluding the reserved names
@code{?}, @code{,}, @code{=}, @code{_}, @code{and}, @code{or}, @code{not}, @code{set!}, @code{get!}, @code{...}, and
@code{..k} for non-negative integers @code{k})
matches anything, and binds a variable of this name to
the matching value in the @code{body}.

@code{_}:
matches anything, without binding any variables.

@code{()}, @code{#t}, @code{#f}, @code{string}, @code{number},
@code{character}, '@code{s-expression}:
These constant patterns match themselves, i.e.,
the corresponding value must be @code{equal?} to the pattern.

@code{(pat-1 ... pat-n)}:
matches a proper list of @code{n} elements
that match @code{pat-1} through @code{pat-n}.

@code{(pat-1 ... pat-n . pat-n+1)}:
matches a (possibly improper) list of at least @code{n}
elements that ends in
something matching @code{pat-n+1}.

@code{(pat-1 ... pat-n pat-n+1 ...)}:
matches a proper list of @code{n} or more elements, where
each element of the tail matches @code{pat-n+1}.  Each pattern variable in
@code{pat-n+1} is bound to a list of the matching values.  For example,
the expression:

@lisp
(match '(let ([x 1][y 2]) z)
  [('let ((binding values) ...) exp)  body])
@end lisp

binds @code{binding} to the list @code{'(x y)},
@code{values} to the list \@code{'(1 2)},
and @code{exp} to @code{'z}
in the body of the @code{match}-expression.
For the special case where @code{pat-n+1} is a pattern variable, the list
bound to that variable may share with the matched value.

@code{(pat-1 ... pat-n pat-n+1 ___)}:
This pattern means the same thing as the previous pattern.

@code{(pat-1 ... pat-n pat-n+1 ..k)}:
This pattern is similar to the previous pattern, but the tail must be
at least @code{k} elements long.
The pattern keywords @code{..0} and @code{...} are equivalent.

@code{(pat-1 ... pat-n ~ pat-n+1 __k)}:
This pattern means the same thing as the previous pattern.

@code{#(pat-1 ... pat-n)}:
matches a vector of length @code{n}, whose elements match
@code{pat-1} through @code{pat-n}.

@code{#(pat-1 ... pat-n pat-n+1 ...)}:
matches a vector of length @code{n} or more, where each element
beyond @code{n} matches @code{pat-n+1}.

@code{#(pat-1 ... pat-n pat-n+1 ..k)}:
matches a vector of length @code{n+k} or more, where each element
beyond @code{n} matches @code{pat-n+1}.

@code{($ struct pat-1 ... pat-n)}:
matches a structure
declared with @code{define-record} or @code{define-record-type}.

@code{(= field pat)}:
is intended for selecting a field from a structure.  ``field'' may be
any expression; it is applied to the value being matched, and the
result of this application is matched against @code{pat}.

@code{(and pat-1 ... pat-n)}:
matches if all of the subpatterns match.
At least one subpattern must be present.
This pattern is often used as @code{(and x pat)} to bind @code{x} to
to the entire value that matches @code{pat}
(cf. ``as-patterns'' in ML or Haskell).

@code{(or pat-1 ... pat-n)}:
matches if any of the subpatterns match.
At least one subpattern must be present.
All subpatterns must bind the same set of pattern variables.

@code{(not pat-1 ... pat-n)}:
matches if none of the subpatterns match.
At least one subpattern must be present.
The subpatterns may not bind any pattern variables.

@code{(? predicate pat-1 ... pat-n)}:
In this pattern,
@code{predicate} must be an expression evaluating to a single argument
function.
This pattern matches if @code{predicate} applied to the corresponding value
is true, and the subpatterns @code{pat-1 ... pat-n} all match.
The @code{predicate} should not have side effects, as
the code generated by the pattern matcher may invoke predicates repeatedly
in any order.
The @code{predicate} expression is bound in the same scope as the
match expression, i.e.,
free variables in @code{predicate} are not bound by pattern variables.

@code{(set! identifier)}:
matches anything, and binds @code{identifier}
to a procedure of one argument that mutates the corresponding field of
the matching value.
This pattern must be nested within a pair, vector, box, or structure
pattern. For example, the expression:

@lisp
(define x (list 1 (list 2 3)))
(match x [(_ (_ (set! setit)))  (setit 4)])
@end lisp

mutates the @code{cadadr} of @code{x} to 4, so that @code{x} is
@code{'(1 (2 4))}.

@code{(get! identifier)}:
matches anything, and binds @code{identifier}
to a procedure of zero arguments that accesses the corresponding field of
the matching value.  This pattern is the complement to @code{set!}.
As with @code{set!},
this pattern must be nested within a pair, vector, box, or structure
pattern.

@emph{Quasipatterns}:
Quasiquote introduces a quasipattern, in which identifiers are considered
to be symbolic constants.  Like Scheme's quasiquote for data,
@code{unquote} (,) and @code{unquote-splicing} (,@@) escape back to
normal patterns.


@subsection Match Failure

If no clause matches the value, the default action 
is to invoke the procedure @code{##sys#match-error}
with the value that did not match.  The default definition of
@code{##sys#match-error} calls @code{error} with an appropriate message:

@verbatim
#;1> (match 1 (2 2))

Failed match:
Error: no matching clause for : 1
@end verbatim

For most situations, this behavior is adequate, but it can be changed
by altering the value of the parameter @code{match-error-control}:

@deffn {procedure} match-error-control
@lisp
(match-error-control [MODE])
@end lisp
Selects a mode that specifies how @code{match...} macro forms are to
be expanded.  With no argument this procedure returns the current mode. A
single argument specifies the new mode that decides what should happen
if no match-clause applies.  The following modes are supported:

@table @code

@item #:error

Signal an error. This is the default.

@item #:match

Signal an error and output the offending form.

@item #:fail

Omits @code{pair?} tests when the consequence is to fail in @code{car}
or @code{cdr} rather than to signal an error.

@item #:unspecified

Non-matching expressions will either fail in @code{car} or @code{cdr}
or return an unspecified value.  This mode applies to files compiled
with the @code{unsafe} option or declaration.

@end table

When an error is signalled, the raised exception will be of kind @code{(exn match)}.

@end deffn


Note: the @code{$} pattern handles native record structures and SRFI-9 records transparently.
Currently it is required that SRFI-9 record predicates are named exactly like the record type
name, followed by a @code{?} (question mark) character.


@subsection Code Generation

Pattern matching macros are compiled into @code{if}-expressions
that decompose the value being matched with standard
Scheme procedures, and test the components with standard predicates.
Rebinding or lexically shadowing the names of any of these procedures
will change the
semantics of the @code{match} macros.  The names that should not be
rebound or shadowed are:

@lisp
null? pair? number? string? symbol? boolean? char? procedure? vector? list?
equal?
car cdr cadr cdddr ...
vector-length vector-ref
reverse length call/cc
@end lisp

Additionally, the code generated to match a structure pattern like
@code{($ Foo pat-1 ... pat-n)}
refers to the name @code{Foo?}.
This name also should not be shadowed.


@node Declarations
@section Declarations



@deffn {syntax} declare
@lisp
(declare DECLSPEC ...)
@end lisp
Process declaration specifiers. Declarations always override
any command-line settings.  Declarations are valid for the whole
compilation-unit (source file), the position of the declaration in
the source file can be arbitrary. Declarations are ignored in the interpreter
but not in code evaluated at compile-time (by @code{eval-when} or in
syntax extensions loaded via @code{require-extension} or @code{require-for-syntax}.
@code{DECLSPEC} may be any of the following:


@deffn {declaration specifier} always-bound
@lisp
(always-bound SYMBOL ...)
@end lisp
Declares that the given variables are always bound and
accesses to those have not to be checked.
@end deffn

@deffn {declaration specifier} block
@lisp
(block)
@end lisp
Assume global variables are never redefined. This is the same as
specifying the @code{-block} option.
@end deffn

@deffn {declaration specifier} block-global
@deffnx {declaration specifier} hide
@lisp
(block-global SYMBOL ...)
(hide SYMBOL ...)
@end lisp
Declares that the toplevel bindings for @code{SYMBOL ...}
should not be accessible from code in other compilation units or by
@code{eval}. Access to toplevel bindings declared as block global is
also more efficient.
@end deffn

@deffn {declaration specifier} bound-to-procedure
@lisp
(bound-to-procedure SYMBOL ...)
@end lisp
Declares that the given identifiers are always bound to procedure values.
@end deffn

@deffn {declaration specifier} c-options
@lisp
(c-options STRING ...)
@end lisp
Declares additional C/C++ compiler options that are to be passed to the subsequent compilation pass
that translates C to machine code. This declaration will only work if the source file is compiled
with the @code{csc} compiler driver.
@end deffn

@deffn {declaration specifier} check-c-syntax
@lisp
(check-c-syntax)
(not check-c-syntax)
@end lisp
Enables or disables syntax-checking of embedded C/C++ code fragments. Checking C syntax is the default.
@end deffn

@deffn {declaration specifier} compress-literals
@lisp
(compress-literals [THRESHOLD [INITIALIZER]])
@end lisp
The same as the @code{-compress-literals} compiler option.
The threshold argument defaults to 50. If the optional argument @code{INITIALIZER}
is given, then the literals will not be created at module startup,
but when the procedure with this name will be called.
@end deffn

@deffn {declaration specifier} constant
@lisp
(constant SYMBOL ...)
@end lisp
Declares the procedures with the names @code{SYMMBOL ...} as constant, that is, as not having any
side effects. This can help the compiler to remove non-side-effecting expressions.
@end deffn

@deffn {declaration specifier} export
@lisp
(export SYMBOL ...)
@end lisp
The opposite of @code{hide}. All given identifiers will be exported and all toplevel variables
not listed will be hidden and not be accessible outside of this compilation unit.
@end deffn

@deffn {declaration-specifier} emit-exports
@lisp
(emit-exports STRING)
@end lisp
Write exported toplevel variables to file with name @code{STRING}.
@end deffn

@deffn {declaration specifier} emit-external-prototypes-first
@lisp
(emit-external-prototypes-first)
@end lisp
Emit prototypes for callbacks defined with @code{define-external} before any
other foreign declarations. Equivalent to giving the @code{-emit-external-prototypes-first}
option to the compiler.
@end deffn

@deffn {declaration specifier} disable-interrupts
@lisp
(disable-interrupts)
(not interrupts-enabled)
@end lisp
Disable timer-interrupts checks in the compiled program. Threads can
not be preempted in main- or library-units that contain this declaration.
@end deffn

@deffn {declaration specifier} disable-warning
@lisp
(disable-warning CLASS ...)
@end lisp
Disable warnings of type @code{CLASS ...} (equivalent to the @code{-disable-warning CLASS}
compiler option).
@end deffn

@deffn {declaration specifier} import
@lisp
(import SYMBOL-OR-STRING ...)
@end lisp
Adds new imports to the list of externally available toplevel variables. Arguments to this declaration
may be either strings (designating @code{.exports} files, without the file-extension) or symbols
which directly designate imported variables.
@end deffn

@deffn {declaration specifier} inline
@lisp
(inline)
(not inline)
(inline IDENTIFIER ...)
(not inline IDENTIFIER ...)
@end lisp
If given without an identifier-list, inlining of known procedures is enabled (this is equivalent to the @code{-inline}
compiler option). When an identifier-list is given, then inlining is enabled only for the specified global procedures.
The negated forms @code{(not inline)} and @code{(not inline IDENTIFIER)} disable global inlining, or inlining for
the given global procedures only, respectively.
@end deffn

@deffn {declaration specifier} inline-limit
@lisp
(inline-limit THRESHOLD)
@end lisp
Sets the maximum size of procedures which may potentially be inlined. The default threshold is @code{10}.
@end deffn

@deffn {declaration specifier} interrupts-enabled
@lisp
(interrupts-enabled)
@end lisp
Enable timer-interrupts checks in the compiled program (the default).
@end deffn

@deffn {declaration specifier} keep-shadowed-macros
@lisp
(keep-shadowed-macros)
@end lisp
Normally, when a toplevel variable is assigned or defined that has the same name as a macro, the macro-definition
will be removed (in addition to showing a warning). This declaration will disable the removal of the macro.
@end deffn

@deffn {declaration specifier} lambda-lift
@lisp
(lambda-lift)
@end lisp
Enables lambda-lifting (equivalent to the @code{-lambda-lift} option).
@end deffn

@deffn {declaration specifier} link-options
@lisp
(link-options STRING ...)
@end lisp
Declares additional linker compiler options that are to be passed to the subsequent compilation pass
that links the generated code into an executable or library. 
This declaration will only work if the source file is compiled
with the @code{csc} compiler driver.
@end deffn

@deffn {declaration specifier} no-argc-checks
@lisp
(no-argc-checks)
@end lisp
Disables argument count checking.
@end deffn

@deffn {declaration specifier} no-bound-checks
@lisp
(no-bound-checks)
@end lisp
Disables the bound-checking of toplevel bindings.
@end deffn

@deffn {declaration specifier} no-procedure-checks
@lisp
(no-procedure-checks)
@end lisp
Disables checking of values in operator position for being of procedure type.
@end deffn

@deffn {declaration specifier} post-process
@lisp
(post-process STRING ...)
@end lisp
Arranges for the shell commands @code{STRING ...} to be invoked after the current
file has been translated to C. Any occurrences of the substring @code{$@@} in the
strings given for this declaration will be replaced by the pathname of the currently
compiled file, without the file-extension.
This declaration will only work if the source file is compiled
with the @code{csc} compiler driver.
@end deffn

@deffn {declaration specifier} TYPE
@deffnx {declaration specifier} fixnum-arithmetic
@lisp
([number-type] TYPE)
(fixnum-arithmetic)
@end lisp
Declares that only numbers of the given type are used. @code{TYPE}
may be @code{fixnum} or @code{generic} (which is
the default).
@end deffn

@deffn {declaration specifier} run-time-macros
@lisp
(run-time-macros)
@end lisp
Equivalent to the compiler option of the same name - macros defined in the compiled code are also made available at
runtime.
@end deffn

@deffn {declaration specifier} standard-bindings
@lisp
(standard-bindings SYMBOL ...)
(not standard-bindings SYMBOL ...)
@end lisp
Declares that all given standard procedures (or all if no symbols are
specified) are never globally redefined.  If @code{not} is specified,
then all but the given standard bindings are assumed to be never
redefined.
@end deffn

@deffn {declaration specifier} extended-bindings
@lisp
(extended-bindings SYMBOL ...)
(not extended-bindings SYMBOL ...)
@end lisp
Declares that all given non-standard and CHICKEN-specific procedures
(or all if no symbols are specified) are never globally redefined.
If @code{not} is specified, then all but the given extended bindings
are assumed to be never redefined.
@end deffn

@deffn {declaration specifier} usual-integrations
@lisp
(usual-integrations SYMBOL ...)
(not usual-integrations SYMBOL ...)
@end lisp
Declares that all given standard and extended bindings (or all if no
symbols are specified) are never globally redefined.  If @code{not}
is specified, then all but the given standard and extended bindings are
assumed to be never redefined. Note that this is the default behaviour,
unless the @code{-no-usual-integrations} option has been given.
@end deffn

@deffn {declaration specifier} unit
@lisp
(unit SYMBOL)
@end lisp
Specify compilation unit-name (if this is a library)
@end deffn

@deffn {declaration specifier} unsafe
@lisp
(unsafe)
(not safe)
@end lisp
Do not generate safety-checks. This is the same as specifying the
@code{-unsafe} option.  Also implies

@verbatim
(declare (no-bound-checks) (no-procedure-checks) (no-argc-checks))
@end verbatim
@end deffn

@deffn {declaration specifier} uses
@lisp
(uses SYMBOL ...)
@end lisp
Gives a list of used library-units. Before the toplevel-expressions
of the main-module are executed, all used units evaluate their
toplevel-expressions in the order in which they appear in this
declaration. If a library unit A uses another unit B, then B's toplevel
expressions are evaluated before A's.  Furthermore, the used symbols
are registered as features during compile-time, so @code{cond-expand}
knows about them.
@end deffn


@end deffn



@node Parameters
@section Parameters 


Certain behavior of the interpreter and compiled programs can be
customized via 'parameters', where a parameter is a procedure of
zero or one arguments. To retrieve the value of a parameter call the
parameter-procedure with zero arguments. To change the setting of the
parameter, call the parameter-procedure with the new value as argument:

@verbatim
(define foo (make-parameter 123))
(foo)                             ==> 123
(foo 99)
(foo)                             ==> 99
@end verbatim

Parameters are fully thread-local, each thread of execution
owns a local copy of a parameters' value.

CHICKEN implements @uref{http://srfi.schemers.org/srfi-39/srfi-39.html, SRFI-39}



@deffn {procedure} make-parameter
@lisp
(make-parameter VALUE [GUARD])
@end lisp
Returns a procedure that accepts zero or one argument. Invoking the
procedure with zero arguments returns @code{VALUE}. Invoking the
procedure with one argument changes its value to the value of that
argument (subsequent invocations with zero parameters return the new
value). @code{GUARD} should be a procedure of a single argument. Any
new values of the parameter (even the initial value) are passed to this
procedure. The guard procedure should check the value and/or convert it
to an appropriate form.

@end deffn
@defvr {parameter} case-sensitive
If true, then @code{read} reads symbols and identifiers in
case-sensitive mode and uppercase characters in symbols are printed
escaped. Defaults to @code{#t}.

@end defvr
@defvr {parameter} dynamic-load-libraries
A list of strings containing shared libraries that should be checked
for explicitly loaded library units (this facility is not available on
all platforms). See @code{load-library}.

@end defvr
@defvr {parameter} command-line-arguments
Contains the list of arguments passed to this program, with the name of
the program and any runtime options (all options starting with @code{-:})
removed.

@end defvr

@defvr {parameter} current-read-table
A read-table object that holds read-procedures for special non-standard
read-syntax (see @code{set-read-syntax!} for more information).
@end defvr

@defvr {parameter} exit-handler
A procedure of a single optional argument. When @code{exit} is called,
then this procedure will be invoked with the exit-code as argument. The
default behavior is to terminate the program.

@end defvr
@defvr {parameter} eval-handler
A procedure of one or two arguments. When @code{eval} is invoked, it
calls the value of this parameter with the same arguments. The default
behavior is to evaluate the argument expression and to ignore the
second parameter.

@end defvr
@defvr {parameter} force-finalizers
If true, force and execute all pending finalizers before exiting the
program (either explicitly by @code{exit} or implicitly when the last
toplevel expression has been executed). Default is @code{#t}.

@end defvr
@defvr {parameter} implicit-exit-handler
A procedure of no arguments. When the last toplevel expression of the
program has executed, then the value of this parameter is called. The
default behaviour is to invoke all pending finalizers.

@end defvr
@defvr {parameter} keyword-style
Enables alternative keyword syntax, where @code{STYLE} may be either
@code{#:prefix} (as in Common Lisp) or @code{#:suffix} (as in DSSSL).
Any other value disables the alternative syntaxes.

@end defvr
@defvr {parameter} load-verbose
A boolean indicating whether loading of source files, compiled code
(if available) and compiled libraries should display a message.

@end defvr
@defvr {parameter} repl-prompt
A procedure that should evaluate to a string that will be printed before reading 
interactive input from the user in a read-eval-print loop. Defaults to 
@code{(lambda () "#;N> ")}.

@end defvr
@defvr {parameter} reset-handler
A procedure of zero arguments that is called via @code{reset}. The
default behavior in compiled code is to invoke the value of
@code{(exit-handler)}. The default behavior in the interpreter is to
abort the current computation and to restart the read-eval-print loop.

@end defvr



@node Unit library
@section Unit library

This unit contains basic Scheme definitions. This unit is used by default, unless the program
is compiled with the @code{-explicit-use} option.

@menu
* Arithmetic::                  
* File Input/Output::           
* Files::                       
* String ports::                
* Feature identifiers::         
* Keywords::                    
* Exceptions::                  
* Environment information and system interface::  
* Execution time::              
* Interrupts and error-handling::  
* Garbage collection::          
* Other control structures::    
* String utilities::
* Generating uninterned symbols::  
* Standard Input/Output::       
* User-defined named characters::  
* Vectors::                     
* The unspecified value::       
* Continuations::                     
* Setters::
@end menu

@node Arithmetic
@subsection Arithmetic


@deffn {procedure} add1
@deffnx {procedure} sub1
@lisp
(add1 N)
(sub1 N)
@end lisp
Adds/subtracts 1 from @code{N}.

@end deffn
@deffn {procedure} bitwise-and
@deffnx {procedure} bitwise-ior
@deffnx {procedure} bitwise-xor
@deffnx {procedure} bitwise-not
@deffnx {procedure} arithmetic-shift
@lisp
(bitwise-and N1 ...)
(bitwise-ior N1 ...)
(bitwise-xor N1 ...)
(bitwise-not N)
(arithmetic-shift N1 N2)
@end lisp
Binary integer operations. @code{arithmetic-shift} shifts the argument
@code{N1} by @code{N2} bits to the left. If @code{N2} is negative,
than @code{N1} is shifted to the right.
These operations only accept exact integers or inexact integers in word range
(32 bit signed on 32-bit platforms, or 64 bit signed on 64-bit platforms).

@end deffn
@deffn {procedure} fixnum?
@lisp
(fixnum? X)
@end lisp
Returns @code{#t} if @code{X} is a fixnum, or @code{#f} otherwise.

@end deffn
@deffn {procedure} fx+
@deffnx {procedure} fx-
@deffnx {procedure} fx*
@deffnx {procedure} fx/
@deffnx {procedure} fxmod
@deffnx {procedure} fxneg
@deffnx {procedure} fxmin
@deffnx {procedure} fxmax
@deffnx {procedure} fx=
@deffnx {procedure} fx>
@deffnx {procedure} fx<
@deffnx {procedure} fx>=
@deffnx {procedure} fx<=
@deffnx {procedure} fxand
@deffnx {procedure} fxior
@deffnx {procedure} fxxor
@deffnx {procedure} fxnot
@deffnx {procedure} fxshl
@deffnx {procedure} fxshr
@lisp
(fx+ N1 N2)
(fx- N1 N2)
(fx* N1 N2)
(fx/ N1 N2)
(fxmod N1 N2)
(fxneg N)
(fxmin N1 N2)
(fxmax N1 N2)
(fx= N1 N2)
(fx> N1 N2)
(fx< N1 N2)
(fx>= N1 N2)
(fx<= N1 N2)
(fxand N1 N2)
(fxior N1 N2)
(fxxor N1 N2)
(fxnot N)
(fxshl N1 N2)
(fxshr N1 N2)
@end lisp
Arithmetic fixnum operations. These procedures do not check their
arguments, so non-fixnum parameters will result in incorrect
results. @code{fxneg} negates its argument.

On division by zero, @code{fx/} and @code{fxmod} signal a condition of
kind @code{(exn arithmetic)}.

@code{fxshl} and @code{fxshr} perform arithmetic shift left and right,
respectively.

@end deffn
@deffn {procedure} fp+
@deffnx {procedure} fp-
@deffnx {procedure} fp*
@deffnx {procedure} fp/
@deffnx {procedure} fpneg
@deffnx {procedure} fpmin
@deffnx {procedure} fpmax
@deffnx {procedure} fp=
@deffnx {procedure} fp>
@deffnx {procedure} fp<
@deffnx {procedure} fp>=
@deffnx {procedure} fp<=
@lisp
(fp+ N1 N2)
(fp- N1 N2)
(fp* N1 N2)
(fp/ N1 N2)
(fpneg N)
(fpmin N1 N2)
(fpmax N1 N2)
(fp= N1 N2)
(fp> N1 N2)
(fp< N1 N2)
(fp>= N1 N2)
(fp<= N1 N2)
@end lisp
Arithmetic floating-point operations. These procedures do not check their
arguments, so non-flonum parameters will result in incorrect
results.
On division by zero, @code{fp/} signals a condition of
kind @code{(exn arithmetic)}.

@end deffn
@deffn {procedure} signum
@lisp
(signum N)
@end lisp
Returns @code{1} if @code{N} is positive, @code{-1} if @code{N} 
is negative or @code{0} if @code{N} is zero. @code{signum} is exactness preserving.
@end deffn




@node File Input/Output
@subsection File Input/Output


@deffn {procedure} current-error-port
@lisp
(current-error-port [PORT])
@end lisp
Returns default error output port. If @code{PORT} is given, then that
port is selected as the new current error output port.
@end deffn

@deffn {procedure} flush-output
@lisp
(flush-output [PORT])
@end lisp
Write buffered output to the given output-port. @code{PORT} defaults
to the value of @code{(current-output-port)}.

@end deffn
@deffn {procedure} port-name
@lisp
(port-name PORT)
@end lisp
Fetch filename from @code{PORT}. This returns the filename that was
used to open this file.  Returns a special tag string, enclosed into
parentheses for non-file ports.

@end deffn
@deffn {procedure} port-position
@lisp
(port-position PORT)
@end lisp
Returns the current position of @code{PORT} as two values: row and
column number.  If the port does not support such an operation an error
is signaled. This procedure is currently only available for input ports.

@end deffn
@deffn {procedure} set-port-name!
@lisp
(set-port-name! PORT STRING)
@end lisp
Sets the name of @code{PORT} to @code{STRING}.
@end deffn




@node Files
@subsection Files




@deffn {procedure} delete-file
@lisp
(delete-file STRING)
@end lisp
Deletes the file with the pathname @code{STRING}. If the file does
not exist, an error is signaled.

@end deffn
@deffn {procedure} file-exists?
@lisp
(file-exists? STRING)
@end lisp
Returns @code{STRING} if a file with the given pathname exists, or
@code{#f} otherwise.

@end deffn
@deffn {procedure} rename-file
@lisp
(rename-file OLD NEW)
@end lisp
Renames the file or directory with the pathname @code{OLD} to
@code{NEW}. If the operation does not succeed, an error is signaled.
@end deffn



@node String ports
@subsection String ports




@deffn {procedure} get-output-string
@lisp
(get-output-string PORT)
@end lisp
Returns accumulated output of a port created with
@code{(open-output-string)}.

@end deffn
@deffn {procedure} open-input-string
@lisp
(open-input-string STRING)
@end lisp
Returns a port for reading from @code{STRING}.

@end deffn
@deffn {procedure} open-output-string
@lisp
(open-output-string)
@end lisp
Returns a port for accumulating output in a string.
@end deffn




@node Feature identifiers
@subsection Feature identifiers


CHICKEN maintains a global list of ``features'' naming functionality available
int the current system. Additionally the @code{cond-expand} form accesses this
feature list to infer what features are provided. Predefined features are
@code{chicken}, and the SRFIs (Scheme Request For Implementation) provided by the
base system: @code{srfi-23, srfi-30, srfi-39}. If the @code{eval} unit
is used (the default), the features @code{srfi-0, srfi-2, srfi-6, srfi-8, srfi-9}
and @code{srfi-10} are defined. When compiling code (during compile-time) the
feature @code{compiling} is registered. When evaluating code in the interpreter
(csi), the feature @code{csi} is registered.


@deffn {procedure} features
@lisp
(features)
@end lisp
Returns a list of all registered features that will be accepted as valid
feature-identifiers by @code{cond-expand}.
@end deffn

@deffn {procedure} feature?
@lisp
(feature? ID ...)
@end lisp
Returns @code{#t} if all features with the given feature-identifiers @code{ID ...}
are registered.

@end deffn
@deffn {procedure} register-feature!
@lisp
(register-feature! FEATURE ...)
@end lisp
Register one or more features that will be accepted as valid
feature-identifiers by @code{cond-expand}. @code{FEATURE ...} may
be a keyword, string or symbol.

@end deffn
@deffn {procedure} unregister-feature!
@lisp
(unregister-feature! FEATURE ...)
@end lisp
Unregisters the specified feature-identifiers. @code{FEATURE ...}
may be a keyword, string or symbol.
@end deffn




@node Keywords
@subsection Keywords

Keywords are special symbols prefixed with @code{#:} that evaluate
to themselves.  Procedures can use keywords to accept optional named
parameters in addition to normal required parameters.  Assignment to
and bindings of keyword symbols is not allowed.
The parameter @code{keyword-style} and the compiler/interpreter option
@code{-keyword-style} can be used to allow an additional keyword
syntax, either compatible to Common LISP, or to DSSSL.



@deffn {procedure} get-keyword
@lisp
(get-keyword KEYWORD ARGLIST [THUNK])
@end lisp
Returns the argument from @code{ARGLIST} specified under the keyword
@code{KEYWORD}.  If the keyword is not found, then the zero-argument
procedure @code{THUNK} is invoked and the result value is returned. If
@code{THUNK} is not given, @code{#f} is returned.

@verbatim
(define (increase x . args)
  (+ x (get-keyword #:amount args (lambda () 1))) )
(increase 123)                                      ==> 124
(increase 123 #:amount 10)                          ==> 133
@end verbatim

Note: the @code{KEYWORD} may actually be any kind of object.

@end deffn
@deffn {procedure} keyword?
@lisp
(keyword? X)
@end lisp
Returns @code{#t} if @code{X} is a keyword symbol, or @code{#f}
otherwise.

@end deffn
@deffn {procedure} keyword->string
@lisp
(keyword->string KEYWORD)
@end lisp
Transforms @code{KEYWORD} into a string.

@end deffn
@deffn {procedure} string->keyword
@lisp
(string->keyword STRING)
@end lisp
Returns a keyword with the name @code{STRING}.
@end deffn




@node Exceptions
@subsection Exceptions


CHICKEN implements the (currently withdrawn) SRFI-12
exception system. For more information, see the @uref{http://srfi.schemers.org/srfi-12/srfi-12.html, SRFI-12
document }



@deffn {syntax} condition-case
@lisp
(condition-case EXPRESSION CLAUSE ...)
@end lisp
Evaluates @code{EXPRESSION} and handles any exceptions that are covered by
@code{CLAUSE ...}, where @code{CLAUSE} should be of the following form:

@verbatim
CLAUSE = ([VARIABLE] (KIND ...) BODY ...)
@end verbatim

If provided, @code{VARIABLE} will be bound to the signalled exception
object. @code{BODY ...} is executed when the exception is a property-
or composite condition with the kinds given @code{KIND ...} (unevaluated).
If no clause applies, the exception is re-signalled in the same dynamic
context as the @code{condition-case} form.

@verbatim
(define (check thunk)
  (condition-case (thunk)
    [(exn file) (print "file error")]
    [(exn) (print "other error")]
    [var () (print "something else")] ) )

(check (lambda () (open-input-file "")))   ; -> "file error"
(check (lambda () some-unbound-variable))  ; -> "othererror"
(check (lambda () (signal 99)))            ; -> "something else"

(condition-case some-unbound-variable
  [(exn file) (print "ignored)] )      ; -> signals error

@end verbatim
@end deffn

@deffn {procedure} breakpoint
@lisp
(breakpoint [NAME])
@end lisp
Programmatically triggers a breakpoint (similar to the @code{,br} top-level csi command).
@end deffn


All error-conditions signalled by the system are of kind @code{exn}.
The following composite conditions are additionally defined:

@table @code

@item (exn arity)

Signalled when a procedure is called with the wrong number of arguments.

@item (exn type)

Signalled on type-mismatch errors, for example when an argument of the wrong
type is passed to a builtin procedure.

@item (exn arithmetic)

Signalled on arithmetic errors, like division by zero.

@item (exn i/o)

Signalled on input/output errors.

@item (exn i/o file)

Signalled on file-related errors.

@item (exn i/o net)

Signalled on network errors.

@item (exn bounds)

Signalled on errors caused by accessing non-existent elements of a collection.

@item (exn runtime)

Signalled on low-level runtime-system error-situations.

@item (exn runtime limit)

Signalled when an internal limit is exceeded (like running out of memory).

@item (exn match)

Signalled on errors raised by failed matches (see the section on @code{match}).

@item (exn syntax)

Signalled on syntax errors.

@item (exn breakpoint)

Signalled when a breakpoint is reached.

@end table

Notes:
@itemize
@item All error-exceptions (of the kind @code{exn}) are non-continuable.

@item Error-exceptions of the @code{exn} kind have additional
@code{arguments} and @code{location} properties that contain the
arguments passed to the exception-handler and the name of the procedure
where the error occurred (if available).

@item When the @code{posix} unit is available and used, then a
user-interrupt (@code{signal/int}) signals an exception of the kind
@code{user-interrupt}. 

@item the procedure @code{condition-property-accessor} accepts an optional
third argument. If the condition does not have a value for the desired property
and if the optional argument is given, no error is signalled and
the accessor returns the third argument.

@item In composite conditionss all properties are currently collected in a single
property-list, so in the case that to conditions have the same named property, only
one will be visible.

@end itemize


@node Environment information and system interface
@subsection Environment information and system interface



@deffn {procedure} argv
@lisp
(argv)
@end lisp
Return a list of all supplied command-line arguments. The first item in
the list is a string containing the name of the executing program. The
other items are the arguments passed to the application. This list is
freshly created on every invocation of @code{(argv)}.  It depends on
the host-shell whether arguments are expanded ('globbed') or not.

@end deffn
@deffn {procedure} exit
@lisp
(exit [CODE])
@end lisp
Exit the running process and return exit-code, which defaults to 0
(Invokes @code{exit-handler}).

@end deffn
@deffn {procedure} build-platform
@lisp
(build-platform)
@end lisp
Returns a symbol specifying the toolset which has been used for
building the executing system, which is one of the following:

@verbatim
cygwin
msvc
mingw32
gnu
metrowerks
intel
watcom
unknown
@end verbatim

@end deffn
@deffn {procedure} chicken-version
@lisp
(chicken-version [FULL])
@end lisp
Returns a string containing the version number of the CHICKEN runtime
system. If the optional argument @code{FULL} is given and true, then
a full version string is returned.

@end deffn
@deffn {procedure} errno
@lisp
(errno)
@end lisp
Returns the error code of the last system call.

@end deffn
@deffn {procedure} getenv
@lisp
(getenv STRING)
@end lisp
Returns the value of the environment variable @code{STRING} or
@code{#f} if that variable is not defined.

@end deffn

@deffn {procedure} machine-byte-order
@lisp
(machine-byte-order)
@end lisp
Returns the symbol @code{little-endian} or @code{big-endian}, depending on the machine's byte-order.
@end deffn

@deffn {procedure} machine-type
@lisp
(machine-type)
@end lisp
Returns a symbol specifying the processor on which this process is
currently running, which is one of the following:

@verbatim
alpha
mips
hppa
ultrasparc
sparc
ppc
ia64
x86
x86-64
unknown
@end verbatim

@end deffn
@deffn {procedure} software-type
@lisp
(software-type)
@end lisp
Returns a symbol specifying the operating system on which this process
is currently running, which is one of the following:

@verbatim
windows
unix
macos
ecos
unknown
@end verbatim

@end deffn
@deffn {procedure} software-version
@lisp
(software-version)
@end lisp
Returns a symbol specifying the operating system version on which this
process is currently running, which is one of the following:

@verbatim
linux
freebsd
netbsd
openbsd
macosx
hpux
solaris
sunos
unknown
@end verbatim

@end deffn

@deffn {procedure} c-runtime
@lisp
(c-runtime)
@end lisp
Returns a symbol that designates what kind of C runtime library has been linked with this version of the Chicken
libraries. Possible return values are @code{static}, @code{dynamic} or @code{unknown}. On systems not compiled
with the Microsoft C compiler, @code{c-runtime} always returns @code{unknown}.
@end deffn

@deffn {procedure} chicken-home
@lisp
(chicken-home)
@end lisp
Returns a string given the installation directory (usually @code{/usr/local/share/chicken} on UNIX-like systems).
If the environment variable @code{CHICKEN_HOME} is set, then its value will be returned. As a last option,
if the environment variable @code{CHICKEN_PREFIX} is set, then @code{chicken-home} will return
@code{$CHICKEN_PREFIX/share}.
@end deffn

@deffn {procedure} system
@lisp
(system STRING)
@end lisp
Execute shell command. The functionality offered by this procedure
depends on the capabilities of the host shell.
@end deffn




@node Execution time
@subsection Execution time



@deffn {procedure} cpu-time
@lisp
(cpu-time)
@end lisp
Returns the used CPU time of the current process in milliseconds as
two values: the time spent in user code, and the time spent in system
code. On platforms where user and system time can not be differentiated,
system time will be always be 0.

@end deffn
@deffn {procedure} current-milliseconds
@lisp
(current-milliseconds)
@end lisp
Returns the number of milliseconds since process- or machine startup.

@end deffn
@deffn {procedure} current-seconds
@lisp
(current-seconds)
@end lisp
Returns the number of seconds since midnight, Jan. 1, 1970.
@end deffn

@deffn {procedure} current-gc-milliseconds
@lisp
(current-gc-milliseconds)
@end lisp
Returns the number of milliseconds spent in major garbage collections since
the last call of @code{current-gc-milliseconds} and returns an exact
integer.
@end deffn


@node Interrupts and error-handling
@subsection Interrupts and error-handling



@deffn {procedure} enable-warnings
@lisp
(enable-warnings [BOOL])
@end lisp
Enables or disables warnings, depending on wether @code{BOOL} is true or false.
If called with no arguments, this procedure returns @code{#t} if warnings are
currently enabled, or @code{#f} otherwise. Note that this is not a parameter.
The current state (wether warnings are enabled or disabled) is global and not
thread-local.

@end deffn
@deffn {procedure} error
@lisp
(error [LOCATION] STRING EXP ...)
@end lisp
Prints error message, writes all extra arguments to the
value of @code{(current-error-port)} and invokes the
current exception-handler.  This conforms to
@uref{http://srfi.schemers.org/srfi-23/srfi-23.html, SRFI-23 }.
If @code{LOCATION} is given and a symbol, it specifies the ``location'' (the name
of the procedure) where the error occurred.

@end deffn

@deffn {procedure} get-call-chain
@lisp
(get-call-chain [START [THREAD]])
@end lisp
Returns a list with the call history. Backtrace information
is only generated in code compiled without @code{-no-trace} and evaluated code.
If the optional argument @code{START} is given, the backtrace starts
at this offset, i.e. when @code{START} is 1, the next to last trace-entry 
is printed, and so on. If the optional argument @code{THREAD} is given, then
the call-chain will only be constructed for calls performed by this thread.

@end deffn

@deffn {procedure} print-call-chain
@lisp
(print-call-chain [PORT [START [THREAD]]])
@end lisp
Prints a backtrace of the procedure call history to @code{PORT},
which defaults to @code{(current-output-port)}.

@end deffn
@deffn {procedure} print-error-message
@lisp
(print-error-message EXN [PORT [STRING]])
@end lisp
Prints an appropriate error message to @code{PORT} (which defaults to the
value of @code{(current-output-port)} for the object @code{EXN}.
@code{EXN} may be a condition, a string or any other object.
If the optional argument @code{STRING} is given, it is printed before the
error-message. @code{STRING} defaults to @code{"Error:"}.

@end deffn

@deffn {procedure} procedure-information
@lisp
(procedure-information PROC)
@end lisp
Returns an s-expression with debug information for the procedure @code{PROC}, or
@code{#f}, if @code{PROC} has no associated debug information.
@end deffn

@deffn {procedure} reset
@lisp
(reset)
@end lisp
Reset program (Invokes @code{reset-handler}).
@end deffn

@deffn {procedure} warning
@lisp
(warning STRING EXP ...)
@end lisp
Displays a warning message (if warnings are enabled with @code{enable-warnings}) and
continues execution.
@end deffn

@deffn {procedure} singlestep
@lisp
(singlestep THUNK)
@end lisp
Executes the code in the zero-procedure @code{THUNK} in single-stepping mode.
@end deffn


@node Garbage collection
@subsection Garbage collection



@deffn {procedure} gc
@lisp
(gc [FLAG])
@end lisp
Invokes a garbage-collection and returns the number of free bytes
in the heap. The flag specifies whether a minor (@code{#f}) or
major (@code{#t}) GC is to be triggered. If no argument is given,
@code{#t} is assumed. When the argument is @code{#t}, all pending
finalizers are executed.
@end deffn

@deffn {procedure} memory-statistics
@lisp
(memory-statistics)
@end lisp
Performs a major garbage collection and returns a three element vector 
containing the total heap size in bytes, the number of bytes currently
used and the size of the nursery (the first heap generation). Note
that the actual heap is actually twice the size given in the heap size,
because CHICKEN uses a copying semi-space collector.
@end deffn

@deffn {procedure} set-finalizer!
@lisp
(set-finalizer! X PROC)
@end lisp
Registers a procedure of one argument @code{PROC}, that will be
called as soon as the non-immediate data object @code{X} is about to
be garbage-collected (with that object as its argument).  Note that
the finalizer will @b{not} be called when interrupts are disabled.
This procedure returns @code{X}.

@end deffn
@deffn {procedure} set-gc-report!
@lisp
(set-gc-report! FLAG)
@end lisp
Print statistics after every GC, depending on @code{FLAG}. A value of
@code{#t} shows statistics after every major GC. A true value different
from @code{#t} shows statistics after every minor GC. @code{#f}
switches statistics off.
@end deffn




@node Other control structures
@subsection Other control structures



@deffn {procedure} andmap
@lisp
(andmap PROC LIST1 ...)
@end lisp
Repeatedly calls @code{PROC} with arguments taken from @code{LIST1 ...}.  
If any invocation should return @code{#f}, the result of
@code{andmap} is @code{#f}. If all invocations return a true result,
then the result of @code{andmap} is @code{#t}.

@end deffn
@deffn {procedure} ormap
@lisp
(ormap PROC LIST1 ...)
@end lisp
Repeatedly calls @code{PROC} with arguments taken from @code{LIST1 ...}.  
If any invocation should return a value different from
@code{#f}, then this value is returned as the  result of
@code{ormap}. If all invocations return @b{#f},
then the result of @code{ormap} is @code{#f}.
@end deffn

@deffn {procedure} promise?
@lisp
(promise? X)
@end lisp
Returns @code{#t} if @code{X} is a promise returned by @code{delay}, or
@code{#f} otherwise.
@end deffn


@node String utilities
@subsection String utilities


@deffn {procedure} reverse-list->string
@lisp
(reverse-list->string LIST)
@end lisp
Returns a string with the characters in @code{LIST} in reverse order. This is equivalent to
@code{(list->string (reverse LIST))}, but much more efficient.
@end deffn


@node Generating uninterned symbols
@subsection Generating uninterned symbols



@deffn {procedure} gensym
@lisp
(gensym [STRING-OR-SYMBOL])
@end lisp
Returns a newly created uninterned symbol. If an argument is provided,
the new symbol is prefixed with that argument.

@end deffn
@deffn {procedure} string->uninterned-symbol
@lisp
(string->uninterned-symbol STRING)
@end lisp
Returns a newly created, unique symbol with the name @code{STRING}.
@end deffn




@node Standard Input/Output
@subsection Standard Input/Output

@deffn {procedure} port?
@lisp
(port? X)
@end lisp
Returns @code{#t} if @code{X} is a port object or @code{#f}
otherwise.

@end deffn
@deffn {procedure} print
@lisp
(print EXP1 EXP2 ...)
@end lisp
Outputs the arguments @code{EXP1 EXP2 ...} using @code{display}
and writes a newline character to the port that is the value of
@code{(current-output-port)}. Returns its first argument.

@end deffn
@deffn {procedure} print*
@lisp
(print* EXP1 ...)
@end lisp
Similar to @code{print}, but does not output a terminating newline
character and performes a @code{flush-outout} after writing its arguments.
@end deffn



@node User-defined named characters
@subsection User-defined named characters



@deffn {procedure} char-name
@lisp
(char-name SYMBOL-OR-CHAR [CHAR])
@end lisp
This procedure can be used to inquire about character names or to
define new ones. With a single argument the behavior is as follows:
If @code{SYMBOL-OR-CHAR} is a symbol, then @code{char-name} returns
the character with this name, or @code{#f} if no character is defined
under this name.  If @code{SYMBOL-OR-CHAR} is a character, then the
name of the character is returned as a symbol, or @code{#f} if the
character has no associated name.

If the optional argument @code{CHAR} is provided, then
@code{SYMBOL-OR-CHAR} should be a symbol that will be the new name of
the given character.  If multiple names designate the same character,
then the @code{write} will use the character name that was defined last.

@verbatim
(char-name 'space)                  ==> #\space
(char-name #\space)                 ==> space
(char-name 'bell)                   ==> #f
(char-name (integer->char 7))       ==> #f
(char-name 'bell (integer->char 7))
(char-name 'bell)                   ==> #\bell
(char->integer (char-name 'bell))   ==> 7
@end verbatim
@end deffn




@node Vectors
@subsection Vectors



@deffn {procedure} vector-copy!
@lisp
(vector-copy! VECTOR1 VECTOR2 [COUNT])
@end lisp
Copies contents of @code{VECTOR1} into @code{VECTOR2}. If the
argument @code{COUNT} is given, it specifies the maximal number of
elements to be copied. If not given, the minimum of the lengths of the
argument vectors is copied.

Exceptions: @code{(exn bounds)}

@end deffn
@deffn {procedure} vector-resize
@lisp
(vector-resize VECTOR N [INIT])
@end lisp
Creates and returns a new vector with the contents of @code{VECTOR} and length @code{N}.
If @code{N} is greater than the original length of @code{VECTOR}, then all additional
items are initialized to @code{INIT}. If @code{INIT} is not specified, the
contents are initialized to some unspecified value.
@end deffn




@node The unspecified value
@subsection The @emph{unspecified} value



@deffn {procedure} void
@lisp
(void)
@end lisp
Returns an unspecified value.
@end deffn




@node Continuations
@subsection Continuations



@deffn {procedure} call/cc
@lisp
(call/cc PROCEDURE)
@end lisp
An alias for @code{call-with-current-continuation}.
@end deffn

@deffn {procedure} continuation-capture
@lisp
(continuation-capture PROCEDURE)
@end lisp
Creates a continuation object representing the current continuation and tail-calls 
@code{PROCEDURE} with this continuation as the single argument.

More information about this continuation API can be found in the paper
@uref{http://repository.readscheme.org/ftp/papers/sw2001/feeley.pdf} ``A Better API for first class
Continuations'' by Marc Feeley.
@end deffn

@deffn {procedure} continuation?
@lisp
(continuation? X)
@end lisp
Returns @code{#t} if @code{X} is a continuation object, or @code{#f} otherwise.
@end deffn

@deffn {procedure} continuation-graft
@lisp
(continuation-graft CONT THUNK)
@end lisp
Calls the procedure @code{THUNK} with no arguments and the implicit continuation
@code{CONT}.
@end deffn

@deffn {procedure} continuation-return
@lisp
(continuation-return CONT VALUE ...)
@end lisp
Returns the value(s) to the continuation @code{CONT}. @code{continuation-result} could
be implemented like this:

@lisp
(define (continuation-return k . vals)
  (continuation-graft
    k
    (lambda () (apply values vals)) ) )
@end lisp
@end deffn


@node Setters
@subsection Setters

SRFI-17 is fully implemented. For more information see: @uref{http://srfi.schemers.org/srfi-17/srfi-17.html, SRFI-17}

@deffn {procedure} setter
@lisp
(setter PROCEDURE)
@end lisp
Returns the setter-procedure of @code{PROCEDURE}, or signals an error if @code{PROCEDURE}
has no associated setter-procedure.

Note that @code{(set! (setter PROC) ...)} for a procedure that has no associated setter procedure
yet is a very slow operation (the old procedure is replaced by a modified copy, which involves a
garbage collection).
@end deffn

@deffn {procedure} getter-with-setter
@lisp
(getter-with-setter GETTER SETTER)
@end lisp
Returns a copy of the procedure @code{GETTER} with the associated setter procedure @code{SETTER}.
Contrary to the SRFI specification, the setter of the returned procedure may be changed.
@end deffn


@node Unit eval
@section Unit eval

This unit has support for evaluation and macro-handling. This unit is used
by default, unless the program is compiled with the @code{-explicit-use}
option.

@menu
* Loading code::                
* Read-eval-print loop::        
* Macros::                      
* Loading extension libraries::         
* Reader extensions::           
* Eval::                        
@end menu

@node Loading code
@subsection Loading code



@deffn {procedure} load
@lisp
(load FILE [EVALPROC])
@end lisp
Loads and evaluates expressions from the given source file, which may
be either a string or an input port.  Each expression read is passed to
@code{EVALPROC} (which defaults to @code{eval}).  On platforms that
support it (currently native Windows, Linux ELF and Solaris), @code{load} can be used
to load compiled programs:

@verbatim
% cat x.scm
(define (hello) (print "Hello!"))
% csc -s x.scm
% csi -q
#;1> (load "x.so")
; loading x.so ...
#;2> (hello)
Hello!
#;3>
@end verbatim

The second argument to @code{load} is ignored when loading compiled
code. 
If source code is loaded from a port, then that port is closed after
all expressions have been read.

Compiled code can be re-loaded, but care has to be taken, if code
from the replaced dynamically loaded module is still executing (i.e.
if an active continuation refers to compiled code in the old module).

Support for realoding compiled code dynamically is still experimental.
    
@end deffn
@deffn {procedure} load-relative
@lisp
(load-relative FILE [EVALPROC])
@end lisp
Similar to @code{load}, but loads @code{FILE} relative to the path
of the currently loaded file.
@end deffn

@deffn {procedure} load-noisily
@lisp
(load-noisily FILE #!key EVALUATOR TIME PRINTER)
@end lisp
As @code{load} but the result(s) of each evaluated toplevel-expression
is written to standard output. If @code{EVALUATOR} is given and not @code{#f},
then each expression is evaluated by calling this argument with the read
expression as argument. If @code{TIME} is given and not false, then
the execution time of each expression is shown (as with the @code{time} macro).
If @code{PRINTER} is given and not false, then each expression is
printed before evaluation by applying the expression to the value of this
argument, which should be a one-argument procedure.
@end deffn

@deffn {procedure} load-library
@lisp
(load-library UNIT [LIBRARYFILE])
@end lisp
On platforms that support dynamic loading, @code{load-library} loads
the compiled library unit @code{UNIT} (which should be a symbol). If the
string @code{LIBRARYFILE} is given, then the given shared library will
be loaded and the toplevel code of the contained unit will be executed.
If no @code{LIBRARYFILE} argument is given, then the following libraries
are checked for the required unit:

@itemize
@item a file named ``@code{<UNIT>.so}''

@item the files given in the parameter @code{dynamic-load-libraries}

@end itemize

If the unit is not found, an error is signaled.  When the library unit
can be successfully loaded, a feature-identifier named @code{UNIT}
is registered. If the feature is already registered before loading,
the @code{load-library} does nothing.

@end deffn
@deffn {procedure} set-dynamic-load-mode!
@lisp
(set-dynamic-load-mode! MODELIST)
@end lisp
On systems that support dynamic loading of compiled code via the @code{dlopen(3)}
interface (for example Linux and Solaris), some options can be specified to
fine-tune the behaviour of the dynamic linker. @code{MODE} should be a list of
symbols (or a single symbol) taken from the following set:

@itemize
@item @code{local}
If @code{local} is given, then any C/C++ symbols defined in the dynamically loaded file
are not available for subsequently loaded files and libraries. Use this if you have linked
foreign code into your dynamically loadable file and if you don't want to export them
(for example because you want to load another file that defines the same symbols).
@item @code{global} 
The default is @code{global}, which means all C/C++ symbols are available to code
loaded at a later stage.
@item @code{now}
If @code{now} is specified, all symbols are resolved immediately.
@item @code{lazy}
Unresolved symbols are resolved as code from the file is executed.
This is the default. 
@end itemize

Note that this procedure does not control the way Scheme variables are handled -
this facility is mainly of interest when accessing foreign code.


@end deffn


@node Read-eval-print loop
@subsection Read-eval-print loop



@deffn {procedure} repl
@lisp
(repl)
@end lisp
Start a new read-eval-print loop. Sets the @code{reset-handler} so that
any invocation of @code{reset} restarts the read-eval-print loop. Also
changes the current exception-handler to display a message, write
any arguments to the value of @code{(current-error-port)} and reset.
@end deffn




@node Macros
@subsection Macros




@deffn {procedure} get-line-number
@lisp
(get-line-number EXPR)
@end lisp
If @code{EXPR} is a pair with the car being a symbol, and line-number
information is available for this expression, then this procedure returns
the associated line number. If line-number information is not available,
then @code{#f} is returned.  Note that line-number information for
expressions is only available in the compiler.

@end deffn
@deffn {procedure} macro?
@lisp
(macro? SYMBOL)
@end lisp
Returns @code{#t} if there exists a macro-definition for @code{SYMBOL}.

@end deffn
@deffn {procedure} macroexpand
@lisp
(macroexpand X)
@end lisp
If @code{X} is a macro-form, expand the macro (and repeat expansion
until expression is a non-macro form).  Returns the resulting expression.

@end deffn
@deffn {procedure} macroexpand-1
@lisp
(macroexpand-1 X)
@end lisp
If @code{X} is a macro-form, expand the macro.  Returns the resulting
expression.

@end deffn
@deffn {procedure} undefine-macro!
@lisp
(undefine-macro! SYMBOL)
@end lisp
Remove the current macro-definition of the macro named @code{SYMBOL}.
@end deffn

@deffn {procedure} syntax-error
@lisp
(syntax-error [LOCATION] MESSAGE ARGUMENT ...)
@end lisp
Signals an exception of the kind @code{(exn syntax)}. Otherwise identical to 
@code{error}.
@end deffn


@node Loading extension libraries
@subsection Loading extension libraries


This functionality is only available on platforms that support dynamic
loading of compiled code. Currently Linux, BSD, Solaris, Windows (with Cygwin) and HP/UX are supported.


@deffn {parameter} repository-path
Contains a string naming the path to the extension repository, which defaults to
either the value of the environment variable @code{CHICKEN_REPOSITORY}, the value
of the environment variable @code{CHICKEN_HOME} or the default library path
(usually @code{/usr/local/lib/chicken} on UNIX systems).
@end deffn

@deffn {procedure} extension-information
@lisp
(extension-information ID)
@end lisp
If an extension with the name @code{ID} is installed and if it has a setup-information
list registered in the extension repository, then the info-list is returned. Otherwise
@code{extension-information} returns @code{#f}.
@end deffn

@deffn {procedure} provide
@lisp
(provide ID ...)
@end lisp
Registers the extension IDs @code{ID ...} as loaded. This is mainly
intended to provide aliases for certain extension identifiers.

@end deffn
@deffn {procedure} provided?
@lisp
(provided? ID ...)
@end lisp
Returns @code{#t} if the extension with the IDs @code{ID @dots{}}
are currently loaded, or @code{#f} otherwise.
Works also for feature-ids.

@end deffn
@deffn {procedure} require
@deffnx {procedure} require-for-syntax
@lisp
(require ID ...)
(require-for-syntax ID ...)
@end lisp
If the extension library @code{ID} is not already loaded into the
system, then @code{require} will lookup the location of the shared
extension library and load it. If @code{ID} names a library-unit of
the base system, then it is loaded via @code{load-library}.  If no
extension library is available for the given ID, then an attempt is
made to load the file @code{ID.so} or @code{ID.scm} (in that order)
from one of the following locations:

@enumerate

@item the current include path, which defaults to the pathnames
given in @code{CHICKEN_INCLUDE_PATH} and @code{CHICKEN_HOME}.

@item the current directory

@end enumerate

@code{ID} should be a string or a symbol. The difference between @code{require} and 
@code{require-for-syntax} is the the latter loads the extension library
at compile-time (the argument is still evaluated), while the former
loads it at run-time.

@end deffn

@deffn {procedure} set-extension-specifier!
@lisp
(set-extension-specifier! SYMBOL PROC)
@end lisp
Registers the handler-procedure @code{PROC} as a extension-specifier with the
name @code{SYMBOL}. This facility allows extending the set of valid extension
specifiers to be used with @code{require-extension}. When @code{register-extension}
is called with an extension specifier of the form @code{(SPEC ...)} and @code{SPEC}
has been registered with @code{set-extension-specifier!}, then @code{PROC} will
be called with two arguments: the specifier and the previously installed handler
(or @code{#f} if no such handler was defined). The handler should return a new
specifier that will be processed recursively. If the handler returns a vector,
then each element of the vector will be processed recursively. 
Alternatively the handler may return a string which specifies a file to be loaded:

@lisp
(eval-when (compile eval)
  (set-extension-specifier! 
    'my-package 
    (lambda (spec old) 
      (make-pathname my-package-directory (->string (cadr spec))) ) ) )

(require-extension (my-package stuff))     ; --> expands into '(load "my-package-dir/stuff")
@end lisp

Note that the handler has to be registered at compile time, if it is to be 
visible in compiled code.
@end deffn


@node Reader extensions
@subsection Reader extensions



@deffn {procedure} define-reader-ctor
@lisp
(define-reader-ctor SYMBOL PROC)
@end lisp
Define new read-time constructor for @code{#,} read syntax. For further information, see
the documentation for @uref{http://srfi.schemers.org/srfi-10/srfi-10.html, SRFI-10 }.
@end deffn

@deffn {procedure} set-read-syntax!
@lisp
(set-read-syntax! CHAR PROC)
@end lisp
When the reader is encounting the non-whitespace character @code{CHAR} while reading
an expression from a given port, then the procedure @code{PROC} will be called with
that port as its argument. The procedure should return a value that will be returned
to the reader:

@lisp
; A simple RGB color syntax:

(set-read-syntax! #\%
  (lambda (port)
    (apply vector
      (map (cut string->number <> 16)
           (string-chop (read-string 6 port) 2) ) ) ) )

(with-input-from-string "(1 2 %f0f0f0 3)" read)
; ==> (1 2 #(240 240 240) 3)
@end lisp

You can undo special handling of read-syntax by passing @code{#f} as the second argument
(if the syntax was previously defined via @code{set-read-syntax!}).

Note that all of CHICKEN's special non-standard read-syntax is handled directly by the reader
to disable built-in read-syntax, define a handler that triggers an error (for example).
@end deffn

@deffn {procedure} set-sharp-read-syntax!
@lisp
(set-sharp-read-syntax! CHAR PROC)
@end lisp
Similar to @code{set-read-syntax!}, but allows defining new @code{#<CHAR> ...} reader syntax.
@end deffn


@deffn {procedure} copy-read-table
@lisp
(copy-read-table READ-TABLE)
@end lisp
Returns a copy of the given read-table. You can access the currently active read-table
with @code{(current-read-table)}.
@end deffn


@node Eval
@subsection Eval



@deffn {procedure} eval
@lisp
(eval EXP [ENVIRONMENT])
@end lisp
Evaluates @code{EXP} and returns the result of the evaluation. The second argument is optional
and defaults to the value of @code{(interaction-environment)}.
@end deffn




@node Unit extras
@section Unit extras


This unit contains a collection of useful utility definitions. 
This unit is used by default, unless the program
is compiled with the @code{-explicit-use} option.


@menu
* Lists::                       
* String-port extensions::      
* Formatted output::            
* Hash tables::                 
* Queues::                      
* Sorting::                     
* Random numbers::              
* Input/Output extensions::     
* Strings::                     
* Combinators::                 
* Binary searching::            
@end menu

@node Lists
@subsection Lists


@deffn {procedure} alist-ref
@lisp
(alist-ref KEY ALIST [TEST [DEFAULT]])
@end lisp
Looks up @code{KEY} in @code{ALIST} using @code{TEST} as the comparison function (or @code{eqv?} if
no test was given) and returns the cdr of the found pair, or @code{DEFAULT} (which defaults to @code{#f}).
@end deffn

@deffn {procedure} alist-update!
@lisp
(alist-update! KEY VALUE ALIST [TEST])
@end lisp
If the list @code{ALIST} contains a pair of the form @code{(KEY . X)}, then this procedure
replaces @code{X} with @code{VALUE} and returns @code{ALIST}. If @code{ALIST} contains no such item, then
@code{alist-update!} returns @code{((KEY . VALUE) . ALIST)}. The optional argument
@code{TEST} specifies the comparison procedure to search a matching pair in @code{ALIST}
and defaults to @code{eqv?}.
@end deffn

@deffn {procedure} atom?
@lisp
(atom? X)
@end lisp
Returns @code{#t} if @code{X} is a not list (@code{X} is not a pair nor the empty list).
@end deffn

@deffn {procedure} rassoc
@lisp
(rassoc KEY LIST [TEST])
@end lisp
Similar to @code{assoc}, but compares @code{KEY} with the @code{cdr} of each pair in @code{LIST} using
@code{TEST} as the comparison procedures (which defaults to @code{eqv?}.

@end deffn
@deffn {procedure} butlast
@lisp
(butlast LIST)
@end lisp
Returns a fresh list with all elements but the last of @code{LIST}.

@end deffn
@deffn {procedure} chop
@lisp
(chop LIST N)
@end lisp
Returns a new list of sublists, where each sublist contains @code{N}
elements of @code{LIST}. If @code{LIST} has a length that is not
a multiple of @code{N}, then the last sublist contains the remaining
elements.

@verbatim
(chop '(1 2 3 4 5 6) 2) ==> ((1 2) (3 4) (5 6))
(chop '(a b c d) 3)     ==> ((a b c) (d))
@end verbatim

@end deffn

@deffn {procedure} compress
@lisp
(compress BLIST LIST)
@end lisp
Returns a new list with elements taken from @code{LIST} with
corresponding true values in the list @code{BLIST}.

@verbatim
(define nums '(99 100 110 401 1234))
(compress (map odd? nums) nums)      ==> (99 401)
@end verbatim

@end deffn
@deffn {procedure} flatten
@lisp
(flatten LIST1 ...)
@end lisp
Returns @code{LIST1 @dots{}} concatenated together, with nested lists
removed (flattened).

@end deffn
@deffn {procedure} intersperse
@lisp
(intersperse LIST X)
@end lisp
Returns a new list with @code{X} placed between each element.

@end deffn
@deffn {procedure} join
@lisp
(join LISTOFLISTS [LIST])
@end lisp
Concatenates the lists in @code{LISTOFLISTS} with @code{LIST} placed
between each sublist. @code{LIST} defaults to the empty list.

@verbatim
(join '((a b) (c d) (e)) '(x y)) ==> (a b x y c d x y e)
(join '((p q) () (r (s) t)) '(-))  ==> (p q - - r (s) t)
@end verbatim

@code{join} could be implemented as follows:

@verbatim
(define (join lstoflsts #!optional (lst '()))
  (apply append (intersperse lstoflists lst)) )
@end verbatim

@end deffn
@deffn {procedure} shuffle
@lisp
(shuffle LIST)
@end lisp
Returns @code{LIST} with its elements sorted in a random order.

@end deffn
@deffn {procedure} tail?
@lisp
(tail? X LIST)
@end lisp
Returns true if @code{X} is one of the tails (cdr's) of @code{LIST}.
@end deffn




@node String-port extensions
@subsection String-port extensions




@deffn {procedure} call-with-input-string
@lisp
(call-with-input-string STRING PROC)
@end lisp
Calls the procedure @code{PROC} with a single argument that is a
string-input-port with the contents of @code{STRING}.

@end deffn
@deffn {procedure} call-with-output-string
@lisp
(call-with-output-string PROC)
@end lisp
Calls the procedure @code{PROC} with a single argument that is a
string-output-port.  Returns the accumulated output-string.

@end deffn
@deffn {procedure} with-input-from-string
@lisp
(with-input-from-string STRING THUNK)
@end lisp
Call procedure @code{THUNK} with the current input-port temporarily
bound to an input-string-port with the contents of @code{STRING}.

@end deffn
@deffn {procedure} with-output-to-string
@lisp
(with-output-to-string THUNK)
@end lisp
Call procedure @code{THUNK} with the current output-port temporarily
bound to a string-output-port and return the accumulated output string.
@end deffn




@node Formatted output
@subsection Formatted output




@deffn {procedure} fprintf
@deffnx {procedure} printf
@deffnx {procedure} sprintf
@deffnx {procedure} format
@lisp
(fprintf PORT FORMATSTRING ARG ...)
(printf FORMATSTRING ARG)
(sprintf FORMATSTRING ARG ...)
(format FORMATSTRING ARG ...)
@end lisp
Simple formatted output to a given port (@code{fprintf}), the
value of @code{(current-output-port) } (@code{printf}) or a string
(@code{sprintf}/@code{format}).  The @code{FORMATSTRING} can contain any sequence
of characters. The character `~' prefixes special formatting directives:

@table @code
@item ~%
write newline character
@item ~N
the same as @code{~%}
@item ~S
write the next argument
@item ~A
display the next argument
@item ~\n
skip all whitespace in the format-string until the next non-whitespace character
@item ~B
write the next argument as a binary number
@item ~O
write the next argument as an octal number
@item ~X
write the next argument as a hexadecimal number
@item ~C
write the next argument as a character
@item ~~
display `~'
@item ~!
flush all pending output
@item ~?
invoke formatted output routine recursively with the next two arguments as format-string and list of parameters
@end table
 
@end deffn




@node Hash tables
@subsection Hash tables

CHICKEN implements SRFI-69. For more information, 
see @uref{http://srfi.schemers.org/srfi-69/srfi-69.html, SRFI-69 }.

A setter for @code{hash-table-ref} is defined, so

@verbatim
(set! (hash-table-ref HT KEY) VAL)
@end verbatim

is equivalent to

@verbatim
(hash-table-set! HT KEY VAL)
@end verbatim


@node Queues
@subsection Queues




@deffn {procedure} list->queue
@lisp
(list->queue LIST)
@end lisp
Returns @code{LIST} converted into a queue, where the first element
of the list is the same as the first element of the queue. The resulting
queue may share memory with the list and the list should not be modified
after this operation.

@end deffn
@deffn {procedure} make-queue
@lisp
(make-queue)
@end lisp
Returns a newly created queue.

@end deffn
@deffn {procedure} queue?
@lisp
(queue? X)
@end lisp
Returns @code{#t} if @code{X} is a queue, or @code{#f} otherwise.

@end deffn
@deffn {procedure} queue->list
@lisp
(queue->list QUEUE)
@end lisp
Returns @code{QUEUE} converted into a list, where the first element
of the list is the same as the first element of the queue. The resulting
list may share memory with the queue object and should not be modified.

@end deffn
@deffn {procedure} queue-add!
@lisp
(queue-add! QUEUE X)
@end lisp
Adds @code{X} to the rear of @code{QUEUE}.

@end deffn
@deffn {procedure} queue-empty?
@lisp
(queue-empty? QUEUE)
@end lisp
Returns @code{#t} if @code{QUEUE} is empty, or @code{#f} otherwise.

@end deffn
@deffn {procedure} queue-first
@lisp
(queue-first QUEUE)
@end lisp
Returns the first element of @code{QUEUE}. If @code{QUEUE} is empty
an error is signaled

@end deffn
@deffn {procedure} queue-last
@lisp
(queue-last QUEUE)
@end lisp
Returns the last element of @code{QUEUE}. If @code{QUEUE} is empty
an error is signaled

@end deffn
@deffn {procedure} queue-remove!
@lisp
(queue-remove! QUEUE)
@end lisp
Removes and returns the first element of @code{QUEUE}. If @code{QUEUE}
is empty an error is signaled
@end deffn

@deffn {procedure} queue-push-back!
@lisp
(queue-push-back! QUEUE ITEM)
@end lisp
Pushes an item into the first position of a queue, i.e. the next
@code{queue-remove!} will return @code{ITEM}.
@end deffn

@deffn {procedure} queue-push-back-list!
@lisp
(queue-push-back-list! QUEUE LIST)
@end lisp
Pushes the items in item-list back onto the queue,
so that @code{(car LIST)} becomes the next removable item.
@end deffn



@node Sorting
@subsection Sorting




@deffn {procedure} merge
@deffnx {procedure} merge!
@lisp
(merge LIST1 LIST2 LESS?)
(merge! LIST1 LIST2 LESS?)
@end lisp
Joins two lists in sorted order. @code{merge!} is the destructive
version of merge. @code{LESS?  } should be a procedure of two arguments,
that returns true if the first argument is to be ordered before the
second argument.

@end deffn
@deffn {procedure} sort
@deffnx {procedure} sort!
@lisp
(sort SEQUENCE LESS?)
(sort! SEQUENCE LESS?)
@end lisp
Sort @code{SEQUENCE}, which should be a list or a vector. @code{sort!}
is the destructive version of sort.

@end deffn
@deffn {procedure} sorted?
@lisp
(sorted? SEQUENCE LESS?)
@end lisp
Returns true if the list or vector @code{SEQUENCE} is already sorted.
@end deffn




@node Random numbers
@subsection Random numbers




@deffn {procedure} random
@lisp
(random N)
@end lisp
Returns an exact random integer from 0 to @code{N}-1.

@end deffn
@deffn {procedure} randomize
@lisp
(randomize [X])
@end lisp
Set random-number seed. If @code{X} is not supplied, the current time is used.
On startup (when the @code{extras} unit is initialized), the random number generator
is initialized with the current time.
@end deffn




@node Input/Output extensions
@subsection Input/Output extensions




@deffn {procedure} make-input-port
@lisp
(make-input-port READ READY? CLOSE [PEEK])
@end lisp
Returns a custom input port. Common operations on this
port are handled by the given parameters, which should be
procedures of no arguments. @code{READ} is called when the
next character is to be read and should return a character or
@code{#!eof}. @code{READY?} is called
when @code{char-ready?} is called on this port and should return
@code{#t} or @code{#f}.  @code{CLOSE} is called when the port is
closed. @code{PEEK} is called when @code{peek-char} is called on this
port and should return a character or @code{#!eof}.
if the argument @code{PEEK} is not given, then @code{READ} is used
instead and the created port object handles peeking automatically (by
calling @code{READ} and buffering the character).

@end deffn
@deffn {procedure} make-output-port
@lisp
(make-output-port WRITE CLOSE [FLUSH])
@end lisp
Returns a custom output port. Common operations on this port are handled
by the given parameters, which should be procedures.  @code{WRITE} is
called when output is sent to the port and receives a single argument,
a string.  @code{CLOSE} is called when the port is closed and should
be a procedure of no arguments. @code{FLUSH} (if provided) is called
for flushing the output port.

@end deffn
@deffn {procedure} pretty-print
@deffnx {procedure} pp
@lisp
(pretty-print EXP [PORT])
(pp EXP [PORT])
@end lisp
Print expression nicely formatted. @code{PORT} defaults to the value
of @code{(current-output-port)}.

@end deffn
@defvr {parameter} pretty-print-width
Specifies the maximal line-width for pretty printing, after which line
wrap will occur.

@end defvr
@deffn {procedure} read-file
@lisp
(read-file [FILE-OR-PORT [READER [MAXCOUNT]]])
@end lisp
Returns a list containing all toplevel expressions
read from the file or port @code{FILE-OR-PORT}. If no argument is given,
input is read from the port that is the current value of @code{(current-input-port)}.
After all expressions are read, and if the argument is a port, then the port will
not be closed. The @code{READER} argument specifies the procedure used to read 
expressions from the given file or port and defaults to @code{read}. The reader
procedure will be called with a single argument (an input port).
If @code{MAXCOUNT} is given then only up to @code{MAXCOUNT} expressions will be read in.

@end deffn
@deffn {procedure} read-line
@deffnx {procedure} write-line
@lisp
(read-line [PORT [LIMIT]])
(write-line STRING [PORT])
@end lisp
Line-input and -output. @code{PORT} defaults to the value of
@code{(current-input-port)} and @code{(current-output-port)},
respectively. if the optional argument @code{LIMIT} is given and
not @code{#f}, then @code{read-line} reads at most @code{LIMIT}
characters per line.

@end deffn
@deffn {procedure} read-lines
@lisp
(read-lines [PORT [MAX]])
@end lisp
Read @code{MAX} or fewer lines from @code{PORT}. @code{PORT}
defaults to the value of @code{(current-input-port)}. @code{PORT} may optionally be
a string naming a file.

@end deffn
@deffn {procedure} read-string
@deffnx {procedure} write-string
@lisp
(read-string [NUM [PORT]])
(write-string STRING [NUM [PORT]]
@end lisp
Read or write @code{NUM} characters from/to @code{PORT}, which defaults to the
value of @code{(current-input-port)} or @code{(current-output-port)}, respectively. 
If @code{NUM} is @code{#f} or not given, then all data
up to the end-of-file is read, or, in the case of @code{write-string} the whole
string is written. If no more input is available, @code{read-string} returns the
empty string.
@end deffn

@deffn {procedure} read-token
@lisp
(read-token PREDICATE [PORT])
@end lisp
Reads characters from @code{PORT} (which defaults to the value of @code{(current-input-port)})
and calls the procedure @code{PREDICATE} with each character until @code{PREDICATE} returns
false. Returns a string with the accumulated characters.
@end deffn

@deffn {procedure} with-error-output-to-port
@lisp
(with-error-output-to-port PORT THUNK)
@end lisp
Call procedure @code{THUNK} with the current error output-port
temporarily bound to @code{PORT}.

@end deffn
@deffn {procedure} with-input-from-port
@lisp
(with-input-from-port PORT THUNK)
@end lisp
Call procedure @code{THUNK} with the current input-port temporarily
bound to @code{PORT}.

@end deffn
@deffn {procedure} with-output-to-port
@lisp
(with-output-to-port PORT THUNK)
@end lisp
Call procedure @code{THUNK} with the current output-port temporarily
bound to @code{PORT}.
@end deffn



@node Strings
@subsection Strings


@deffn {procedure} conc
@lisp
(conc X ...)
@end lisp
Returns a string with the string-represenation of all arguments concatenated
together. @code{conc} could be implemented as

@verbatim
(define (conc . args)
  (apply string-append (map ->string args)) )
@end verbatim
@end deffn


@deffn {procedure} ->string
@lisp
(->string X)
@end lisp
Returns a string-representation of @code{X}.

@end deffn
@deffn {procedure} string-chop
@lisp
(string-chop STRING LENGTH)
@end lisp
Returns a list of substrings taken by ``chopping'' @code{STRING} every @code{LENGTH}
characters:

@verbatim
(string-chop "one two three" 4)  ==>  ("one " "two " "thre" "e")
@end verbatim

@end deffn

@deffn {procedure} string-chomp
@lisp
(string-chomp STRING [SUFFIX])
@end lisp
If @code{STRING} ends with @code{SUFFIX}, then this procedure returns a copy of its first argument with the suffix
removed, otherwise returns @code{STRING} unchanged. @code{SUFFIX} defaults to @code{"\n"}.
@end deffn

@deffn {procedure} string-compare3
@lisp
(string-compare3 STRING1 STRING2)
@end lisp
@end deffn
@deffn {procedure} string-compare3-ci
@lisp
(string-compare3-ci STRING1 STRING2)
@end lisp
Perform a three-way comparison between the @code{STRING1} and @code{STRING2},
returning either @code{-1} if @code{STRING1} is lexicographically less
than @code{STRING2}, @code{0} if it is equal, or @code{1} if it s greater.
@code{string-compare3-ci} performs a case-insensitive comparison.
@end deffn

@deffn {procedure} string-intersperse
@lisp
(string-intersperse LIST [STRING])
@end lisp
Returns a string that contains all strings in @code{LIST} concatenated
together.  @code{STRING} is placed between each concatenated string and
defaults to @code{" "}.

@verbatim
(string-intersperse '("one" "two") "three")
@end verbatim

is equivalent to

@verbatim
(apply string-append (intersperse '("one" "two") "three"))
@end verbatim

@end deffn
@deffn {procedure} string-split
@lisp
(string-split STRING [DELIMITER-STRING [KEEPEMPTY]])
@end lisp
Split string into substrings separated by the given delimiters. If
no delimiters are specified, a string comprising the tab, newline and space characters 
is assumed. If the
parameter @code{KEEPEMPTY} is given and not @code{#f}, then empty
substrings are retained:

@verbatim
(string-split "one  two  three") ==> ("one" "two" "three")
(string-split "foo:bar::baz:" ":" #t) ==> ("foo" "bar" "" "baz" "")
@end verbatim

@end deffn
@deffn {procedure} string-translate
@lisp
(string-translate STRING FROM [TO])
@end lisp
Returns a fresh copy of @code{STRING} with characters matching
@code{FROM} translated to @code{TO}.  If @code{TO} is omitted, then
matching characters are removed. @code{FROM} and @code{TO} may be
a character, a string or a list. If both @code{FROM} and @code{TO}
are strings, then the character at the same position in @code{TO}
as the matching character in @code{FROM} is substituted.

@end deffn
@deffn {procedure} string-translate*
@lisp
(string-translate* STRING SMAP)
@end lisp
Substitutes elements of @code{STRING} according to @code{SMAP}.
@code{SMAP} should be an association-list where each element of the list
is a pair of the form @code{(MATCH \. REPLACEMENT)}. Every occurrence of
the string @code{MATCH} in @code{STRING} will be replaced by the string
@code{REPLACEMENT}:

@verbatim
(string-translate*
  "<h1>this is a \"string\"</h1>"
  '(("<" . "&lt:") (">" . "&gt;") ("\"" . "&quot;")) )

==>  "&lt;h1&gt;this is a &quot;string&quot;&lt;/ht&gt;"
@end verbatim

@end deffn
@deffn {procedure} substring=?
@deffnx {procedure} substring-ci=?
@lisp
(substring=? STRING1 STRING2 [START1 [START2 [LENGTH]]])
(substring-ci=? STRING1 STRING2 [START1 [START2 [LENGTH]]])
@end lisp
Returns @code{#t} if the strings @code{STRING1} and @code{STRING2} are equal, or
@code{#f} otherwise.
The comparison starts at the positions @code{START1} and @code{START2} (which default
to 0), comparing @code{LENGTH} characters (which defaults to the minimum of the remaining
length of both strings).

@end deffn
@deffn {procedure} substring-index
@deffnx {procedure} substring-index-ci
@lisp
(substring-index WHICH WHERE [START])
(substring-index-ci WHICH WHERE [START])
@end lisp
Searches for first index in string @code{WHERE} where string
@code{WHICH} occurs.  If the optional argument @code{START} is given,
then the search starts at that index.  @code{substring-index-ci}
is a case-insensitive version of @code{substring-index}.
@end deffn




@node Combinators
@subsection Combinators


@deffn {procedure} constantly
@lisp
(constantly X ...)
@end lisp
Returns a procedure that always returns the values @code{X ...} regardless of the number and value of its arguments.

@verbatim
(constantly X) <=> (lambda args X)
@end verbatim

@end deffn
@deffn {procedure} complement
@lisp
(complement PROC)
@end lisp
Returns a procedure that returns the boolean inverse of @code{PROC}.
@verbatim
(complement PROC) <=> (lambda (x) (not (PROC x)))
@end verbatim

@end deffn
@deffn {procedure} compose
@lisp
(compose PROC1 PROC2 ...)
@end lisp
Returns a procedure that represents the composition of the
argument-procedures @code{PROC1 PROC2 ...}.

@verbatim
(compose F G) <=> (lambda args
                      (call-with-values
                         (lambda () (apply G args))
                         F))
@end verbatim

@end deffn
@deffn {procedure} conjoin
@lisp
(conjoin PRED ...)
@end lisp
Returns a procedure that returns @code{#t} if its argument satisfies the
predicates @code{PRED ...}.
@verbatim
((conjoin odd? positive?) 33)   ==>  #t
((conjoin odd? positive?) -33)  ==>  #f
@end verbatim

@end deffn
@deffn {procedure} disjoin
@lisp
(disjoin PRED ...)
@end lisp
Returns a procedure that returns @code{#t} if its argument satisfies any
predicate @code{PRED ...}.
@verbatim
((disjoin odd? positive?) 32)    ==>  #t
((disjoin odd? positive?) -32)   ==>  #f
@end verbatim

@end deffn

@deffn {procedure} each
@lisp
(each PROC ...)
@end lisp
Returns a procedure that applies @code{PROC ...} to its arguments, and returns the result(s)
of the last procedure application. For example
@lisp
(each pp eval)
@end lisp
is equivalent to
@lisp
(lambda args 
  (apply pp args)
  (apply eval args) )
@end lisp
@code{(each PROC)} is equivalent to @code{PROC} and @code{(each)} is equivalent to
@code{noop}.
@end deffn

@deffn {procedure} flip
@lisp
(flip PROC)
@end lisp
Returns a two-argument procedure that calls @code{PROC} with its
arguments swapped:
@verbatim
(flip PROC) <=> (lambda (x y) (PROC y x))
@end verbatim

@end deffn
@deffn {procedure} identity
@lisp
(identity X)
@end lisp
Returns its sole argument @code{X}.

@end deffn
@deffn {procedure} project
@lisp
(project N)
@end lisp
Returns a procedure that returns its @code{N}th argument (starting from 0).

@end deffn
@deffn {procedure} list-of
@lisp
(list-of PRED)
@end lisp
Returns a procedure of one argument that returns @code{#t} when
applied to a list of elements that all satisfy the predicate procedure
@code{PRED}, or @code{#f} otherwise.

@verbatim
((list-of even?) '(1 2 3))   ==> #f
((list-of number?) '(1 2 3)) ==> #t
@end verbatim
@end deffn

@deffn {procedure} noop
@lisp
(noop X ...)
@end lisp
Ignores it's arguments, does nothing and returns an unspecified value.
@end deffn


@node Binary searching
@subsection Binary searching



@deffn {procedure} binary-search
@lisp
(binary-search SEQUENCE PROC)
@end lisp
Performs a binary search in @code{SEQUENCE}, which should be a sorted
list or vector.  @code{PROC} is called to compare items in the sequence,
should accept a single argument and return an exact integer: zero if the
searched value is equal to the current item, negative if the searched
value is ``less'' than the current item, and positive otherwise.
@end deffn




@node Unit srfi-1
@section Unit srfi-1

List library, see the documentation for
@uref{http://srfi.schemers.org/srfi-1/srfi-1.html, SRFI-1 }

@node Unit srfi-4
@section Unit srfi-4 

Homogeneous numeric vectors, see the documentation for @uref{http://srfi.schemers.org/srfi-4/srfi-4.html, SRFI-4}.
64-bit integer vectors (@code{u64vector} and @code{s64vector} are not supported.

The basic constructor procedures for number vectors are extended to allow allocating the storage in non garbage
collected memory:

@deffn {procedure} make-XXXvector
@lisp
(make-XXXvector SIZE [INIT NONGC FINALIZE])
@end lisp
Creates a SRFI-4 homogenous number vector of length @code{SIZE}. If @code{INIT} is given, it specifies the initial
value for each slot in the vector. The optional arguments @code{NONGC} and @code{FINALIZE} define whether the
vector should be allocated in a memory area not subject to garbage collection and whether the associated storage
should be automatically freed (using finalization) when there are no references from Scheme variables and data.
@code{NONGC} defaults to @code{#f} (the vector will be located in normal garbage collected memory) and
@code{FINALIZE} defaults to  @code{#t}. Note that the @code{FINALIZE} argument is only used when @code{NONGC}
is true.
@end deffn

Additionally, the following procedures are provided:

@deffn {procedure} u8vector->byte-vector
@deffnx {procedure} s8vector->byte-vector
@deffnx {procedure} u16vector->byte-vector
@deffnx {procedure} s16vector->byte-vector
@deffnx {procedure} u32vector->byte-vector
@deffnx {procedure} s32vector->byte-vector
@deffnx {procedure} f32vector->byte-vector
@deffnx {procedure} f64vector->byte-vector
@lisp
(u8vector->byte-vector U8VECTOR)
(s8vector->byte-vector S8VECTOR)
(u16vector->byte-vector U16VECTOR)
(s16vector->byte-vector S16VECTOR)
(u32vector->byte-vector U32VECTOR)
(s32vector->byte-vector S32VECTOR)
(f32vector->byte-vector F32VECTOR)
(f64vector->byte-vector F64VECTOR)
@end lisp
Each of these procedures return the contents of the given vector as a
'packed' byte-vector. The byte order in that vector is platform-dependent
(for example little-endian on an @b{Intel} processor). The returned
byte-vector shares memory with the contents of the vector.
@end deffn

@deffn {procedure} byte-vector->u8vector
@deffnx {procedure} byte-vector->s8vector
@deffnx {procedure} byte-vector->u16vector
@deffnx {procedure} byte-vector->s16vector
@deffnx {procedure} byte-vector->u32vector
@deffnx {procedure} byte-vector->s32vector
@deffnx {procedure} byte-vector->f32vector
@deffnx {procedure} byte-vector->f64vector
@lisp
(byte-vector->u8vector BYTE-VECTOR)
(byte-vector->s8vector BYTE-VECTOR)
(byte-vector->u16vector BYTE-VECTOR)
(byte-vector->s16vector BYTE-VECTOR)
(byte-vector->u32vector BYTE-VECTOR)
(byte-vector->s32vector BYTE-VECTOR)
(byte-vector->f32vector BYTE-VECTOR)
(byte-vector->f64vector BYTE-VECTOR)
@end lisp
Each of these procedures return a vector where the argument
@code{BYTE-VECTOR} is taken as a 'packed' representation of the contents
of the vector. The argument-byte-vector shares memory with the contents
of the vector.

@end deffn
@deffn {procedure} subu8vector
@deffnx {procedure} subu16vector
@deffnx {procedure} subu32vector
@deffnx {procedure} subs8vector
@deffnx {procedure} subs16vector
@deffnx {procedure} subs32vector
@deffnx {procedure} subf32vector
@deffnx {procedure} subf64vector
@lisp
(subu8vector U8VECTOR FROM TO)
(subu16vector U16VECTOR FROM TO)
(subu32vector U32VECTOR FROM TO)
(subs8vector S8VECTOR FROM TO)
(subs16vector S16VECTOR FROM TO)
(subs32vector S32VECTOR FROM TO)
(subf32vector F32VECTOR FROM TO)
(subf64vector F64VECTOR FROM TO)
@end lisp
Creates a number vector of the same type as the argument vector with the elements at the positions @code{FROM} up to but
not including @code{TO}.

SRFI-17 Setters for @code{XXXvector-ref} are defined.
@end deffn




@node Unit srfi-13
@section Unit srfi-13 


String library, see the documentation for
@uref{http://srfi.schemers.org/srfi-13/srfi-13.html, SRFI-13 }


On systems that support dynamic loading, the @code{srfi-13} unit can
be made available in the interpreter (@code{csi}) by entering

@verbatim
(require-extension srfi-13)
@end verbatim

@node Unit srfi-14
@section Unit srfi-14

Character set library, see the documentation for
@uref{http://srfi.schemers.org/srfi-14/srfi-14.html, SRFI-14 }

On systems that support dynamic loading, the @code{srfi-14} unit can
be made available in the interpreter (@code{csi}) by entering

@verbatim
(require-extension srfi-14)
@end verbatim

@itemize
@item This library provides only the Latin-1 character set.
@end itemize


@node Unit match
@section Unit match

The runtime-support code for the Pattern Matching extensions. Note that to use the macros in
normal compiled code it is not required to declare this unit as used. Only
if forms containing these macros are to be expanded at runtime, this
is needed. 


@node Unit regex
@section Unit regex

This library unit provides support for regular expressions. The flavor depends on
the particular installation platform:

@itemize
@item On UNIX systems that have PCRE (the Perl Compatible Regular Expression package)
installed, PCRE is used.
@item If PCRE is not available, and the C library provides regular expressions, these
are used instead.
@item on Windows (or of PCRE and libc regexes are not available), Dorai Sitaram's
portable @code{pregexp} library is used.
@end itemize



@deffn {procedure} grep
@lisp
(grep REGEX LIST)
@end lisp
Returns all items of @code{LIST} that match the regular expression
@code{REGEX}.  This procedure could be defined as follows:

@verbatim
(define (grep regex lst)
  (filter (lambda (x) (string-search regex x)) lst) )
@end verbatim

@end deffn
@deffn {procedure} glob->regexp
@lisp
(glob->regexp PATTERN)
@end lisp
Converts the file-pattern @code{PATTERN} into a regular expression.

@verbatim
(glob->regexp "foo.*") ==> "foo\..*"
@end verbatim

@end deffn
@deffn {procedure} regexp
@lisp
(regexp STRING [IGNORECASE [IGNORESPACE [UTF8]]])
@end lisp
Returns a precompiled regular expression object for @code{string}.
The optional arguments @code{IGNORECASE}, @code{IGNORESPACE} and @code{UTF8}
specify whether the regular expression should be matched with case- or whitespace-differences
ignored, or whether the string should be treated as containing UTF-8 encoded
characters, respectively.

Notes:

@itemize
@item regex doesn't allow (?: ) cloisters (non-capturing groups)
    Currently this means if you use utf8 matching, individual "."
    matching will return extra submatches.
@item pregexp doesn't allow a # comment w/o a trailing newline.
@end itemize

@end deffn
@deffn {procedure} regexp?
@lisp
(regexp? X)
@end lisp
Returns @code{#t} if @code{X} is a precompiled regular expression,
or @code{#f} otherwise.

@end deffn
@deffn {procedure} string-match
@deffnx {procedure} string-match-positions
@lisp
(string-match REGEXP STRING [START])
(string-match-positions REGEXP STRING [START])
@end lisp
Matches the regular expression in @code{REGEXP} (a string or a precompiled
regular expression) with
@code{STRING} and returns either @code{#f} if the match failed,
or a list of matching groups, where the first element is the complete
match. If the optional argument @code{START} is supplied, it specifies
the starting position in @code{STRING}.  For each matching group the
result-list contains either: @code{#f} for a non-matching but optional
group; a list of start- and end-position of the match in @code{STRING}
(in the case of @code{string-match-positions}); or the matching
substring (in the case of @code{string-match}). Note that the exact string
is matched. For searching a pattern inside a string, see below.
Note also that @code{string-match} is implemented by calling
@code{string-search} with the regular expression wrapped in @code{^ ... $}.

@end deffn
@deffn {procedure} string-search
@deffnx {procedure} string-search-positions
@lisp
(string-search REGEXP STRING [START [RANGE]])
(string-search-positions REGEXP STRING [START [RANGE]])
@end lisp
Searches for the first match of the regular expression in
@code{REGEXP} with @code{STRING}. The search can be limited to
@code{RANGE} characters.

@end deffn
@deffn {procedure} string-split-fields
@lisp
(string-split-fields REGEXP STRING [MODE [START]])
@end lisp
Splits @code{STRING} into a list of fields according to @code{MODE},
where @code{MODE} can be the keyword @code{#:infix} (@code{REGEXP}
matches field separator), the keyword @code{#:suffix} (@code{REGEXP}
matches field terminator) or @code{#t} (@code{REGEXP} matches field),
which is the default.

@lisp
(define s "this is a string 1, 2, 3,")

(string-split-fields "[^ ]+" s)

  => ("this" "is" "a" "string" "1," "2," "3,")

(string-split-fields " " s #:infix)

  => ("this" "is" "a" "string" "1," "2," "3,")

(string-split-fields "," s #:suffix))
 
  => ("this is a string 1" " 2" " 3")
@end lisp

@end deffn
@deffn {procedure} string-substitute
@lisp
(string-substitute REGEXP SUBST STRING [MODE])
@end lisp
Searches substrings in @code{STRING} that match @code{REGEXP}
and substitutes them with the string @code{SUBST}. The substitution
can contain references to subexpressions in 
@code{REGEXP} with the @code{\NUM} notation, where @code{NUM}
refers to the NUMth parenthesized expression. The optional argument
@code{MODE} defaults to 1 and specifies the number of the match to
be substituted. Any non-numeric index specifies that all matches are to
be substituted.

@verbatim
(string-substitute "([0-9]+) (eggs|chicks)"
                   "\\2 (\\1)" "99 eggs or 99 chicks" 2)
 ==> "99 eggs or chicks (99)"
@end verbatim

@end deffn
@deffn {procedure} string-substitute*
@lisp
(string-substitute* STRING SMAP [MODE])
@end lisp
Substitutes elements of @code{STRING} with @code{string-substitute} according to @code{SMAP}.
@code{SMAP} should be an association-list where each element of the list
is a pair of the form @code{(MATCH . REPLACEMENT)}. Every occurrence of
the regular expression @code{MATCH} in @code{STRING} will be replaced by the string
@code{REPLACEMENT}

@verbatim
(string-substitute* "<h1>Hello, world!</h1>"
                    '(("<[/A-Za-z0-9]+>" . ""))))

==>  "Hello, world!"
@end verbatim
@end deffn

@deffn {procedure} regexp-escape
@lisp
(regexp-escape STRING)
@end lisp
Escapes all special characters in @code{STRING} with @code{\}, so that the string can be embedded
into a regular expression.

@verbatim
(regexp-escape "^[0-9]+:.*$")   ==>  "\\^\\[0-9\\]\\+:.\n.\\*\\$"
@end verbatim
@end deffn

Platform-specific notes:

@itemize
@item due to a bug in the @code{pregexp} library, character classes enclosed in @code{[ ... ]}
may not begin with a hyphen (@code{-}). A workaround is either to precede the hyphen with a backslash
or use the range @code{---}.
@end itemize


@node Unit srfi-18
@section Unit srfi-18

A simple multithreading package. This threading package follows largely
the specification of SRFI-18. For more information see the documentation
for @uref{http://srfi.schemers.org/srfi-18/srfi-18.html, SRFI-18 }

@b{Notes:}

@itemize

@item @code{thread-start!} accepts a thunk (a zero argument procedure) as argument, which is
equivalent to @code{(thread-start! (make-thread THUNK))}.

@item When an uncaught exception (i.e. an error) is signalled in a thread other than
the primordial thread and warnings are enabled (see: @code{enable-warnings}, then a warning 
message is written to the port that is the value of @code{(current-error-port)}.

@item Blocking I/O will block all threads, except for some socket operations
(see the section about the @code{tcp} unit). An exception is the read-eval-print loop on
UNIX platforms: waiting for input will not block other threads, provided the current input
port reads input from a console.

@item It is generally not a good idea for one thread to call a
continuation created by another thread, if @code{dynamic-wind}
is involved.

@item When more than one thread compete for the current time-slice,
the thread that was waiting first will become the next runnable thread.

@item The dynamic environment of a thread consists of the following state:

 @itemize

 @item The current input-, output- and error-port

 @item The current exception handler

 @item The values of all current parameters (created by @code{make-parameter})

 @item Any pending @code{dynamic-wind} thunks.

 @end itemize

@end itemize

The following procedures are provided, in addition to the procedures defined in SRFI-18:



@deffn {procedure} thread-signal!
@lisp
(thread-signal! THREAD X)
@end lisp
This will cause @code{THREAD} to signal the condition @code{X} once it is scheduled
for execution. After signalling the condition, the thread continues with its normal
execution.

@end deffn
@deffn {procedure} thread-quantum
@lisp
(thread-quantum THREAD)
@end lisp
Returns the quantum of @code{THREAD}, which is an exact integer
specifying the approximate time-slice of the thread.

@end deffn
@deffn {procedure} thread-quantum-set!
@lisp
(thread-quantum-set! THREAD QUANTUM)
@end lisp
Sets the quantum of @code{THREAD} to @code{QUANTUM}.
@end deffn



@node Unit posix
@section Unit posix

This unit provides services as used on many UNIX-like systems.  Note that
the following definitions are not all available on non-UNIX systems like
Windows. See below for Windows specific notes.

This unit uses the @code{regex}, @code{scheduler}, @code{extras} and @code{utils} units.

All errors related to failing file-operations will signal a condition
of kind @code{(exn i/o file)}.

@menu
* Directories::                 
* Pipes::                       
* Fifos::                       
* File descriptors and low-level I/O::  
* Retrieving file attributes::  
* Changing file attributes::    
* Processes::                   
* Hard and symbolic links::              
* Permissions::                 
* Record locking::              
* Signal handling::             
* Environment access::          
* Memory mapped I/O::           
* Date and time routines::               
* Raw exit::                    
* ERRNO values::                
* Finding files::               
* Getting the hostname and system information::  
* Setting the file buffering mode::  
* Terminal ports::              
* How Scheme procedures relate to UNIX C functions::  
* Windows specific notes::
@end menu

@node Directories
@subsection Directories



@deffn {procedure} change-directory
@lisp
(change-directory NAME)
@end lisp
Changes the current working directory to @code{NAME}.

@end deffn
@deffn {procedure} current-directory
@lisp
(current-directory [DIR])
@end lisp
Returns the name of the current working directory. If the optional argument @code{DIR} is given,
then @code{(current-directory DIR)} is equivalent to @code{(change-directory DIR)}.

@end deffn
@deffn {procedure} create-directory
@lisp
(create-directory NAME)
@end lisp
Creates a directory with the pathname @code{NAME}.

@end deffn
@deffn {procedure} delete-directory
@lisp
(delete-directory NAME)
@end lisp
Deletes the directory with the pathname @code{NAME}. The directory has
to be empty.

@end deffn
@deffn {procedure} directory
@lisp
(directory [PATHNAME [SHOW-DOTFILES?]])
@end lisp
Returns a list with all files that are contained in the directory with the name @code{PATHNAME}
(which defaults to the value of @code{(current-directory)}). If @code{SHOW-DOTFILES?} is given
and not @code{#f}, then files beginning with ``.'' are not included in the directory listing.

@end deffn
@deffn {procedure} directory?
@lisp
(directory? NAME)
@end lisp
Returns @code{#t} if there exists a file with the name @code{NAME}
and if that file is a directory, or @code{#f} otherwise.

@end deffn
@deffn {procedure} glob
@lisp
(glob PATTERN1 ...)
@end lisp
Returns a list of the pathnames of all existing files matching
@code{PATTERN1 ...}, which should be strings containing the usual
file-patterns (with @code{*} matching zero or more characters and
@code{?} matching zero or one character).
@end deffn

@deffn {procedure} set-root-directory!
@lisp
(set-root-directory! STRING)
@end lisp
Sets the root directory for the current process to the path given in @code{STRING}
(using the @code{chroot} function).
If the current process has no root permissions, the operation will fail.
@end deffn


@node Pipes
@subsection Pipes



@deffn {procedure} call-with-input-pipe
@deffnx {procedure} call-with-output-pipe
@lisp
(call-with-input-pipe CMDLINE PROC [MODE])
(call-with-output-pipe CMDLINE PROC [MODE])
@end lisp
Call @code{PROC} with a single argument: a input- or output port
for a pipe connected to the subprocess named in @code{CMDLINE}. If
@code{PROC} returns normally, the pipe is closed and any result values
are returned.

@end deffn
@deffn {procedure} close-input-pipe
@deffnx {procedure} close-output-pipe
@lisp
(close-input-pipe PORT)
(close-output-pipe PORT)
@end lisp
Closes the pipe given in @code{PORT} and waits until the connected
subprocess finishes. The exit-status code of the invoked process
is returned.

@end deffn
@deffn {procedure} create-pipe
@lisp
(create-pipe)
@end lisp
The fundamental pipe-creation operator. Calls the C function
@code{pipe()} and returns 2 values: the file-descriptors of the input-
and output-ends of the pipe.

@end deffn
@deffn {procedure} open-input-pipe
@lisp
(open-input-pipe CMDLINE [MODE])
@end lisp
Spawns a subprocess with the command-line string @code{CMDLINE} and
returns a port, from which the output of the process can be read. If
@code{MODE} is specified, it should be the keyword @code{#:text}
(the default) or @code{#:binary}.

@end deffn
@deffn {procedure} open-output-pipe
@lisp
(open-output-pipe CMDLINE [MODE])
@end lisp
Spawns a subprocess with the command-line string @code{CMDLINE} and
returns a port. Anything written to that port is treated as the input
for the process.  If @code{MODE} is specified, it should be the keyword
@code{#:text} (the default) or @code{#:binary}.

@end deffn
@defvr {limit} pipe/buf
This variable contains the maximal number of bytes that can be written
atomically into a pipe or FIFO.

@end defvr
@deffn {procedure} with-input-from-pipe
@deffnx {procedure} with-output-to-pipe
@lisp
(with-input-from-pipe CMDLINE THUNK [MODE])
(with-output-to-pipe CMDLINE THUNK [MODE])
@end lisp
Temporarily set the value of
@code{current-input-port/current-output-port} to a port for a
pipe connected to the subprocess named in @code{CMDLINE} and call
the procedure @code{THUNK} with no arguments. After @code{THUNK}
returns normally the pipe is closed and the standard input-/output port
is restored to its previous value and any result values are returned.

@verbatim
(with-output-to-pipe 
  "gs -dNOPAUSE -sDEVICE=jpeg -dBATCH -sOutputFile=signballs.jpg -g600x600 -q -"
  (lambda ()
    (print #<<EOF
%!IOPSC-1993 %%Creator: HAYAKAWA Takashi<xxxxxxxx@xx.xxxxxx.xx.xx>
/C/neg/d/mul/R/rlineto/E/exp/H{{cvx def}repeat}def/T/dup/g/gt/r/roll/J/ifelse 8
H/A/copy(z&v4QX&93r9AxYQOZomQalxS2w!!O&vMYa43d6r93rMYvx2dca!D&cjSnjSnjjS3o!v&6A
X&55SAxM1CD7AjYxTTd62rmxCnTdSST0g&12wECST!&!J0g&D1!&xM0!J0g!l&544dC2Ac96ra!m&3A
F&&vGoGSnCT0g&wDmlvGoS8wpn6wpS2wTCpS1Sd7ov7Uk7o4Qkdw!&Mvlx1S7oZES3w!J!J!Q&7185d
Z&lx1CS9d9nE4!k&X&MY7!&1!J!x&jdnjdS3odS!N&mmx1C2wEc!G&150Nx4!n&2o!j&43r!U&0777d
]&2AY2A776ddT4oS3oSnMVC00VV0RRR45E42063rNz&v7UX&UOzF!F!J![&44ETCnVn!a&1CDN!Y&0M
V1c&j2AYdjmMdjjd!o&1r!M){( )T 0 4 3 r put T(/)g{T(9)g{cvn}{cvi}J}{($)g[]J}J
cvx}forall/moveto/p/floor/w/div/S/add 29 H[{[{]setgray fill}for Y}for showpage
EOF
) ) )
@end verbatim
@end deffn




@node Fifos
@subsection Fifos




@deffn {procedure} create-fifo
@lisp
(create-fifo FILENAME [MODE])
@end lisp
Creates a FIFO with the name @code{FILENAME} and the permission bits
@code{MODE}, which defaults to

@verbatim
(+ perm/irwxu perm/irwxg perm/irwxo)
@end verbatim

@end deffn
@deffn {procedure} fifo?
@lisp
(fifo? FILENAME)
@end lisp
Returns @code{#t} if the file with the name @code{FILENAME} names
a FIFO.
@end deffn




@node File descriptors and low-level I/O
@subsection File descriptors and low-level I/O




@deffn {procedure} duplicate-fileno
@lisp
(duplicate-fileno OLD [NEW])
@end lisp
If @code{NEW} is given, then the file-descriptor @code{NEW} is opened
to access the file with the file-descriptor @code{OLD}. Otherwise a
fresh file-descriptor accessing the same file as @code{OLD} is returned.

@end deffn
@deffn {procedure} file-close
@lisp
(file-close FILENO)
@end lisp
Closes the input/output file with the file-descriptor @code{FILENO}.

@end deffn
@deffn {procedure} file-open
@lisp
(file-open FILENAME FLAGS [MODE])
@end lisp
Opens the file specified with the string @code{FILENAME} and open-flags
@code{FLAGS} using the C function @code{open()}. On success a
file-descriptor for the opened file is returned.  @code{FLAGS}
should be a bitmask containing one or more of the @code{open/...}
values @b{or}ed together using @code{bitwise-ior} (or simply added
together).  The optional @code{MODE} should be a bitmask composed of one
or more permission values like @code{perm/irusr} and is only relevant
when a new file is created. The default mode is 
@code{perm/irwxu | perm/irgrp | perm/iroth}.

@end deffn
@deffn {procedure} file-mkstemp
@lisp
(file-mkstemp TEMPLATE-FILENAME)
@end lisp
Create a file based on the given @code{TEMPLATE-FILENAME}, in which
the six last characters must be ``XXXXXX''.  These will be replaced
with a string that makes the filename unique.  The file descriptor of
the created file and the generated filename is returned.  See the
@code{mkstemp(3)} manual page for details on how this function
works.  The template string given is not modified.

Example usage:
@verbatim
(let-values (((fd temp-path) (file-mkstemp "/tmp/mytemporary.XXXXXX")))
  (let ((temp-port (open-output-file* fd)))
    (format temp-port "This file is ~A.~%" temp-path)
    (close-output-port temp-port)))
@end verbatim

@end deffn
@deffn {procedure} file-read
@lisp
(file-read FILENO SIZE [BUFFER])
@end lisp
Reads @code{SIZE} bytes from the file with the file-descriptor
@code{FILENO}.  If a string or bytevector is passed in the optional
argument @code{BUFFER}, then this string will be destructively modified
to contain the read data. This procedure returns a list with two values:
the buffer containing the data and the number of bytes read.

@end deffn
@deffn {procedure} file-select
@lisp
(file-select READFDLIST WRITEFDLIST [TIMEOUT])
@end lisp
Waits until any of the file-descriptors given in the lists
@code{READFDLIST} and @code{WRITEFDLIST} is ready for input or
output, respectively. If the optional argument @code{TIMEOUT} is
given and not false, then it should specify the number of seconds after
which the wait is to be aborted. This procedure returns two values:
the lists of file-descriptors ready for input and output, respectively.
@code{READFDLIST} and @b{WRITEFDLIST} may also by file-descriptors
instead of lists.  In this case the returned values are booleans
indicating whether input/output is ready by @code{#t} or @code{#f}
otherwise.  You can also pass @code{#f} as @code{READFDLIST} or
@code{WRITEFDLIST} argument, which is equivalent to @code{()}.

@end deffn
@deffn {procedure} file-write
@lisp
(file-write FILENO BUFFER [SIZE])
@end lisp
Writes the contents of the string or bytevector @code{BUFFER} into
the file with the file-descriptor @code{FILENO}. If the optional
argument @code{SIZE} is given, then only the specified number of bytes
are written.
@end deffn

@defvr {file descriptor} fileno/stdin
@defvrx {file descriptor} fileno/stdout
@defvrx {file descriptor} fileno/stderr
These variables contain file-descriptors for the standard I/O files.
@end defvr

@defvr {flag} open/rdonly
@defvrx {flag} open/wronly
@defvrx {flag} open/rdwr
@defvrx {flag} open/read 
@defvrx {flag} open/write 
@defvrx {flag} open/creat
@defvrx {flag} open/append 
@defvrx {flag} open/excl
@defvrx {flag} open/noctty 
@defvrx {flag} open/nonblock 
@defvrx {flag} open/trunc
@defvrx {flag} open/sync
@defvrx {flag} open/fsync
@defvrx {flag} open/binary
@defvrx {flag} open/text
Flags for use with @code{file-open}.
@end defvr

@deffn {procedure} open-input-file*
@deffnx {procedure} open-output-file*
@lisp
(open-input-file* FILENO [OPENMODE])
(open-output-file* FILENO [OPENMODE])
@end lisp
Opens file for the file-descriptor @code{FILENO} for input or output
and returns a port.  @code{FILENO} should be a positive exact integer.
@code{OPENMODE} specifies an additional mode for opening the file
(currently only the keyword @code{#:append} is supported, which opens
an output-file for appending).
@end deffn

@deffn {procedure} port->fileno
@lisp
(port->fileno PORT)
@end lisp
If @code{PORT} is a file- or tcp-port, then a file-descriptor is returned for
this port. Otherwise an error is signaled.
@end deffn




@node Retrieving file attributes
@subsection Retrieving file attributes




@deffn {procedure} file-access-time
@deffnx {procedure} file-change-time
@deffnx {procedure} file-modification-time
@lisp
(file-access-time FILE)
(file-change-time FILE)
(file-modification-time FILE)
@end lisp
Returns time (in seconds) of the last acces, modification or change of @code{FILE}. @code{FILE}
may be a filename or a file-descriptor. If the file does not exist,
an error is signaled.
@end deffn

@deffn {procedure} file-stat
@lisp
(file-stat FILE [LINK])
@end lisp
Returns a 9-element vector with the following contents: inode-number, mode (as with @code{file-permissions}),
number of hard links, uid of owner (as with @code{file-owner}), gid of owner, size (as with
@code{file-size}) and access-, change- and modification-time (as with @code{file-access-time},
@code{file-change-time} and @code{file-modification-time}).
If the optional argument @code{LINK} is given and not @code{#f}, then the file-statistics vector will be resolved for
symbolic links (otherwise symbolic links are resolved).

@end deffn
@deffn {procedure} file-position
@lisp
(file-position FILE)
@end lisp
Returns the current file position of @code{FILE}, which should be a
port or a file-descriptor.

@end deffn
@deffn {procedure} file-size
@lisp
(file-size FILENAME)
@end lisp
Returns the size of the file designated by @code{FILE}.  @code{FILE}
may be a filename or a file-descriptor.  If the file does not exist,
an error is signaled.
@end deffn

@deffn {procedure} regular-file?
@lisp
(regular-file? FILENAME)
@end lisp
Returns true, if @code{FILENAME} names a regular file (not a directory or symbolic link).
@end deffn


@node Changing file attributes
@subsection Changing file attributes




@deffn {procedure} file-truncate
@lisp
(file-truncate FILE OFFSET)
@end lisp
Truncates the file @code{FILE} to the length @code{OFFSET},
which should be an integer. If the file-size is smaller or equal to
@code{OFFSET} then nothing is done.  @code{FILE} should be a filename
or a file-descriptor.

@end deffn
@deffn {procedure} set-file-position!
@lisp
(set-file-position! FILE POSITION [WHENCE])
@end lisp
Sets the current read/write position of @code{FILE} to
@code{POSITION}, which should be an exact integer. @code{FILE}
should be a port or a file-descriptor.  @code{WHENCE} specifies
how the position is to interpreted and should be one of the values
@code{seek/set, seek/cur} and @code{seek/end}. It defaults to
@code{seek/set}.

Exceptions: @code{(exn bounds)}, @code{(exn i/o file)}
@end deffn




@node Processes
@subsection Processes




@deffn {procedure} current-process-id
@lisp
(current-process-id)
@end lisp
Returns the process ID of the current process.

@end deffn
@deffn {procedure} parent-process-id
@lisp
(parent-process-id)
@end lisp
Returns the process ID of the parent of the current process.

@end deffn
@deffn {procedure} process-execute
@lisp
(process-execute PATHNAME [ARGUMENT-LIST [ENVIRONMENT-LIST]])
@end lisp
Creates a new child process and replaces the running process with it
using the C library function @code{execvp(3)}. If the optional argument
@code{ARGUMENT-LIST} is given, then it should contain a list of strings which
are passed as arguments to the subprocess. If the optional argument
@code{ENVIRONMENT-LIST} is supplied, then the library function @code{execve(2)}
is used, and the environment passed in @code{ENVIRONMENT-LIST} (which should
be of the form @code{("<NAME>=<VALUE>" ...)} is given
to the invoked process. Note that @code{execvp(3)} respects the current setting
of the @code{PATH} environment variable while @code{execve(3)} does not.

On native Windows, @code{process-execute} ignores the @code{ENVIRONMENT-LIST} arguments.

@end deffn
@deffn {procedure} process-fork
@lisp
(process-fork [THUNK])
@end lisp
Creates a new child process with the UNIX system call
@code{fork()}. Returns either the PID of the child process or 0. If
@code{THUNK} is given, then the child process calls it as a procedure
with no arguments and terminates.

@end deffn
@deffn {procedure} process-run
@lisp
(process-run PATHNAME [LIST])
@end lisp
Creates a new child process using the UNIX system call @code{fork()}
that executes the program given by the string @code{PATHNAME} using
the UNIX system call @code{execv()}.  The PID of the new process is
returned. If @code{LIST} is not specified, then @code{PATHNAME}
is passed to a program named by the environment variable @code{SHELL}
(or @code{/bin/sh}, if the variable is not defined), so usual argument
expansion can take place.

@end deffn
@deffn {procedure} process-signal
@lisp
(process-signal PID [SIGNAL])
@end lisp
Sends @code{SIGNAL} to the process with the id @code{PID} using the
UNIX system call @code{kill()}. @code{SIGNAL} defaults to the value
of the variable @code{signal/term}.

@end deffn
@deffn {procedure} process-wait
@lisp
(process-wait [PID [NOHANG]])
@end lisp
Suspends the current process until the child process with
the id @code{PID} has terminated using the UNIX system call
@code{waitpid()}. If @code{PID} is not given, then this procedure
waits for any child process. If @code{NOHANG} is given and not
@code{#f} then the current process is not suspended.  This procedure
returns three values:
@end deffn

@itemize
@item @code{PID} or 0, if @code{NOHANG} is true and the child process
has not terminated yet;

@item @code{#t} if the process exited normally or @code{#f}
otherwise;

@item either the exit status, if the process terminated normally or the
signal number that terminated/stopped the process.
@end itemize

@deffn {procedure} process
@lisp
(process COMMANDLINE [ARGUMENTLIST [ENVIRONMENT]])
@end lisp
Passes the string @code{COMMANDLINE} to the host-system's shell that
is invoked as a subprocess and returns three values: an input port from
which data written by the sub-process can be read, an output port from
which any data written to will be received as input in the sub-process
and the process-id of the started sub-process. Blocking reads and writes
to or from the ports returned by @code{process} only block the current
thread, not other threads executing concurrently.

If @code{ARGUMENTLIST} is given, then the invocation of the subprocess
is not done via the shell, but directly. The arguments are directly
passed to @code{process-execute} (as is @code{ENVIRONMENT}).
Not using the shell may be preferrable for security reasons.

On native Windows the @code{ARGUMENTLIST} and @code{ENVIRONMENT} arguments are ignored.

@end deffn
@deffn {procedure} sleep
@lisp
(sleep SECONDS)
@end lisp
Puts the process to sleep for @code{SECONDS}. Returns either 0 if
the time has completely elapsed, or the number of remaining seconds,
if a signal occurred.
@end deffn



@node Hard and symbolic links
@subsection Hard and symbolic links



@deffn {procedure} symbolic-link?
@lisp
(symbolic-link? FILENAME)
@end lisp
Returns true, if @code{FILENAME} names a symbolic link.
@end deffn

@deffn {procedure} create-symbolic-link
@lisp
(create-symbolic-link OLDNAME NEWNAME)
@end lisp
Creates a symbolic link with the filename @code{NEWNAME} that points
to the file named @code{OLDNAME}.

@end deffn
@deffn {procedure} read-symbolic-link
@lisp
(read-symbolic-link FILENAME)
@end lisp
Returns the filename to which the symbolic link @code{FILENAME} points.
@end deffn

@deffn {procedure} file-link
@lisp
(file-link OLDNAME NEWNAME)
@end lisp
Creates a hard link from @code{OLDNAME} to @code{NEWNAME} (both strings).
@end deffn



@node Permissions
@subsection Permissions, owners, users and groups




@deffn {procedure} file-owner
@lisp
(file-owner FILE)
@end lisp
Returns the user-id of @code{FILE}.  @code{FILE} may be a filename
or a file-descriptor.

@end deffn
@deffn {procedure} file-permissions
@lisp
(file-permissions FILE)
@end lisp
Returns the permission bits for @code{FILE}. You can test this value
by performing bitwise operations on the result and the @code{perm/@dots{}}
values.  @code{FILE} may be a filename or a file-descriptor.

@end deffn
@deffn {procedure} file-read-access?
@deffnx {procedure} file-write-access?
@deffnx {procedure} file-execute-access?
@lisp
(file-read-access? FILENAME)
(file-write-access? FILENAME)
(file-execute-access? FILENAME)
@end lisp
These procedures return @code{#t} if the current user has read,
write or execute permissions on the file named @code{FILENAME}.

@end deffn
@deffn {procedure} change-file-mode
@lisp
(change-file-mode FILENAME MODE)
@end lisp
Changes the current file mode of the file named @code{FILENAME}
to @code{MODE} using the @code{chmod()} system call.  The
@code{perm/...} variables contain the various permission bits and can
be combinded with the @code{bitwise-ior} procedure.

@end deffn
@deffn {procedure} change-file-owner
@lisp
(change-file-owner FILENAME UID GID)
@end lisp
Changes the owner information of the file named @code{FILENAME} to
the user- and group-ids @code{UID} and @code{GID} (which should be
exact integers) using the @code{chown()} system call.

@end deffn
@deffn {procedure} current-user-id
@deffnx {procedure} current-group-id
@deffnx {procedure} current-effective-user-id
@deffnx {procedure} current-effective-group-id
@lisp
(current-user-id)
(current-group-id)
(current-effective-user-id)
(current-effective-group-id)
@end lisp
Return the user- and group-ids of the current process.

@deffn {procedure} process-group-id
@lisp
(process-group-id PID)
@end lisp
Returns the process group ID of the process specified by @code{PID}.
@end deffn

@end deffn
@deffn {procedure} group-information
@lisp
(group-information GROUP)
@end lisp
If @code{GROUP} specifies a valid group-name or group-id, then this
procedure returns a list of four values: the group-name, the encrypted group password,
the group ID and a list of the names of all group members. If no group with the
given name or ID exists, then @code{#f} is returned.
@end deffn

@deffn {procedure} get-groups
@lisp
(get-groups)
@end lisp
Returns a list with the supplementary group IDs of the current user.
@end deffn

@deffn {procedure} set-groups!
@lisp
(set-groups! GIDLIST)
@end lisp
Sets the supplementrary group IDs of the current user to the IDs given in the list @code{GIDLIST}.

Only the superuser may invoke this procedure.
@end deffn

@deffn {procedure} initialize-groups
@lisp
(initialize-groups USERNAME BASEGID)
@end lisp
Sets the supplementrary group IDs of the current user to the IDs from the user with name @code{USERNAME} 
(a string), including @code{BASEGID}.

Only the superuser may invoke this procedure.
@end deffn

@defvr {permission bits} perm/irusr
@defvrx {permission bits} perm/iwusr
@defvrx {permission bits} perm/ixusr
@defvrx {permission bits} perm/irgrp
@defvrx {permission bits} perm/iwgrp
@defvrx {permission bits} perm/ixgrp
@defvrx {permission bits} perm/iroth
@defvrx {permission bits} perm/iwoth
@defvrx {permission bits} perm/ixoth
@defvrx {permission bits} perm/irwxu
@defvrx {permission bits} perm/irwxg
@defvrx {permission bits} perm/irwxo
@defvrx {permission bits} perm/isvtx
@defvrx {permission bits} perm/isuid
@defvrx {permission bits} perm/isgid
These variables contain permission bits as used in @code{change-file-mode}.
@end defvr

@deffn {procedure} set-user-id!
@lisp
(set-user-id! UID)
@end lisp
Sets the effective user id of the current process to @code{UID},
which should be a positive integer.
@end deffn

@deffn {procedure} set-group-id!
@lisp
(set-group-id! GID)
@end lisp
Sets the effective group id of the current process to @code{GID},
which should be a positive integer.
@end deffn

@deffn {procedure} set-process-group-id!
@lisp
(set-user-id! PID PGID)
@end lisp
Sets the process group ID of the process specifed by @code{PID} to @code{PGID}.
@end deffn

@deffn {procedure} user-information
@lisp
(user-information USER)
@end lisp
If @code{USER} specifes a valid username (as a string) or user ID, then
the user database is consulted and a list of 7 values are returned: the user-name,
the encrypted password, the user ID, the group ID, a user-specific string,
the home directory and the default shell. If no user with this name or
ID can be found, then @code{#f} is returned.
@end deffn

@deffn {procedure} create-session
@lisp
(create-session)
@end lisp
Creates a new session if the calling process is not a process group leader and returns
the session ID.
@end deffn



@node Record locking
@subsection Record locking




@deffn {procedure} file-lock
@lisp
(file-lock PORT [START [LEN]])
@end lisp
Locks the file associated with @code{PORT} for reading or
writing (according to whether @code{PORT} is an input- or
output-port). @code{START} specifies the starting position in the
file to be locked and defaults to 0. @code{LEN} specifies the length
of the portion to be locked and defaults to @code{#t}, which means
the complete file. @code{file-lock} returns a ``lock''-object.

@end deffn
@deffn {procedure} file-lock/blocking
@lisp
(file-lock/blocking PORT [START [LEN]])
@end lisp
Similar to @code{file-lock}, but if a lock is held on the file,
the current process blocks (including all threads) until the lock is released.

@end deffn
@deffn {procedure} file-test-lock
@lisp
(file-test-lock PORT [START [LEN]])
@end lisp
Tests whether the file associated with @code{PORT} is locked for reading
or writing (according to whether @code{PORT} is an input- or output-port)
and returns either @code{#f} or the process-id of the locking process.

@end deffn
@deffn {procedure} file-unlock
@lisp
(file-unlock LOCK)
@end lisp
Unlocks the previously locked portion of a file given in @code{LOCK}.
@end deffn




@node Signal handling
@subsection Signal handling




@deffn {procedure} set-alarm!
@lisp
(set-alarm! SECONDS)
@end lisp
Sets an internal timer to raise the @code{signal/alrm}
after @code{SECONDS} are elapsed.  You can use the
@code{set-signal-handler!} procedure to write a handler for this signal.

@end deffn
@deffn {procedure} set-signal-handler!
@lisp
(set-signal-handler! SIGNUM PROC)
@end lisp
Establishes the procedure of one argument @code{PROC} as the handler
for the signal with the code @code{SIGNAL}. @code{PROC} is called
with the signal number as its sole argument. If the argument @code{PROC} is @code{#f}
then this signal will be ignored. Note that is is unspecified in which thread of execution
the signal handler will be invoked.

@end deffn
@deffn {procedure} set-signal-mask!
@lisp
(set-signal-mask! SIGLIST)
@end lisp
Sets the signal mask of the current process to block all signals given
in the list @code{SIGLIST}.  Signals masked in that way will not be
delivered to the current process.
@end deffn

@defvr {signal code} signal/term
@defvrx {signal code} signal/kill
@defvrx {signal code} signal/int
@defvrx {signal code} signal/hup
@defvrx {signal code} signal/fpe
@defvrx {signal code} signal/ill
@defvrx {signal code} signal/segv
@defvrx {signal code} signal/abrt
@defvrx {signal code} signal/trap
@defvrx {signal code} signal/quit
@defvrx {signal code} signal/alrm
@defvrx {signal code} signal/vtalrm
@defvrx {signal code} signal/prof
@defvrx {signal code} signal/io
@defvrx {signal code} signal/urg
@defvrx {signal code} signal/chld
@defvrx {signal code} signal/cont
@defvrx {signal code} signal/stop
@defvrx {signal code} signal/tstp
@defvrx {signal code} signal/pipe
@defvrx {signal code} signal/xcpu
@defvrx {signal code} signal/xfsz
@defvrx {signal code} signal/usr1
@defvrx {signal code} signal/usr2
@defvrx {signal code} signal/winch
These variables contain signal codes for use with @code{process-signal} 
or @code{set-signal-handler!}.
@end defvr




@node Environment access
@subsection Environment access




@deffn {procedure} current-environment
@lisp
(current-environment)
@end lisp
Returns a association list of the environment variables and their
current values. 

@end deffn
@deffn {procedure} setenv
@lisp
(setenv VARIABLE VALUE)
@end lisp
Sets the environment variable named @code{VARIABLE} to
@code{VALUE}. Both arguments should be strings. If the variable is
not defined in the environment, a new definition is created.

@end deffn
@deffn {procedure} unsetenv
@lisp
(unsetenv VARIABLE)
@end lisp
Removes the definition of the environment variable @code{VARIABLE} from
the environment of the current process. If the variable is not defined,
nothing happens.
@end deffn




@node Memory mapped I/O
@subsection Memory mapped I/O



@deffn {pocedure} memory-mapped-file?
@lisp
(memory-mapped-file? X)
@end lisp
Returns @code{#t}, if @code{X} is an object representing a memory
mapped file, or @code{#f} otherwise.
@end deffn

@deffn {procedure} map-file-to-memory
@lisp
(map-file-to-memory ADDRESS LEN PROTECTION FLAG FILENO [OFFSET])
@end lisp
Maps a section of a file to memory using the C function
@code{mmap()}.  @code{ADDRESS} should be a foreign pointer object
or @code{#f}; @code{LEN} specifies the size of the section to
be mapped; @code{PROTECTION} should be one or more of the flags
@code{prot/read, prot/write, prot/exec} or @code{prot/none}
@b{bitwise-ior}ed together; @code{FLAG} should be one or more of
the flags @code{map/fixed, map/shared, map/private, map/anonymous} or
@code{map/file}; @code{FILENO} should be the file-descriptor of the
mapped file. The optional argument @code{OFFSET} gives the offset of
the section of the file to be mapped and defaults to 0. This procedure
returns an object representing the mapped file section.  The procedure
@code{move-memory!} can be used to access the mapped memory.

@end deffn
@deffn {procedure} memory-mapped-file-pointer
@lisp
(memory-mapped-file-pointer MMAP)
@end lisp
Returns a machine pointer to the start of the memory region to which
the file is mapped.

@end deffn
@deffn {procedure} unmap-file-from-memory
@lisp
(unmap-file-from-memory MMAP [LEN])
@end lisp
Unmaps the section of a file mapped to memory using the C function
@code{munmap()}.  @code{MMAP} should be a mapped file as returned
by the procedure @code{map-file-to-memory}.  The optional argument
@code{LEN} specifies the length of the section to be unmapped and
defaults to the complete length given when the file was mapped.
@end deffn



@node Date and time routines
@subsection Date and time routines



@deffn {procedure} seconds->local-time
@lisp
(seconds->local-time SECONDS)
@end lisp
Breaks down the time value represented in @code{SECONDS} into a 10
element vector of the form @code{#(seconds minutes hours mday month
year wday yday dstflag timezone)}, in the following format:

@itemize
@item seconds: the number of seconds after the minute (0 - 59)
@item minutes: the number of minutes after the hour (0 - 59)
@item hours: the number of hours past midnight (0 - 23)
@item mday: the day of the month (1 - 31)
@item month: the number of months since january (0 - 11)
@item year: the number of years since 1900
@item wday: the number of days since Sunday (0 - 6)
@item yday: the number of days since January 1 (0 - 365)
@item dstflag: a flag that is true if Daylight Saving Time is in effect at the time described.
@item timezone: the difference between UTC and the latest local standard
time, in seconds west of UTC.
@end itemize

@end deffn

@deffn {procedure} local-time->seconds
@lisp
(local-time->seconds VECTOR)
@end lisp
Converts the ten-element vector @code{VECTOR} representing the time value relative to
the current timezone into
the number of seconds since the first of January, 1970 UTC.
@end deffn

@deffn {procedure} local-timezone-abbreviation
@lisp
(local-timezone-abbrevtiation)
@end lisp
Returns the abbreviation for the local timezone as a string.
@end deffn

@deffn {procedure} seconds->string
@lisp
(seconds->string SECONDS)
@end lisp
Converts the local time represented in @code{SECONDS} into a string
of the form @code{"Tue May 21 13:46:22 1991\n"}.

@end deffn
@deffn {procedure} seconds->utc-time
@lisp
(seconds->utc-time SECONDS)
@end lisp
Similar to @code{seconds->local-time}, but interpretes @code{SECONDS}
as UTC time.

@end deffn

@deffn {procedure} utc-time->seconds
@lisp
(utc-time->seconds VECTOR)
@end lisp
Converts the ten-element vector @code{VECTOR} representing the UTC time value into
the number of seconds since the first of January, 1970 UTC.
@end deffn

@deffn {procedure} time->string
@lisp
(time->string VECTOR)
@end lisp
Converts the broken down time represented in the 10 element vector
@code{VECTOR} into a string of the form @code{"Tue May 21 13:46:22
1991\n"}.
@end deffn




@node Raw exit
@subsection @emph{Raw} exit



@deffn {procedure} _exit
@lisp
(_exit [CODE])
@end lisp
Exits the current process without flushing any buffered output (using
the C function @code{_exit}).  Note that the @code{exit-handler}
is not called when this procedure is invoked. The optional return-code
@code{CODE} defaults to @code{0}.
@end deffn




@node ERRNO values
@subsection ERRNO values



@defvr {error code} errno/perm
@defvrx {error code} errno/noent
@defvrx {error code} errno/srch
@defvrx {error code} errno/intr
@defvrx {error code} errno/io
@defvrx {error code} errno/noexec
@defvrx {error code} errno/badf
@defvrx {error code} errno/child
@defvrx {error code} errno/nomem
@defvrx {error code} errno/acces
@defvrx {error code} errno/fault
@defvrx {error code} errno/busy
@defvrx {error code} errno/notdir
@defvrx {error code} errno/isdir
@defvrx {error code} errno/inval
@defvrx {error code} errno/mfile
@defvrx {error code} errno/nospc
@defvrx {error code} errno/spipe
@defvrx {error code} errno/pipe
@defvrx {error code} errno/again
@defvrx {error code} errno/rofs
@defvrx {error code} errno/exist
@defvrx {error code} errno/wouldblock
These variables contain error codes as returned by @code{errno}.
@end defvr




@node Finding files
@subsection Finding files



@deffn {procedure} find-files
@lisp
(find-files DIRECTORY PREDICATE [ACTION [IDENTITY [LIMIT]]])
@end lisp
Recursively traverses the contents of @code{DIRECTORY} (which should
be a string) and invokes the procedure @code{ACTION} for all files
for which the procedure @code{PREDICATE} is true.  @code{PREDICATE}
may me a procedure of one argument or a regular-expression string.
@code{ACTION} should be a procedure of two arguments: the currently
encountered file and the result of the previous invocation of
@code{ACTION}, or, if this is the first invocation, the value
of @code{IDENTITY}. @code{ACTION} defaults to @code{cons},
@code{IDENTITY} defaults to @code{()}.  @code{LIMIT} should a
procedure of one argument that is called for each nested directory
and which should return true, if that directory is to be traversed
recursively. @code{LIMIT} may also be an exact integer that
gives the maximum recursion depth. A depth of @code{0} means the
files in the specified directory are traversed but not any nested
directories. @code{LIMIT} may also be @code{#f} (the default),
which is equivalent to @code{(constantly #t)}.

Note that @code{ACTION} is called with the full pathname of each file,
including the directory prefix.
@end deffn




@node Getting the hostname and system information
@subsection Getting the hostname and system information



@deffn {procedure} get-host-name
@lisp
(get-host-name)
@end lisp
Returns the hostname of the machine that this process is running on.

@end deffn
@deffn {procedure} system-information
@lisp
(system-information)
@end lisp
Invokes the UNIX system call @code{uname()} and returns a list of 5 values:
system-name, node-name, OS release, OS version and machine.
@end deffn




@node Setting the file buffering mode
@subsection Setting the file buffering mode



@deffn {procedure} set-buffering-mode!
@lisp
(set-buffering-mode! PORT MODE [BUFSIZE])
@end lisp
Sets the buffering-mode for the file associated with @code{PORT} to
@code{MODE}, which should be one of the keywords @code{#:full,
#:line} or @code{#:none}. If @code{BUFSIZE} is specified it
determines the size of the buffer to be used (if any).
@end deffn




@node Terminal ports
@subsection Terminal ports



@deffn {procedure} terminal-name
@lisp
(terminal-name PORT)
@end lisp
Returns the name of the terminal that is connected to @code{PORT}.

@end deffn
@deffn {procedure} terminal-port?
@lisp
(terminal-port? PORT)
@end lisp
Returns @code{#t} if @code{PORT} is connected to a terminal and
@code{#f} otherwise.
@end deffn




@node How Scheme procedures relate to UNIX C functions
@subsection How Scheme procedures relate to UNIX C functions

@c XXX Is there a better way to get rid of the  ?

@table @code
@item change-directory
chdir
@item change-file-mode
chmod
@item change-file-owner
chown
@item create-directory
mkdir
@item create-fifo
mkfifo
@item create-pipe
pipe
@item create-session
setsid
@item create-symbolic-link
link
@item current-directory
curdir
@item current-effective-groupd-id
getegid
@item current-effective-user-id
geteuid
@item current-group-id
getgid
@item current-parent-id
getppid
@item current-process-id
getpid
@item current-user-id
getuid
@item delete-directory
rmdir
@item duplicate-fileno
dup/dup2
@item _exit
_exit
@item file-close
close
@item file-access-time
stat
@item file-change-time
stat
@item file-modification-time
stat
@item file-execute-access?
access
@item file-open
open
@item file-lock
fcntl
@item file-position
ftell/lseek
@item file-read
read
@item file-read-access?
access
@item file-select
select
@item file-stat
stat
@item file-test-lock
fcntl
@item file-truncate
truncate/ftruncate
@item file-unlock
fcntl
@item file-write
write
@item file-write-access?
access
@item get-groups
getgroups
@item get-host-name
gethostname
@item initialize-groups
initgroups
@item local-time->seconds
mktime
@item local-timezone-abbreviation
localtime
@item map-file-to-memory
mmap
@item open-input-file*
fdopen
@item open-output-file*
fdopen
@item open-input-pipe
popen
@item open-output-pipe
popen
@item port->fileno
fileno
@item process-execute
execvp
@item process-fork
fork
@item process-group-id
getpgid
@item process-signal
kill
@item process-wait
waitpid
@item close-input-pipe
pclose
@item close-output-pipe
pclose
@item read-symbolic-link
readlink
@item seconds->local-time
localtime
@item seconds->string
ctime
@item seconds->utc-time
gmtime
@item set-alarm!
alarm
@item set-buffering-mode!
setvbuf
@item set-file-position!
fseek/seek
@item set-groups!
setgroups
@item set-signal-mask!
sigprocmask
@item set-group-id!
setgid
@item set-process-group-id!
setpgid
@item set-user-id!
setuid
@item set-root-directory!
chroot
@item setenv
setenv/putenv
@item sleep
sleep
@item system-information
uname
@item terminal-name
ttyname
@item terminal-port?
isatty
@item time->string
asctime
@item unsetenv
putenv
@item unmap-file-from-memory
munmap
@item user-information
getpwnam/getpwuid
@item utc-time->seconds
timegm
@end table


@node Windows specific notes
@subsection Windows specific notes

The following definitions are not supported for native Windows builds (compiled with the
Microsoft tools or with MingW):

@verbatim
open/noctty  open/nonblock  open/fsync  open/sync
perm/isvtx  perm/isuid  perm/isgid
file-select
signal/...
set-signal-handler!  set-signal-mask!
user-information  group-information  get-groups  set-groups!  initialize-groups
errno/wouldblock
change-file-owner
current-user-id  current-group-id  current-effective-user-id  current-effective-groupd-id
set-user-id!  set-group-id!
create-session
process-group-id  set-process-group-id!
create-symbolic-link  read-symbolic-link
file-truncate 
file-lock  file-lock/blocking  file-unlock  file-test-lock
create-fifo  fifo?
prot/...
map/...
map-file-to-memory  unmap-file-from-memory  memory-mapped-file-pointer  memory-mapped-file?
set-alarm!
terminal-port?  terminal-name
process-fork  process-signal
parent-process-id 
set-root-directory!
utc-time->seconds local-timezone-abbreviation
@end verbatim

Additionally, the following definitions are only available for Windows:

@defvr {spawn mode} spawn/overlay
@defvrx {spawn mode} spawn/wait
@defvrx {spawn mode} spawn/nowait
@defvrx {spawn mode} spawn/nowaito
@defvrx {spawn mode} spawn/detach
These variables contains special flags that specify the exact semantics of @code{process-spawn}:
@code{spawn/overlay} replaces the current process with the new one. 
@code{spawn/wait} suspends execution of the current process until the spawned process returns. 
@code{spawn/nowait} does the opposite (@code{spawn/nowaito} is identical, according to the Microsoft
documentation) and runs the process asynchronously.
@code{spawn/detach} runs the new process in the background, without being attached to a console.
@end defvr

@deffn {procedure} process-spawn
@lisp
(process-spawn MODE FILENAME ARGUMENT ...)
@end lisp
Creates and runs a new process with the given filename and command-line arguments. @code{MODE} specifies
how exactly the process should be executed and must be one or more of the @code{spawn/...} flags defined
above.
@end deffn


@node Unit utils
@section Unit utils

This unit contains some utility procedures for Shell scripting and for
some file operations.

This unit uses the @code{extras} and @code{regex} units.


@menu
* Pathname operations::         
* Temporary files::             
* Deleting a file without signalling an error::  
* Iterating over input lines and files::  
* Executing shell commands with formatstring and error checking::  
* Reading a file's contents::
* Miscellaneous handy things::
@end menu

@node Pathname operations
@subsection Pathname operations




@deffn {procedure} absolute-pathname?
@lisp
(absolute-pathname? PATHNAME)
@end lisp
Returns @code{#t} if the string @code{PATHNAME} names an absolute
pathname, and returns @code{#f} otherwise.

@end deffn
@deffn {procedure} decompose-pathname
@lisp
(decompose-pathname PATHNAME)
@end lisp
Returns three values: the directory-, filename- and extension-components
of the file named by the string @code{PATHNAME}. For any component
that is not contained in @code{PATHNAME}, @code{#f} is returned.

@end deffn
@deffn {procedure} make-pathname
@deffnx {procedure} make-absolute-pathname
@lisp
(make-pathname DIRECTORY FILENAME [EXTENSION])
(make-absolute-pathname DIRECTORY FILENAME [EXTENSION])
@end lisp
Returns a string that names the file with the
components @code{DIRECTORY, FILENAME} and (optionally)
@code{EXTENSION}. @code{DIRECTORY} can be @code{#f} (meaning no
directory component), a string or a list of strings. @code{FILENAME}
and @code{EXTENSION} should be strings or @code{#f}.
@code{make-absolute-pathname} returns always an absolute pathname.
@end deffn

@deffn {procedure} pathname-directory
@lisp
(pathname-directory PATHNAME)
@end lisp
@end deffn
@deffn {procedure} pathname-file
@lisp
(pathname-file PATHNAME)
@end lisp
@end deffn
@deffn {procedure} pathname-extension
@lisp
(pathname-extension PATHNAME)
@end lisp
Accessors for the components of @code{PATHNAME}. If the pathname does
not contain the accessed component, then @code{#f} is returned.

@end deffn
@deffn {procedure} pathname-replace-directory
@lisp
(pathname-replace-directory PATHNAME DIRECTORY)
@end lisp
@end deffn
@deffn {procedure} pathname-replace-file
@lisp
(pathname-replace-file PATHNAME FILENAME)
@end lisp
@end deffn
@deffn {procedure} pathname-replace-extension
@lisp
(pathname-replace-extension PATHNAME EXTENSION)
@end lisp
Return a new pathname with the specified component of @code{PATHNAME}
replaced by a new value.

@end deffn
@deffn {procedure} pathname-strip-directory
@lisp
(pathname-strip-directory PATHNAME)
@end lisp
@end deffn
@deffn {procedure} pathname-strip-extension
@lisp
(pathname-strip-extension PATHNAME)
@end lisp
Return a new pathname with the specified component of @code{PATHNAME}
stripped.
@end deffn




@node Temporary files
@subsection Temporary files



@deffn {procedure} create-temporary-file
@lisp
(create-temporary-file [EXTENSION])
@end lisp
Creates an empty temporary file and returns its pathname. If
@code{EXTENSION} is not given, then @code{.tmp} is used. If the
environment variable @code{TMPDIR, TEMP} or @code{TMP} is set,
then the pathname names a file in that directory.

@end deffn



@node Deleting a file without signalling an error
@subsection Deleting a file without signalling an error



@deffn {procedure} delete-file*
@lisp
(delete-file* FILENAME)
@end lisp
If the file @code{FILENAME} exists, it is deleted and @code{#t}
is returned.  If the file does not exist, nothing happens and @code{#f}
is returned.
@end deffn




@node Iterating over input lines and files
@subsection Iterating over input lines and files



@deffn {procedure} for-each-line
@lisp
(for-each-line PROCEDURE [PORT])
@end lisp
Calls @code{PROCEDURE} for each line read from @code{PORT} (which defaults to the
value of @code{(current-input-port)}. The argument passed to @code{PORCEDURE}
is a string with the contents of the line, excluding any line-terminators.
When all input has been read from the port, @code{for-each-line} returns some unspecified value.

@end deffn
@deffn {procedure} for-each-argv-line
@lisp
(for-each-argv-line PROCEDURE)
@end lisp
 Opens each file listed on the command line in order, passing one line
at a time into @code{PROCEDURE}.  The filename @code{-} is interpreted as
@code{(current-input-port)}.  If no arguments are given on the command line
it again uses the value of @code{(current-input-port)}. During execution of
@code{PROCEDURE}, the current input port will be correctly bound to
the current input source.

This code will act as a simple Unix cat(1) command:
 
@verbatim
(for-each-argv-line print)
@end verbatim
@end deffn

@deffn {procedure} port-for-each
@deffnx {procedure} port-map
@lisp
(port-for-each FN THUNK)
(port-map FN THUNK)
@end lisp
Apply @code{FN} to successive results of calling the zero argument procedure @code{THUNK}
until it returns @code{#!eof}. @code{port-for-each} discards the results, while @code{port-map}
returns a list of the collected results.
@end deffn


@node Executing shell commands with formatstring and error checking
@subsection Executing shell commands with formatstring and error checking



@deffn {procedure} system*
@lisp
(system* FORMATSTRING ARGUMENT1 ...)
@end lisp
Similar to @code{(system (sprintf FORMATSTRING ARGUMENT1 ...))},
but signals an error if the invoked program should return a nonzero
exit status.
@end deffn


@node Reading a file's contents
@subsection Reading a file's contents


@deffn {procedure} read-all
@lisp
(read-all [FILE-OR-PORT])
@end lisp
If @code{FILE-OR-PORT} is a string, then this procedure returns the contents of the file
as a string. If @code{FILE-OR-PORT} is a port, all remaining input is read and returned as
a string. The port is not closed. If no argument is provided, input will be read from the
port that is the current value of @code{(current-input-port)}.
@end deffn


@node Miscellaneous handy things
@subsection Miscellaneous handy things


@deffn {procedure} shift!
@lisp
(shift! LIST [DEFAULT])
@end lisp
Returns the car of @code{LIST} (or @code{DEFAULT} if @code{LIST} is empty) and replaces
the car of @code{LIST} with it's cadr and the cdr with the cddr. If @code{DEFAULT} is not given, and
the list is empty, @code{#f} is returned. An example might be clearer, here:

@lisp
(define lst '(1 2 3))
(shift! lst)             ==> 1, lst is now (2 3)
@end lisp 

The list must at least contain 2 elements.
@end deffn

@deffn {procedure} unshift!
@lisp
(unshift! X PAIR)
@end lisp
Sets the car of @code{PAIR} to @code{X} and the cdr to its cddr. Returns @code{PAIR}:

@lisp
(define lst '(2))
(unshift! 99 lst)      ; lst is now (99 2)
@end lisp
@end deffn


@node Unit tcp
@section Unit tcp

This unit provides basic facilities for communicating over TCP sockets.
The socket interface should be mostly compatible to the one found in
PLT Scheme.

This unit uses the @code{extras} unit.

All errors related to failing network operations will raise a condition
of kind @code{(exn i/o network)}.



@deffn {procedure} tcp-listen
@lisp
(tcp-listen TCPPORT [BACKLOG [HOST]])
@end lisp
Creates and returns a TCP listener object that listens for connections on @code{TCPPORT}, which
should be an exact integer. @code{BACKLOG} specifies the number of maximally pending
connections (and defaults to 4). If the optional argument @code{HOST} is given and not
@code{#f}, then only incoming connections for the given host (or IP) are accepted.

@end deffn
@deffn {procedure} tcp-listener?
@lisp
(tcp-listener? X)
@end lisp
Returns @code{#t} if @code{X} is a TCP listener object, or @code{#f} otherwise.

@end deffn
@deffn {procedure} tcp-close
@lisp
(tcp-close LISTENER)
@end lisp
Reclaims any resources associated with @code{LISTENER}.

@end deffn
@deffn {procedure} tcp-accept
@lisp
(tcp-accept LISTENER)
@end lisp
Waits until a connection is established on the port on which @code{LISTENER} is listening and
returns two values: an input- and output-port that can be used to communicate with the
remote process. 

Note: this operation and any I/O on the ports returned will not block other running threads.

@end deffn
@deffn {procedure} tcp-accept-ready?
@lisp
(tcp-accept-ready? LISTENER)
@end lisp
Returns @code{#t} if there are any connections pending on @code{LISTENER}, or @code{#f}
otherwise.

@end deffn
@deffn {procedure} tcp-listener-port
@lisp
(tcp-listener-port LISTENER)
@end lisp
Returns the port number assigned to @code{LISTENER} (If you pass @code{0} to @code{tcp-listen},
then the system will choose a port-number for you).

@end deffn
@deffn {procedure} tcp-listener-fileno
@lisp
(tcp-listener-port LISTENER)
@end lisp
Returns the file-descriptor associated with @code{LISTENER}.

@end deffn
@deffn {procedure} tcp-connect
@lisp
(tcp-connect HOSTNAME [TCPPORT])
@end lisp
Establishes a client-side TCP connection to the machine with the name @code{HOSTNAME} (a string)
at @code{TCPPORT} (an exact integer) and returns two values: an input- and output-port for communicating
with the remote process.

Note: any I/O on the ports returned will not block other running threads.

@end deffn
@deffn {procedure} tcp-addresses
@lisp
(tcp-addresses PORT)
@end lisp
Returns two values for the input- or output-port @code{PORT} (which should be a port returned
by either @code{tcp-accept} or @code{tcp-connect}): the IP address of the local and the remote
machine that are connected over the socket associated with @code{PORT}. The returned addresses
are strings in @code{XXX.XXX.XXX.XXX} notation.

@end deffn
@deffn {procedure} tcp-port-numbers
@lisp
(tcp-port-numbers PORT)
@end lisp
Returns two values for the input- or output-port @code{PORT} (which should be a port returned
by either @code{tcp-accept} or @code{tcp-connect}): the TCP port numbers of the local and the remote
machine that are connected over the socket associated with @code{PORT}.

@end deffn
@deffn {procedure} tcp-abandon-port
@lisp
(tcp-abandon-port PORT)
@end lisp
Marks the socket port @code{PORT} as abandoned. This is mainly useful to close down a port
without breaking the connection.
@end deffn

@deffn {parameter} tcp-buffer-size
Sets the size of the output buffer. By default no output-buffering for
TCP output is done, but to improve performance by minimizing the
number of TCP packets, buffering may be turned on by setting this
parameter to an exact integer greater zero. A buffer size of zero or @code{#f}
turns buffering off. The setting of this parameter takes effect at the time
when the I/O ports for a particular socket are created, i.e. when @code{tcp-connect}
or @code{tcp-accept} is called.

Note that since output is not immediately written to the associated socket, you
may need to call @code{flush-output}, once you want the output to be transmitted.
Closing the output port will flush automatically.
@end deffn


A very simple example follows. Say we have the two files @code{client.scm}
and @code{server.scm}:

@verbatim
; client.scm
(define-values (i o) (tcp-connect "localhost" 4242))
(write-line "Good Bye!" o)
(print (read-line i))
@end verbatim

@verbatim
; server.scm
(define l (tcp-listen 4242))
(define-values (i o) (tcp-accept l))
(write-line "Hello!" o)
(print (read-line i))
(close-input-port i)
(close-output-port o)

% csi -script server.scm &
[1] 1409
% csi -script client.scm
Good Bye!
Hello!
@end verbatim


@node Unit lolevel
@section Unit lolevel


This unit provides a number of handy low-level operations. @b{Use
at your own risk.}


This unit uses the @code{srfi-4} and @code{extras} units.


@menu
* Foreign pointers::            
* Tagged pointers::             
* Extending procedures with data::  
* Bytevectors::                 
* Data in unmanaged memory::    
* Locatives::                   
* Accessing toplevel variables::  
* Low-level data access::       
* Procedure-call- and variable reference hooks::  
* Magic::                       
@end menu

@node Foreign pointers
@subsection Foreign pointers




@deffn {procedure} address->pointer
@lisp
(address->pointer ADDRESS)
@end lisp
Creates a new foreign pointer object initialized to point to the address
given in the integer @code{ADDRESS}.

@end deffn
@deffn {procedure} allocate
@lisp
(allocate BYTES)
@end lisp
Returns a pointer to a freshly allocated region of static memory.
This procedure could be defined as follows:

@verbatim
(define allocate (foreign-lambda c-pointer "malloc" integer))
@end verbatim

@end deffn
@deffn {procedure} free
@lisp
(free POINTER)
@end lisp
Frees the memory pointed to by @code{POINTER}.  This procedure could
be defined as follows:

@verbatim
(define free (foreign-lambda c-pointer "free" integer))
@end verbatim

@end deffn
@deffn {procedure} null-pointer
@lisp
(null-pointer)
@end lisp
Another way to say @code{(address->pointer 0)}.

@end deffn
@deffn {procedure} null-pointer?
@lisp
(null-pointer? PTR)
@end lisp
Returns @code{#t} if @code{PTR} contains a @code{NULL} pointer,
or @code{#f} otherwise.

@end deffn
@deffn {procedure} object->pointer
@lisp
(object->pointer X)
@end lisp
Returns a pointer pointing to the Scheme object X, which should be a
non-immediate object.  Note that data in the garbage collected heap
moves during garbage collection.

@end deffn
@deffn {procedure} pointer?
@lisp
(pointer? X)
@end lisp
Returns @code{#t} if @code{X} is a foreign pointer object, and
@code{#f} otherwise.

@deffn {procedure} pointer=?
@lisp
(pointer=? PTR1 PTR2)
@end lisp
Returns @code{#t} if the pointer-like objects @code{PTR1} and @code{PTR2} point
to the same address.
@end deffn

@end deffn
@deffn {procedure} pointer->address
@lisp
(pointer->address PTR)
@end lisp
Returns the address, to which the pointer @code{PTR} points.

@end deffn
@deffn {procedure} pointer->object
@lisp
(pointer->object PTR)
@end lisp
Returns the Scheme object pointed to by the pointer @code{PTR}.

@end deffn
@deffn {procedure} pointer-offset
@lisp
(pointer-offset PTR N)
@end lisp
Returns a new pointer representing the pointer @code{PTR} increased
by @code{N}.

@end deffn
@deffn {procedure} pointer-u8-ref
@lisp
(pointer-u8-ref PTR)
@end lisp
Returns the unsigned byte at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-s8-ref
@lisp
(pointer-s8-ref PTR)
@end lisp
Returns the signed byte at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-u16-ref
@lisp
(pointer-u16-ref PTR)
@end lisp
Returns the unsigned 16-bit integer at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-s16-ref
@lisp
(pointer-s16-ref PTR)
@end lisp
Returns the signed 16-bit integer at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-u32-ref
@lisp
(pointer-u32-ref PTR)
@end lisp
Returns the unsigned 32-bit integer at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-s32-ref
@lisp
(pointer-s32-ref PTR)
@end lisp
Returns the signed 32-bit integer at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-f32-ref
@lisp
(pointer-f32-ref PTR)
@end lisp
Returns the 32-bit float at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-f64-ref
@lisp
(pointer-f64-ref PTR)
@end lisp
Returns the 64-bit double at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-u8-set!
@lisp
(pointer-u8-set! PTR N)
(set! (pointer-u8-ref PTR) N)
@end lisp
Stores the unsigned byte @code{N} at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-s8-set!
@lisp
(pointer-s8-set! PTR N)
(set! (pointer-s8-ref PTR) N)
@end lisp
Stores the signed byte @code{N} at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-u16-set!
@lisp
(pointer-u16-set! PTR N)
(set! (pointer-u16-ref PTR) N)
@end lisp
Stores the unsigned 16-bit integer @code{N} at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-s16-set!
@lisp
(pointer-s16-set! PTR N)
(set! (pointer-s16-ref PTR) N)
@end lisp
Stores the signed 16-bit integer @code{N} at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-u32-set!
@lisp
(pointer-u32-set! PTR N)
(set! (pointer-u32-ref PTR) N)
@end lisp
Stores the unsigned 32-bit integer @code{N} at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-s32-set!
@lisp
(pointer-s32-set! PTR N)
(set! (pointer-s32-ref PTR) N)
@end lisp
Stores the 32-bit integer @code{N} at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-f32-set!
@lisp
(pointer-f32-set! PTR N)
(set! (pointer-f32-ref PTR) N)
@end lisp
Stores the 32-bit floating-point number @code{N} at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} pointer-f64-set!
@lisp
(pointer-f64-set! PTR N)
(set! (pointer-f64-ref PTR) N)
@end lisp
Stores the 64-bit floating-point number @code{N} at the address designated by @code{PTR}.

@end deffn
@deffn {procedure} align-to-word
@lisp
(align-to-word PTR-OR-INT)
@end lisp
Accepts either a machine pointer or an integer as argument and returns
a new pointer or integer aligned to the native word size of the host
platform.
@end deffn




@node Tagged pointers
@subsection Tagged pointers

``Tagged'' pointers are foreign pointer objects with an extra tag object.



@deffn {procedure} tag-pointer
@lisp
(tag-pointer PTR TAG)
@end lisp
Creates a new tagged pointer object from the foreign pointer @code{PTR} with the
tag @code{TAG}, which may an arbitrary Scheme object.

@end deffn
@deffn {procedure} tagged-pointer?
@lisp
(tagged-pointer? X TAG)
@end lisp
Returns @code{#t}, if @code{X} is a tagged pointer object with the tag @code{TAG}
(using an @code{eq?} comparison), or @code{#f} otherwise.

@end deffn
@deffn {procedure} pointer-tag
@lisp
(pointer-tag PTR)
@end lisp
If @code{PTR} is a tagged pointer object, its tag is returned. If @code{PTR} is a normal,
untagged foreign pointer object @code{#f} is returned. Otherwise an error is signalled.
@end deffn




@node Extending procedures with data
@subsection Extending procedures with data




@deffn {procedure} extend-procedure
@lisp
(extend-procedure PROCEDURE X)
@end lisp
Returns a copy of the procedure @code{PROCEDURE} which contains an
additional data slot initialized to @code{X}. If @code{PROCEDURE}
is already an extended procedure, then its data slot is changed to
contain @code{X} and the same procedure is returned.

@end deffn
@deffn {procedure} extended-procedure?
@lisp
(extended-procedure? PROCEDURE)
@end lisp
Returns @code{#t} if @code{PROCEDURE} is an extended procedure,
or @code{#f} otherwise.

@end deffn
@deffn {procedure} procedure-data
@lisp
(procedure-data PROCEDURE)
@end lisp
Returns the data object contained in the extended procedure @code{PROCEDURE},
or @code{#f} if it is not an extended procedure.

@end deffn
@deffn {procedure} set-procedure-data!
@lisp
(set-procedure-data! PROCEDURE X)
@end lisp
Changes the data object contained in the extended procedure
@code{PROCEDURE} to @code{X}.

@verbatim
(define foo
  (letrec ((f (lambda () (procedure-data x)))
           (x #f) )
    (set! x (extend-procedure f 123))
    x) )
(foo)                                         ==> 123
(set-procedure-data! foo 'hello)
(foo)                                         ==> hello
@end verbatim
@end deffn




@node Bytevectors
@subsection Bytevectors




@deffn {procedure} byte-vector
@lisp
(byte-vector FIXNUM ...)
@end lisp
Returns a freshly allocated byte-vector with @code{FIXNUM ...} as its
initial contents.

@end deffn
@deffn {procedure} byte-vector?
@lisp
(byte-vector? X)
@end lisp
Returns @code{#t} if @code{X} is a byte-vector object, or
@code{#f} otherwise.

@end deffn
@deffn {procedure} byte-vector-fill!
@lisp
(byte-vector-fill! BYTE-VECTOR N)
@end lisp
Sets each element of @code{BYTE-VECTOR} to @code{N}, which should
be an exact integer.

@end deffn
@deffn {procedure} byte-vector->list
@lisp
(byte-vector->list BYTE-VECTOR)
@end lisp
Returns a list with elements taken from @code{BYTE-VECTOR}.

@end deffn
@deffn {procedure} byte-vector->string
@lisp
(byte-vector->string BYTE-VECTOR)
@end lisp
Returns a string with the contents of @code{BYTE-VECTOR}.

@end deffn
@deffn {procedure} byte-vector-length
@lisp
(byte-vector-length BYTE-VECTOR)
@end lisp
Returns the number of elements in @code{BYTE-VECTOR}.

@end deffn
@deffn {procedure} byte-vector-ref
@lisp
(byte-vector-ref BYTE-VECTOR INDEX)
@end lisp
Returns the byte at the @code{INDEX}th position of @code{BYTE-VECTOR}.

@end deffn
@deffn {procedure} byte-vector-set!
@lisp
(byte-vector-set! BYTE-VECTOR INDEX N)
(set! (byte-vector-ref BYTE-VECTOR INDEX) N)
@end lisp
Sets the byte at the @code{INDEX}th position of @code{BYTE-VECTOR}
to the value of the exact integer @code{n}.

@end deffn
@deffn {procedure} list->byte-vector
@lisp
(list->byte-vector LIST)
@end lisp
Returns a byte-vector with elements taken from @code{LIST}, where the
elements of @code{LIST} should be exact integers.

@end deffn
@deffn {procedure} make-byte-vector
@lisp
(make-byte-vector SIZE [INIT])
@end lisp
Creates a new byte-vector of size @code{SIZE}. If @code{INIT} is
given, then it should be an exact integer with which every element of
the byte-vector is initialized.

@end deffn
@deffn {procedure} make-static-byte-vector
@lisp
(make-static-byte-vector SIZE [INIT])
@end lisp
As @code{make-byte-vector}, but allocates the byte-vector in storage
that is not subject to garbage collection.  To free the allocated memory,
one has to call @code{object-release} explicitly.

Exceptions: @code{(exn bounds)}, @code{(exn runtime)}

@end deffn
@deffn {procedure} static-byte-vector->pointer
@lisp
(static-byte-vector->pointer PBYTE-VECTOR)
@end lisp
Returns a pointer object pointing to the data in the statically allocated
byte-vector @code{PBYTE-VECTOR}.

@end deffn
@deffn {procedure} string->byte-vector
@lisp
(string->byte-vector STRING)
@end lisp
Returns a byte-vector with the contents of @code{STRING}.
@end deffn




@node Data in unmanaged memory
@subsection Data in unmanaged memory




@deffn {procedure} object-evict
@lisp
(object-evict X [ALLOCATOR])
@end lisp
Copies the object @code{X} recursively into the memory pointed
to by the foreign pointer object returned by @code{ALLOCATOR},
which should be a procedure of a single argument (the number of bytes
to allocate). The freshly copied object is returned.  This facility
allows moving arbitrary objects into static memory, but care should be
taken when mutating evicted data: setting slots in evicted vector-like
objects to non-evicted data is not allowed. It @b{is} possible to
set characters/bytes in evicted strings or byte-vectors, though.  It is
advisable @b{not} to evict ports, because they might be mutated by
certain file-operations.  @code{object-evict} is able to handle circular and
shared structures, but evicted symbols are no longer unique: a fresh
copy of the symbol is created, so

@verbatim
(define x 'foo)
(define y (object-evict 'foo))
y                              ==> foo
(eq? x y)                      ==> #f
(define z (object-evict '(bar bar)))
(eq? (car z) (cadr z))         ==> #t
@end verbatim

The @code{ALLOCATOR} defaults to @code{allocate}.

@end deffn
@deffn {procedure} object-evict-to-location
@lisp
(object-evict-to-location X PTR [LIMIT])
@end lisp
As @code{object-evict} but moves the object at the address pointed to by
the machine pointer @code{PTR}. If the number of copied bytes exceeds
the optional @code{LIMIT} then an error is signalled (specifically a composite
condition of types @code{exn} and @code{evict}. The latter provides
a @code{limit} property which holds the exceeded limit. Two values are
returned: the evicted object and a new pointer pointing to the first
free address after the evicted object.

@end deffn
@deffn {procedure} object-evicted?
@lisp
(object-evicted? X)
@end lisp
Returns @code{#t} if @code{X} is a non-immediate evicted data object,
or @code{#f} otherwise.

@end deffn
@deffn {procedure} object-size
@lisp
(object-size X)
@end lisp
Returns the number of bytes that would be needed to evict the data
object @code{X}.

@end deffn
@deffn {procedure} object-release
@lisp
(object-release X [RELEASER])
@end lisp
Frees memory occupied by the evicted object @code{X} recursively.
@code{RELEASER} should be a procedure of a single argument (a foreign
pointer object to the static memory to be freed) and defaults to
@code{free}.

@end deffn
@deffn {procedure} object-unevict
@lisp
(object-unevict X [FULL])
@end lisp
Copies the object @code{X} and nested objects back into the normal
Scheme heap.  Symbols are re-interned into the symbol table. Strings
and byte-vectors are @b{not} copied, unless @code{FULL} is given and
not @code{#f}.
@end deffn




@node Locatives
@subsection Locatives


A @emph{locative} is an object that points to an element of a containing object,
much like a ``pointer'' in low-level, imperative programming languages like ``C''. The element can
be accessed and changed indirectly, by performing access or change operations
on the locative. The container object can be computed by calling the
@code{location->object} procedure.

Locatives may be passed to foreign procedures that expect pointer arguments.
The effect of creating locatives for evicted data (see @code{object-evict}) is undefined.



@deffn {procedure} make-locative
@lisp
(make-locative EXP [INDEX])
@end lisp
Creates a locative that refers to the element of the non-immediate object @code{EXP}
at position @code{INDEX}. @code{EXP} may be a vector, pair, string, byte-vector,
SRFI-4 number-vector, or record. @code{INDEX} should be a fixnum. @code{INDEX} defaults to 0.

@end deffn
@deffn {procedure} make-weak-locative
@lisp
(make-weak-locative EXP [INDEX])
@end lisp
Creates a ``weak'' locative. Even though the locative refers to an element of a container object,
the container object will still be reclaimed by garbage collection if no other references
to it exist.

@end deffn
@deffn {procedure} locative?
@lisp
(locative? X)
@end lisp
Returns @code{#t} if @code{X} is a locative, or @code{#f} otherwise.

@end deffn
@deffn {procedure} locative-ref
@lisp
(locative-ref LOC)
@end lisp
Returns the element to which the locative @code{LOC} refers. If the containing
object has been reclaimed by garbage collection, an error is signalled.

@end deffn
@deffn {procedure} locative-set!
@lisp
(locative-set! LOC X)
(set! (locative-ref LOC) X)
@end lisp
Changes the element to which the locative @code{LOC} refers to @code{X}.
If the containing
object has been reclaimed by garbage collection, an error is signalled.

@end deffn
@deffn {procedure} locative->object
@lisp
(locative->object LOC)
@end lisp
Returns the object that contains the element referred to by @code{LOC} or
@code{#f} if the container has been reclaimed by garbage collection.
@end deffn




@node Accessing toplevel variables
@subsection Accessing toplevel variables




@deffn {procedure} global-bound?
@lisp
(global-bound? SYMBOL)
@end lisp
Returns @code{#t}, if the global (``toplevel'') variable with the name @code{SYMBOL}
is bound to a value, or @code{#f} otherwise.

@end deffn
@deffn {procedure} global-ref
@lisp
(global-ref SYMBOL)
@end lisp
Returns the value of the global variable @code{SYMBOL}.
If no variable under that name is bound, an error is signalled.

Note that it is not possible to access a toplevel binding with @code{global-ref} or
@code{global-set!} if it has been hidden in compiled code via @code{(declare (hide ...))},
or if the code has been compiled in @code{block} mode.

@end deffn
@deffn {procedure} global-set!
@lisp
(global-set! SYMBOL X)
(set! (global-ref SYMBOL) X)
@end lisp
Sets the global variable named @code{SYMBOL} to the value @code{X}.
@end deffn




@node Low-level data access
@subsection Low-level data access



@deffn {procedure} block-ref
@lisp
(block-ref BLOCK INDEX)
@end lisp
Returns the contents of the @code{INDEX}th slot of the object
@code{BLOCK}.  @code{BLOCK} may be a vector, record structure,
pair or symbol.

@end deffn
@deffn {procedure} block-set!
@lisp
(block-set! BLOCK INDEX X)
(set! (block-ref BLOCK INDEX) X)
@end lisp
Sets the contents of the @code{INDEX}th slot of the object
@code{BLOCK} to the value of @code{X}.  @code{BLOCK} may be a
vector, record structure, pair or symbol.

@end deffn
@deffn {procedure} object-copy
@lisp
(object-copy X)
@end lisp
Copies @code{X} recursively and returns the fresh copy. Objects
allocated in static memory are copied back into garbage collected storage.

@end deffn
@deffn {procedure} make-record-instance
@lisp
(make-record-instance SYMBOL ARG1 ...)
@end lisp
Returns a new instance of the record type @code{SYMBOL}, with its
slots initialized to @code{ARG1 ...}.  To illustrate:

@verbatim
(define-record point x y)
@end verbatim

expands into something quite similar to:

@verbatim
(begin
  (define (make-point x y)
    (make-record-instance 'point x y) )
  (define (point? x)
    (and (record-instance? x)
         (eq? 'point (block-ref x 0)) ) )
  (define (point-x p) (block-ref p 1))
  (define (point-x-set! p x) (block-set! p 1 x))
  (define (point-y p) (block-ref p 2))
  (define (point-y-set! p y) (block-set! p 1 y)) )
@end verbatim

@end deffn
@deffn {procedure} move-memory!
@lisp
(move-memory! FROM TO [BYTES])
@end lisp
Copies @code{BYTES} bytes of memory from @code{FROM} to @code{TO}.
@code{FROM} and @code{TO} may be strings, primitive byte-vectors,
SRFI-4 byte-vectors (see: @ref{Unit srfi-4}), memory mapped files, foreign
pointers (as obtained from a call to @code{foreign-lambda}, for
example) or locatives. if @code{BYTES} is not given and the size of the source
or destination operand is known then the maximal number of bytes will
be copied. Moving memory to the storage returned by locatives will cause havoc, 
if the locative refers to containers of non-immediate data, like vectors
or pairs.

@end deffn
@deffn {procedure} number-of-bytes
@lisp
(number-of-bytes BLOCK)
@end lisp
Returns the number of bytes that the object @code{BLOCK} contains.
@code{BLOCK} may be any non-immediate value.

@end deffn
@deffn {procedure} number-of-slots
@lisp
(number-of-slots BLOCK)
@end lisp
Returns the number of slots that the object @code{BLOCK} contains.
@code{BLOCK} may be a vector, record structure, pair or symbol.

@end deffn
@deffn {procedure} record-instance?
@lisp
(record-instance? X)
@end lisp
Returns @code{#t} if @code{X} is an instance of a record type.
See also: @code{make-record-instance}.
@end deffn

@deffn {procedure} record->vector
@lisp
(record->vector BLOCK)
@end lisp
Returns a new vector with the type and the elements of the record @code{BLOCK}.
@end deffn


@node Procedure-call- and variable reference hooks
@subsection Procedure-call- and variable reference hooks


@deffn {procedure} set-invalid-procedure-call-handler!
@lisp
(set-invalid-procedure-call-handler! PROC)
@end lisp
Sets an internal hook that is invoked when a call to an object other than a procedure
is executed at runtime. The procedure @code{PROC} will in that case be called
with two arguments: the object being called and a list of the passed arguments.

@verbatim
;;; Access sequence-elements as in ARC:

(set-invalid-procedure-call-handler!
  (lambda (proc args)
    (cond [(string? proc) (apply string-ref proc args)]
          [(vector? proc) (apply vector-ref proc args)]
          [else (error "call of non-procedure" proc)] ) ) )

("hello" 4)    ==>  #\o
@end verbatim

This facility does not work in code compiled with the ``unsafe'' setting.

@end deffn
@deffn {procedure} unbound-variable-value
@lisp
(unbound-variable-value [X])
@end lisp
Defines the value that is returned for unbound variables. Normally an error
is signalled, use this procedure to override the check and return @code{X}
instead. To set the default behavior (of signalling an error), call
@code{unbound-variable-value} with no arguments.

This facility does not work in code compiled with the ``unsafe'' setting.
@end deffn




@node Magic
@subsection Magic



@deffn {procedure} object-become!
@lisp
(object-become! ALIST)
@end lisp
Changes the identity of the value of the car of each pair in
@code{ALIST} to the value of the cdr. Both values may not be immediate
(i.e. exact integers, characters, booleans or the empty list).

@verbatim
(define x "i used to be a string")
(define y '#(and now i am a vector))
(object-become! (list (cons x y)))
x                                    ==> #(and now i am a vector)
y                                    ==> #(and now i am a vector)
(eq? x y)                            ==> #t
@end verbatim

Note: this operation invokes a major garbage collection.

The effect of using @code{object-become!} on evicted data (see @code{object-evict})
is undefined.
@end deffn




@node Unit tinyclos
@section Unit tinyclos

This unit is a port of Gregor Kiczales @b{TinyCLOS} with numerous
modifications.

This unit uses the @code{extras} unit.


@menu
* Defining forms::              
* Base language::               
* Introspection::               
* Intercessory protocol::       
* Additional protocol::         
* Utility procedures::          
* Builtin classes::             
@end menu

@node Defining forms
@subsection Defining forms




@deffn {syntax} define-class
@lisp
(define-class NAME (SUPERCLASS1 ...) (SLOTNAME1 ...) [METACLASS])
@end lisp
Sets the variable @code{NAME} to a new class (a new instance of
the class @code{<class>}). @code{SUPERCLASS1 ...} is a list of
superclasses of the newly created class. If no superclasses are given,
then @code{<object>} is assumed.  @code{SLOTNAME1 ...} are the names
of the direct slots of the class. if @code{METACLASS} is provided,
then the new class-instance is an instance of @code{METACLASS} instead
of @code{<class>}.

@verbatim
(define-class NAME (SUPER) (SLOT1 SLOT2) META)
@end verbatim 

is equivalent to

@verbatim
(define NAME
  (make META 
    'name 'NAME
    'direct-supers (list SUPER)
    'direct-slots (list 'SLOT1 'SLOT2)) )
@end verbatim

Note that slots-names are not required to be symbols, so the following
is perfectly valid:

@ifhtml
@html
<pre>
(define hidden-slot (list 'hidden))
(define &lt;myclass&gt;
  (make &lt;class&gt;
     'direct-supers (list &lt;object&gt;)
     'direct-slots (list hidden-slot) ) )
(define x1 (make &lt;myclass&gt;)
(slot-set! x1 hidden-slot 99)
@end html
@end ifhtml

@ifnothtml
@verbatim
(define hidden-slot (list 'hidden))
(define <myclass>
  (make <class>
     'direct-supers (list <object>)
     'direct-slots (list hidden-slot) ) )
(define x1 (make <myclass>)
(slot-set! x1 hidden-slot 99)
@end verbatim
@end ifnothtml

@end deffn
@deffn {syntax} define-generic
@lisp
(define-generic NAME [CLASS])
@end lisp
Sets the variable @code{NAME} to contain a fresh generic function
object without associated methods. If the optional argument @code{CLASS}
is given, then the generic function will be an instance of that class.

@end deffn
@deffn {syntax} define-method
@lisp
(define-method (NAME (VARIABLE1 CLASS1) ... PARAMETERS ...) BODY ...)
@end lisp
Adds a new method with the code @code{BODY ...} to the generic function
that was assigned to the variable @code{name}.  @code{CLASS1 ...} is
a list if classes that specialize this particular method. The method can
have additional parameters @code{PARAMETERS}, which do not specialize
the method any further.  Extended lambda-lists are allowed (@code{#!optional, #!key}
or @code{#!rest} argument lists), but can not be specialized.
Inside the body of the method the identifier
@code{call-next-method} names a procedure of zero arguments that can
be invoked to call the next applicable method with the same arguments.
If no generic function is defined under this name, then a fresh generic
function object is created and assigned to @code{NAME}.

Note that only @code{define-generic} expands into a valid definition,
so for internal lexically scoped definitions use @code{define-generic}.

Currently methods defined with @code{define-method} should not be
hidden (via @code{(declare (hide ...))}, nor should such files be compiled
in @code{block} mode, unless the methods are exported.
@end deffn




@node Base language
@subsection Base language




@deffn {procedure} add-method
@lisp
(add-method GENERIC METHOD)
@end lisp
Adds the method object @code{METHOD} to the list of applicable methods
for the generic function @code{GENERIC}.

@end deffn
@deffn {procedure} instance?
@lisp
(instance? X)
@end lisp
Returns @code{#t} if @code{X} is an instance of a non-primitive
class.

@end deffn
@deffn {procedure} make
@lisp
(make CLASS INITARG ...)
@end lisp
Creates a new instance of @code{CLASS} and passes @code{INITARG ...}
to the @code{initialize} method of this class.

@end deffn
@deffn {procedure} make-class
@lisp
(make-class SUPERCLASSES SLOTNAMES)
@end lisp
Creates a new class object, where @code{SUPERCLASSES} should be the
list of direct superclass objects and @code{SLOTNAMES} should be a
list of symbols naming the slots of this class.

@end deffn
@deffn {procedure} make-generic
@lisp
(make-generic [NAME])
@end lisp
Creates a new generic function object. If @code{NAME} is specified,
then it should be a string.

@end deffn
@deffn {procedure} make-method
@lisp
(make-method SPECIALIZERS PROC)
@end lisp
Creates a new method object specialized to the list of classes in
@code{SPECIALIZERS}.

@verbatim
(define-method (foo (x <bar>)) 123)
   <=> (add-method foo
                   (make-method
                      (list <bar>)
                      (lambda (call-next-method x) 123)))
@end verbatim

@end deffn
@deffn {procedure} slot-ref
@lisp
(slot-ref INSTANCE SLOTNAME)
@end lisp
Returns the value of the slot @code{SLOTNAME} of the object
@code{INSTANCE}.

@end deffn
@deffn {procedure} slot-set!
@lisp
(slot-set! INSTANCE SLOTNAME VALUE)
(set! (slot-ref INSTANCE SLOTNAME) VALUE)
@end lisp
Sets the value of the slot @code{SLOTNAME} of the object
@code{INSTANCE} to @code{VALUE}.
@end deffn




@node Introspection
@subsection Introspection




@deffn {procedure} class-cpl
@lisp
(class-cpl CLASS)
@end lisp
Returns the class-precedence-list of @code{CLASS} as a list of classes.

@end deffn
@deffn {procedure} class-direct-slots
@lisp
(class-direct-slots CLASS)
@end lisp
Returns the list of direct slots of @code{CLASS} as a list of lists,
where each sublist contains the name of the slot.

@end deffn
@deffn {procedure} class-direct-supers
@lisp
(class-direct-supers CLASS)
@end lisp
Returns the list of direct superclasses of @code{CLASS}.

@end deffn
@deffn {procedure} class-of
@lisp
(class-of X)
@end lisp
Returns the class that the object @code{X} is an instance of.

@end deffn
@deffn {procedure} class-name
@lisp
(class-name CLASS)
@end lisp
Returns name of @code{CLASS}.

@end deffn
@deffn {procedure} class-slots
@lisp
(class-slots CLASS)
@end lisp
Returns the list of all slots of @code{CLASS} and its superclasses
as a list of lists, where each sublist contains the name of the slot.

@end deffn
@deffn {procedure} generic-methods
@lisp
(generic-methods GENERIC)
@end lisp
Returns the list of all methods associated with the generic function
@code{GENERIC}.

@end deffn
@deffn {procedure} method-specializers
@lisp
(method-specializers METHOD)
@end lisp
Returns the list of classes that specialize @code{METHOD}.

@end deffn
@deffn {procedure} method-procedure
@lisp
(method-procedure METHOD)
@end lisp
Returns the procedure that contains the body of @code{METHOD}.

@end deffn
@deffn {procedure} subclass?
@lisp
(subclass? CLASS1 CLASS2)
@end lisp
Returns @code{#t} is @code{CLASS1} is a subclass of @code{CLASS2},
or @code{#f} otherwise. Note that the following holds:

@verbatim
(subclass? X X) ==> #t
@end verbatim
@end deffn

@deffn {procedure} instance-of?
@lisp
(instance-of? X CLASS)
@end lisp
Returns @code{#t} if @code{X} is an instance of @code{CLASS} (or one of its subclasses).
@end deffn



@node Intercessory protocol
@subsection Intercessory protocol

These definitions allow interfacing to the Meta Object Protocol
of TinyCLOS. For serious use, it is recommended to consult
the source code (@code{tinyclos.scm}).



@deffn {generic} allocate-instance
@lisp
(allocate-instance CLASS)
@end lisp
Allocates storage for an instance of @code{CLASS} and returns the
instance.

@end deffn
@deffn {generic} compute-apply-generic
@lisp
(compute-apply-generic GENERIC)
@end lisp
Returns a procedure that will be called to apply the generic function
methods to the arguments.

@end deffn
@deffn {generic} compute-apply-methods
@lisp
(compute-apply-methods GENERIC)
@end lisp
Returns a procedure of two arguments, a list of applicable methods
and a list of arguments and applies the methods.

@end deffn
@deffn {generic} compute-methods
@lisp
(compute-methods GENERIC)
@end lisp
Returns a procedure of one argument. The procedure is called with the
list of actual arguments passed to the generic function and should
return a list of applicable methods, sorted by precedence.

@end deffn
@deffn {generic} compute-cpl
@lisp
(compute-cpl CLASS)
@end lisp
Computes and returns the class-precedence-list of @code{CLASS}.

@end deffn
@deffn {generic} compute-getter-and-setter
@lisp
(compute-getter-and-setter CLASS SLOT ALLOCATOR)
@end lisp
Returns two values, the procedures that get and set the contents of the
slot @code{SLOT}.  @code{ALLOCATOR} is a procedure of one argument that
gets an initalizer function and returns the getter and setter procedures
for the allocated slot.

@end deffn
@deffn {generic} compute-method-more-specific?
@lisp
(compute-method-more-specific? GENERIC)
@end lisp
Returns a procedure of three arguments (two methods and a list of
arguments) that returns @code{#t} if the first method is more specific
than the second one with respect to the list of arguments. Otherwise
the returned predicate returns @code{#f}.

@end deffn
@deffn {generic} compute-slots
@lisp
(compute-slots CLASS)
@end lisp
Computes and returns the list of slots of @code{CLASS}.

@end deffn
@deffn {generic} initialize
@lisp
(initialize INSTANCE INITARGS)
@end lisp
Initializes the object @code{INSTANCE}. @code{INITARGS} is the list of
initialization arguments that were passed to the @code{make} procedure.
@end deffn




@node Additional protocol
@subsection Additional protocol




@deffn {generic} describe-object
@lisp
(describe-object INSTANCE [PORT])
@end lisp
Writes a description of @code{INSTANCE} to @code{PORT}.  Execution of
the interpreter command @code{,d} will invoke this generic function.
If @code{PORT} is not given it defaults to the value of @code{(current-output-port)}.

@end deffn
@deffn {generic} print-object
@lisp
(print-object INSTANCE [PORT])
@end lisp
Writes a textual representation of @code{INSTANCE} to @code{PORT}.
Any output of an instance with @code{display, write} and @code{print}
will invoke this generic function.
If @code{PORT} is not given it defaults to the value of @code{(current-output-port)}.
@end deffn




@node Utility procedures
@subsection Utility procedures




@deffn {procedure} initialize-slots
@lisp
(initialize-slots INSTANCE INITARGS)
@end lisp
This procedure takes a sequence of alternating slot-names and
initialization values in @code{INITARGS} and initializes the
corresponding slots in @code{INSTANCE}.

@verbatim
(define-class <pos> () (x y))

(define-method (initialize (pos <pos>) initargs)
  (call-next-method)
  (initialize-slots pos initargs))

(define p1 (make <pos> 'x 1 'y 2))
(define p2 (make <pos> 'x 3 'y 5))
@end verbatim
@end deffn




@node Builtin classes
@subsection Builtin classes


The class hierarchy of builtin classes looks like this:

@ifhtml
@html
<pre>
&lt;top&gt;
  &lt;object&gt;
    &lt;class&gt;
      &lt;procedure-class&gt;
        &lt;procedure&gt;
        &lt;entity-class&gt;
          &lt;generic&gt;
      &lt;primitive-class&gt;
    &lt;c++-object&gt;
  &lt;primitive&gt;
    &lt;void&gt;
    &lt;boolean&gt;
    &lt;symbol&gt;
    &lt;char&gt;
    &lt;vector&gt;
    &lt;pair&gt;
    &lt;number&gt;
      &lt;integer&gt;
        &lt;exact&gt;
      &lt;inexact&gt;
    &lt;string&gt;
    &lt;port&gt;
      &lt;input-port&gt;
      &lt;output-port&gt;
    &lt;pointer&gt;
      &lt;tagged-pointer&gt;
      &lt;swig-pointer&gt;
    &lt;locative&gt;
    &lt;byte-vector&gt;
      &lt;u8vector&gt;
      &lt;s8vector&gt;
      &lt;u16vector&gt;
      &lt;s16vector&gt;
      &lt;u32vector&gt;
      &lt;s32vector&gt;
      &lt;f32vector&gt;
      &lt;f64vector&gt;
    &lt;structure&gt;
      &lt;char-set&gt;
      &lt;condition&gt;
      &lt;condition-variable&gt;
      &lt;environment&gt;
      &lt;hash-table&gt;
      &lt;lock&gt;
      &lt;mmap&gt;
      &lt;mutex&gt;
      &lt;promise&gt;
      &lt;queue&gt;
      &lt;read-table&gt;
      &lt;regexp&gt;
      &lt;tcp-listener&gt;
      &lt;thread&gt;
      &lt;time&gt;
    &lt;end-of-file&gt;
</pre>
@end html
@end ifhtml

@ifnothtml
@verbatim
<top>
  <object>
    <class>
      <procedure-class>
        <procedure>
        <entity-class>
          <generic>
      <primitive-class>
    <c++-object>
  <primitive>
    <void>
    <boolean>
    <symbol>
    <char>
    <vector>
    <pair>
    <number>
      <integer>
        <exact>
      <inexact>
    <string>
    <port>
      <input-port>
      <output-port>
    <pointer>
      <tagged-pointer>
      <swig-pointer>
    <locative>
    <byte-vector>
      <u8vector>
      <s8vector>
      <u16vector>
      <s16vector>
      <u32vector>
      <s32vector>
      <f32vector>
      <f64vector>
    <structure>
      <char-set>
      <condition>
      <condition-variable>
      <environment>
      <hash-table>
      <lock>
      <mmap>
      <mutex>
      <promise>
      <queue>
      <read-table>
      <regexp>
      <tcp-listener>
      <thread>
      <time>
    <end-of-file>
@end verbatim
@end ifnothtml


@defvr {class} <primitive>           @pointrightarrow{} <top>
The parent class of the classes of all primitive Scheme objects.
@end defvr

@defvr {class} <boolean>             @pointrightarrow{} <primitive>
@defvrx {class} <symbol>              @pointrightarrow{} <primitive>
@defvrx {class} <char>                @pointrightarrow{} <primitive>
@defvrx {class} <vector>              @pointrightarrow{} <primitive>
@defvrx {class} <null>                @pointrightarrow{} <primitive>
@defvrx {class} <pair>                @pointrightarrow{} <primitive>
@defvrx {class} <number>              @pointrightarrow{} <primitive>
@defvrx {class} <integer>             @pointrightarrow{} <primitive>
@defvrx {class} <exact>               @pointrightarrow{} <integer>
@defvrx {class} <inexact>             @pointrightarrow{} <number>
@defvrx {class} <string>              @pointrightarrow{} <primitive>
@defvrx {class} <port>                @pointrightarrow{} <primitive>
@defvrx {class} <environment>         @pointrightarrow{} <structure>
@defvrx {class} <end-of-file>         @pointrightarrow{} <primitive>
@defvrx {class} <input-port>          @pointrightarrow{} <port>
@defvrx {class} <output-port>         @pointrightarrow{} <port>
@defvrx {class} <procedure>           @pointrightarrow{} <procedure-class>
The classes of primitive Scheme objects.
@end defvr

@defvr {class} <byte-vector>          @pointrightarrow{} <primitive>
@defvrx {class} <structure>           @pointrightarrow{} <primitive>
@defvrx {class} <hash-table>          @pointrightarrow{} <structure>
@defvrx {class} <queue>               @pointrightarrow{} <structure>
The classes of extended data types provided by the various library units.
@end defvr

@defvr {class} <class>               @pointrightarrow{} <object>
The parent class of all class objects.
@end defvr

@defvr {class} <entity-class>        @pointrightarrow{} <class>
The parent class of objects that can be invoked as a procedure and have slots.
@end defvr

@defvr {class} <generic>             @pointrightarrow{} <entity-class>
The parent class of generic function objects.
@end defvr

@defvr {class} <method>              @pointrightarrow{} <class>
The parent class of method objects.
@end defvr

@defvr {class} <object>              @pointrightarrow{} <class>
The parent class of all objects.
@end defvr

@defvr {class} <procedure-class>     @pointrightarrow{} <class>
The parent class of objects that can be invoked as a procedure.
@end defvr

@defvr {class} <condition>           @pointrightarrow{} <structure>
Class of condition objects.
@end defvr

@defvr {class} <array>               @pointrightarrow{} <structure>
@defvrx {class} <char-set>            @pointrightarrow{} <structure>
@defvrx {class} <time>                @pointrightarrow{} <structure>
@defvrx {class} <u8vector>            @pointrightarrow{} <byte-vector>
@defvrx {class} <s8vector>            @pointrightarrow{} <byte-vector>
@defvrx {class} <u16vector>           @pointrightarrow{} <byte-vector>
@defvrx {class} <s16vector>           @pointrightarrow{} <byte-vector>
@defvrx {class} <u32vector>           @pointrightarrow{} <byte-vector>
@defvrx {class} <s32vector>           @pointrightarrow{} <byte-vector>
@defvrx {class} <f32vector>           @pointrightarrow{} <byte-vector>
@defvrx {class} <f64vector>           @pointrightarrow{} <byte-vector>
The classes of data objects provided by the various supported SRFIs.
@end defvr

@defvr {class} <lock>                @pointrightarrow{} <structure>
@defvrx {class} <mmap>                @pointrightarrow{} <structure>
Classes of objects used in the @code{posix} library unit.
@end defvr

@defvr {class} <pointer>             @pointrightarrow{} <primitive>
@defvrx {class} <tagged-pointer>      @pointrightarrow{} <pointer>
@defvrx {class} <swig-pointer>      @pointrightarrow{} <pointer>
A machine pointer (untagged, tagged or pointing to SWIG-wrapped data).
@end defvr

@defvr {class} <locative>            @pointrightarrow{} <primitive>
A locative.
@end defvr

@defvr {class} <promise>             @pointrightarrow{} <structure>
The class of objects returned by @code{delay}.
@end defvr

@defvr {class} <tcp-listener>        @pointrightarrow{} <structure>
The class of an object returned by @code{tcp-listen}.
@end defvr

@defvr {class} <regexp>        @pointrightarrow{} <structure>
The class of an object returned by @code{regexp}.
@end defvr

@defvr {class} <c++-class>           @pointrightarrow{} <object>
The class of generated wrappers for C++ classes parsed by the ``easy''
Foreign Function interface.
@end defvr



The CHICKEN distribution provides several examples in the file
@code{tests/tinyclos-examples.scm}.


@node Interface to external functions and variables
@chapter Interface to external functions and variables

@menu
* Accessing external objects::  
* Foreign type specifiers::     
* Embedding::                
* Callbacks::                   
* Locations::                   
* Other support procedures::    
* The Easy Foreign Function Interface::  
* C interface::                 
@end menu

@node Accessing external objects
@section Accessing external objects



@deffn {syntax} foreign-code
@lisp
(foreign-code STRING)
@end lisp
Executes the embedded C/C++ code @code{STRING}, which should
be a sequence of C statements, which are executed and return an unspecified result.

@verbatim
(foreign-code "doSomeInitStuff();")     =>  #<unspecified>
@end verbatim

Code wrapped inside @code{foreign-code} may not invoke callbacks into Scheme.

@end deffn
@deffn {syntax} foreign-value
@lisp
(foreign-value STRING TYPE)
@end lisp
Evaluates the embedded C/C++ expression @code{STRING}, returning a value of type given
in the foreign-type specifier @code{TYPE}.

@verbatim
(print (foreign-value "my_version_string" c-string))
@end verbatim

@end deffn
@deffn {syntax} foreign-declare
@lisp
(foreign-declare STRING ...)
@end lisp
Include given strings verbatim into header of generated file.
@end deffn

@deffn {syntax} foreign-parse
@lisp
(foreign-parse STRING ...)
@end lisp
Parse given strings and generate foreign-interface bindings. See @ref{The Easy Foreign Function Interface}
for more information.
@end deffn

@deffn {syntax} foreign-parse/declare
@lisp
(foreign-parse/declare STRING ...)
@end lisp
Parse and include strings into the generated code.
@end deffn

@deffn {syntax} define-foreign-type
@lisp
(define-foreign-type NAME TYPE [ARGCONVERT [RETCONVERT]])
@end lisp
Defines an alias for @code{TYPE} with the name @code{NAME} (a symbol). 
@code{TYPE} may be a type-specifier
or a string naming a C type. The namespace of foreign type specifiers
is separate from the normal Scheme namespace.  The optional arguments
@code{ARGCONVERT} and @code{RETCONVERT} should evaluate to procedures
that map argument- and result-values to a value that can be transformed
to @code{TYPE}:

@verbatim
(define-foreign-type char-vector 
  nonnull-c-string
  (compose list->string vector->list)
  (compose list->vector string->list) )

(define strlen
  (foreign-lambda int "strlen" char-vector) )

(strlen '#(#\a #\b #\c))                      ==> 3

(define memset
  (foreign-lambda char-vector "memset" char-vector char int) )

(memset '#(#_ #_ #_) #\X 3)                ==> #(#\X #\X #\X)
@end verbatim                 

Foreign type-definitions are only visible in the compilation-unit in which
they are defined, so use @code{include} to use the same definitions
in multiple files.

@end deffn
@deffn {syntax} define-foreign-variable
@lisp
(define-foreign-variable NAME TYPE [STRING])
@end lisp
Defines a foreign variable of name @code{NAME} (a symbol). @code{STRING}
should be the real name of a foreign variable or parameterless macro. If
@code{STRING} is not given, then the variable name @code{NAME} will
be converted to a string and used instead. All references and assignments
(via @code{set!}) are modified to correctly convert values between
Scheme and C representation. This foreign variable can only be accessed
in the current compilation unit, but the name can be lexically shadowed.
Note that @code{STRING} can name an arbitrary C expression. If no
assignments are performed, then @code{STRING} doesn't even have to
specify an lvalue.

@verbatim
#>
enum { abc=3, def, ghi };
<#

(define-macro (define-simple-foreign-enum . items)
  `(begin
     ,@(map (match-lambda 
              [(name realname) `(define-foreign-variable ,name int ,realname)]
              [name `(define-foreign-variable ,name int)] )
     items) ) )

(define-simple-foreign-enum abc def ghi)

ghi                               ==> 5
@end verbatim

@end deffn
@deffn {syntax} define-foreign-record
@lisp
(define-foreign-record NAME [DECL ...] SLOT ...)
@end lisp
Defines accessor procedures for a C structure definition. @code{NAME} should either be a symbol
or a list of the form @code{(TYPENAME FOREIGNNAME)}. If @code{NAME} is a symbol, then a C declaration
will be generated that defines a C struct named @code{struct NAME}. If @code{NAME} is a list, then
no struct declaration will be generated. 
A foreign-type specifier named @code{NAME} (or @code{TYPENAME}) will be defined as a pointer to
the given C structure.
A @code{SLOT} definition should be a list of one of the following forms:

@verbatim
(TYPE SLOTNAME)
@end verbatim

or

@verbatim
(TYPE SLOTNAME SIZE)
@end verbatim

The latter form defines an array of SIZE elements of the type TYPE embedded in the
structure.
For every slot, the following accessor procedures will be generated:


@deffn {procedure} TYPENAME-SLOTNAME
@lisp
(TYPENAME-SLOTNAME FOREIGN-RECORD-POINTER [INDEX])
@end lisp
A procedure of one argument (a pointer to a C structure), that returns
the slot value of the slot @code{SLOTNAME}. If a @code{SIZE} has been given in the slot definition, then
an additional argument @code{INDEX} is required that specifies the index of an array-element.
@end deffn

@deffn {procedure} TYPENAME-SLOTNAME-set!
@lisp
(TYPENAME-SLOTNAME-set! FOREIGN-RECORD-POINTER [INXDEX] VALUE)
@end lisp
A procedure of two arguments (a pointer to a C structure) and a value, that
sets the slot value of the slot @code{SLOTNAME} in the structure. If a @code{SIZE} has been given in
the slot definition, then an additional argument @code{INDEX} is required for the array index.
@end deffn

If a slot type is of the form @code{(const ...)}, then no setter procedure will be generated.
Slots of the types @code{(struct ...)} or @code{(union ...)} are accessed as pointers to the embedded
struct (or union) and no setter will be generated. 

Additionally, special record-declarations (@code{DECL ...}) may be given, where each declaration consists
of a list of the form @code{(KEYWORD ARGUMENT ...)}. The available declarations are:

@deffn {record declaration} constructor:
@lisp
(constructor: NAME)
@end lisp
Generate a constructor-procedure with no arguments that has the name @code{NAME} (a symbol) that returns a pointer to a structure of this
type. The storage will be allocated with @code{malloc(3)}.
@end deffn

@deffn {record declaration} destructor:
@lisp
(destructor: NAME)
@end lisp
Generate a destructor function with the name @code{NAME} that takes a pointer to a structure of this
type as its single argument and releases the storage with @code{free(3)}. If the argument is @code{#f},
the destructor procedure does nothing.
@end deffn

@deffn {record declaration} rename:
@lisp
(rename: EXPRESSION)
@end lisp
Evaluates @code{EXPRESSION} at compile-/macro-expansion-time and applies the result, which should be
a procedure, to the string-representation of the name of each accessor-procedure generated. Another (or the same)
string should be returned, which in turn is taken as the actual name of the accessor.
@end deffn

An example:

@lisp
(require-for-syntax 'srfi-13)

(define-foreign-record Some_Struct
  (rename: (compose string-downcase (cut string-translate <> "_" "-")))
  (constructor: make-some-struct)
  (destructor: free-some-struct)
  (int xCoord)
  (int yCoord) )
@end lisp

will generate the following procedures:

@verbatim
(make-some-struct)              --> C-POINTER
(free-some-struct C-POINTER)

(some-struct-xcoord C-POINTER)  --> NUMBER
(some-struct-ycoord C-POINTER)  --> NUMBER

(some-struct-xcoord-set! C-POINTER NUMBER)
(some-struct-ycoord-set! C-POINTER NUMBER)
@end verbatim

@end deffn

@deffn {syntax} define-foreign-enum
@lisp
(define-foreign-enum TYPENAME ITEM ...)
@end lisp
Defines a foreign type (as with @code{define-foreign-type}) that maps
the elements of a C/C++ enum (or a enum-like list of constants) to and
from a set of symbols. @code{TYPENAME} names a foreign type that
converts a symbol argument from the set @code{ITEM ...} into the
appropriate enum value when passed as an argument to a foreign
function.
A list of symbols passed as an argument will be combined using
@code{bitwise-ior}. An empty list will be passed as 0 (zero).
Results of the enum type are automatically converted into a symbol
(note that combinations are not supported in this case).
@code{TYPENAME} may alternatively be a list of the form
@code{(SCHEMENAME REALTYPE)} - in this case @code{REALTYPE} designates
the native type used. The default native type is @code{"TYPENAME"}.
Additionally two procedures are generated named @code{SCHEMENAME->number}
and @code{number->SCHEMENAME} which take one argument and convert a 
symbol (or a list of symbols) into its numeric value and vice versa.

Here a heavily contrived example:

@verbatim
#>
enum foo { a_foo = 4, b_foo, c_foo };
enum foo bar(enum foo x) { printf("%d\n", x); return b_foo; }
<#

(define-foreign-enum (foo (enum "foo")) a_foo b_foo (c c_foo))

(define bar (foreign-lambda foo bar foo))

(pp (bar '()))
(pp (bar 'a_foo))
(pp (bar '(b_foo c)))
@end verbatim
@end deffn

@deffn {syntax} foreign-lambda
@lisp
(foreign-lambda RETURNTYPE NAME ARGTYPE ...)
@end lisp
Represents a
binding to an external routine. This form can be used in the position
of an ordinary @code{lambda} expression. @code{NAME} specifies the
name of the external procedure and should be a string or a symbol.

@end deffn
@deffn {syntax} foreign-lambda*
@lisp
(foreign-lambda* RETURNTYPE ((ARGTYPE VARIABLE) ...) STRING ...)
@end lisp
Similar to @code{foreign-lambda}, but instead of generating code to
call an external function, the body of the C procedure is directly given
in @code{STRING ...}:

@verbatim
(define my-strlen
  (foreign-lambda* int ((c-string str))
    "int n = 0;
     while(*(str++)) ++n;
     C_return(n);") )

(my-strlen "one two three")             ==> 13
@end verbatim

For obscure technical reasons you should use the @code{C_return} macro instead of the normal @code{return} statement
to return a result from the foreign lambda body as some cleanup code has to be run before execution
commences in the calling code.
@end deffn

@deffn {syntax} foreign-safe-lambda
@lisp
(foreign-safe-lambda RETURNTYPE NAME ARGTYPE ...)
@end lisp
This is similar to @code{foreign-lambda}, but also allows the called
function to call Scheme functions and allocate Scheme data-objects. See @ref{Callbacks}.

@end deffn
@deffn {syntax} foreign-safe-lambda*
@lisp
(foreign-safe-lambda* RETURNTYPE ((ARGTYPE VARIABLE)...) STRING ...)
@end lisp
This is similar to @code{foreign-lambda*}, but also allows the called
function to call Scheme functions and allocate Scheme data-objects. See @ref{Callbacks}.

@end deffn

@deffn {syntax} foreign-primitive
@lisp
(foreign-primitive [RETURNTYPE] ((ARGTYPE VARIABLE) ...) STRING ...)
@end lisp
This is also similar to @code{foreign-lambda*} but the code will be executed
in a ``primitive'' CPS context, which means it will not actually return, but
call it's continuation on exit. This means that code inside this form may
allocate Scheme data on the C stack (the ``nursery'') with @code{C_alloc}
(see below). If the @code{RETURNTYPE} is omitted it defaults to @code{void}.
You can return multiple values inside the body of the @code{foreign-primitive}
form by calling this C function:

@verbatim
C_values(N + 2, C_SCHEME_UNDEFINED, C_k, X1, ...)
@end verbatim

where @code{N} is the number of values to be returned, and @code{X1, ...} are the
results, which should be Scheme data objects. When returning multiple values, the
return-type should be omitted.
@end deffn

@deffn {syntax} $
@lisp
($ [RETURNTYPE] NAME (TYPE ARGUMENT) ...)
@end lisp
Invokes a C/C++ function by evaluating the
arguments, performing the neccessary type-conversions for the foreign type-specifiers
and calling @code{NAME} (which must be a symbol). If a return-type is given, then
the result will be converted properly and returned. Callbacks into Scheme are not
allowed inside the invoked foreign code. The type/argument lists may also be literal
Scheme data or expressions of the form @code{(quote LITERAL)} or @code{(location ...)} - in this case the
arguments are converted according to the type of the literal or are treated as a c-pointer, respectively. 
Booleans, characters,
numbers, strings, SRFI-4 number vectors and symbols are converted, all other data is passed as being of
type @code{scheme-object}.

@verbatim
($ printf "%d times Hello, %s!\n" 1000 "world")

(define f 99.2)

(let-location ((double n))
  (let ((f ($ double modf (double f) (location n))))
    (cons n f) ) )
@end verbatim

If no return type is given, @code{void} is assumed. This macro expands into one
of the @code{foreign-lambda*}, @code{foreign-code} or @code{foreign-value} forms.
@end deffn


@node Foreign type specifiers
@section Foreign type specifiers

Here is a list of valid foreign type specifiers:

@table @code

@item scheme-object

An arbitrary Scheme data object (immediate or non-immediate). 

@item bool

As argument: any value (@code{#f} is false, anything else is true).
As result: anything different from 0 and the @code{NULL}-pointer
is @code{#t}.

@item byte unsigned-byte

A byte.

@item char unsigned-char

A character.

@item short unsigned-short

A short integer number.

@item int unsigned-int
@item int32 unsigned-int32

An small integer number in fixnum range (at least 30 bit).

@item integer unsigned-integer
@item integer32 unsigned-integer32
@item integer64

Either a fixnum or a flonum in the range of a (unsigned) machine ``int''
or with 32/64 bit width.

@item long unsigned-long

Either a fixnum or a flonum in the range of a (unsigned) machine ``long''
or with 32 bit width.

@item float double

A floating-point number. If an exact integer is passed as an argument,
then it is automatically converted to a float.

@item number

A floating-point number. Similar to @code{double}, but when used as a result
type, then either an exact integer or a floating-point number is returned, depending
on whether the result fits into an exact integer or not.

@item symbol

A symbol, which will be passed to foreign code as a zero-terminated string.
When declared as the result of foreign code, the result should be a string and
a symbol with the same name will be interned in the symbol table (and returned
to the caller).

@item scheme-pointer

An untyped pointer to the contents of a non-immediate Scheme object
(not allowed as return type).  The value @code{#f} is also allowed
and is passed as a @code{NULL} pointer. 
Don't confuse this type with @code{(pointer ...)} which means something
different (a machine-pointer object).

@item nonnull-scheme-pointer

As @code{pointer}, but guaranteed not to be @code{#f}.
Don't confuse this type with @code{(nonnull-pointer ...)} which means something
different (a machine-pointer object).

@item c-pointer

An untyped operating-system pointer or a locative.  The value @code{#f} is also
allowed and is passed as a @code{NULL} pointer.  If uses as the type of
a return value, a @code{NULL} pointer will be returned as @code{#f}.

@item nonnull-c-pointer

As @code{c-pointer}, but guaranteed not to be @code{#f/NULL}.

@item scheme-or-c-pointer

An untyped pointer. If the argument is a machine-pointer object, the wrapped C pointer
will be passed. If it is any other object, then this type is treated as @code{scheme-pointer}.

Not allowed as a result type.

@item [nonnull-] byte-vector
A byte-vector object, passed as a pointer to its contents. Arguments
of type @code{byte-vector} may optionally be @code{#f}, which is
passed as a NULL pointer.  This is not allowed as a return type.
@c @end deffn

@item  [nonnull-] u8vector
@itemx [nonnull-] u16vector
@itemx [nonnull-] u32vector
@itemx [nonnull-] s8vector
@itemx [nonnull-] s16vector
@itemx [nonnull-] s32vector
@itemx [nonnull-] f32vector
@itemx [nonnull-] f64vector
A SRFI-4 number-vector object, passed as a pointer to its
contents. Arguments of type @code{byte-vector} may optionally be
@code{#f}, which is passed as a NULL pointer.  These are not allowed
as return types.

@item c-string

A C string (zero-terminated). The value @code{#f}
is also allowed and is passed as a @code{NULL} pointer. If uses as
the type of a return value, a @code{NULL} pointer will be returned as
@code{#f}. Note that the string is copied (with a zero-byte appended)
when passed as an argument to a foreign function. Also a return value
of this type is copied into garbage collected memory.

@item nonnull-c-string

As @code{c-string}, but guaranteed not to be @code{#f/NULL}.

@item [nonnull-] c-string*
Similar to @code{[nonnull-]c-string}, but if used as a result-type,
the pointer returned by the foreign code will be freed (using the
C-libraries @code{free()})
after copying. This type specifier is not valid as a result type
for callbacks defined with @code{define-external}.

@item void

Specifies an undefined return value. Not allowed as argument type.

@item (const TYPE)

The foreign type @code{TYPE} with an additional @code{const} specifier.

@item (enum NAME)

An enumeration type. Handled internally as an @code{integer}.

@item (pointer TYPE)

@item (c-pointer TYPE)

An operating-system pointer or a locative to an object of @code{TYPE}.

@item (nonnull-pointer TYPE)

@item (nonnull-c-pointer TYPE)

As @code{(pointer TYPE)}, but guaranteed not to be @code{#f/NULL}.

@item (ref TYPE)

A C++ reference type. Reference types are handled the same way as pointers
inside Scheme code.

@item (struct NAME)

A struct of the name @code{NAME}, which should be a string. Structs
can not be directly passed as arguments to foreign function, neither
can they be result values. Pointers to structs are allowed, though.

@item (template TYPE ARGTYPE ...)

A C++ template type. For example @code{vector<int>} would be specified
as @code{(template "vector" int)}. Template types can not be directly passed
as arguments or returned as results.

@item (union NAME)

A union of the name @code{NAME}, which should be a string. Unions can
not be directly passed as arguments to foreign function, neither can
they be result values. Pointers to unions are allowed, though.

@item (instance CNAME SCHEMECLASS)

A pointer to a C++ class instance. @code{CNAME} should designate
the name of the C++ class, and @code{SCHEMECLASS} should be the class
that wraps the instance pointer. Normally @code{SCHEMECLASS}
should be a subclass of @code{<c++-object>}.

@item (instance-ref CNAME SCHEMECLASS)

A reference to a C++ class instance. 

@item (function RESULTTYPE (ARGUMENTTYPE1 ... [...]) [CALLCONV])
A function pointer. @code{CALLCONV} specifies an optional calling
convention and should be a string. The meaning of this string is entirely
platform dependent.  The value @code{#f} is also allowed and is passed
as a @code{NULL} pointer.

@end table

Foreign types are mapped to C types in the following manner:

@c % XXX figure out  if this is the right way to do this...

@table @code
@item bool
int
@item [unsigned-]char
[unsigned] char
@item [unsigned-]short
[unsigned] short
@item [unsigned-]int
[unsigned] int
@item [unsigned-]integer
[unsigned] int
@item [unsigned-]long
[unsigned] long
@item float
float
@item double
double
@item number
double
@item [nonnull-]pointer
void *
@item [nonnull-]c-pointer
void *
@item [nonnull-]byte-vector
unsigned char *
@item [nonnull-]u8vector
unsigned char *
@item [nonnull-]s8vector
char *
@item [nonnull-]u16vector
unsigned short *
@item [nonnull-]s16vector
short *
@item [nonnull-]u32vector
uint32_t *
@item [nonnull-]s32vector
int32_t *
@item [nonnull-]f32vector
float *
@item [nonnull-]f64vector
double *
@item [nonnull-]c-string
char *
@item symbol
char *
@item void
void
@item ([nonnull-]pointer TYPE)
TYPE *
@item (enum NAME)
enum NAME
@item (struct NAME)
struct NAME
@item (ref TYPE)
TYPE &
@item (template T1 T2 ...)
T1<T2, ...>
@item (union NAME)
union NAME
@item (function RTYPE (ATYPE ...) [CALLCONV])
[CALLCONV] RTYPE (*)(ATYPE, ...)
@item (instance CNAME SNAME)
CNAME *
@item (instance-ref CNAME SNAME)
CNAME &
@end table


@node Embedding
@section Embedding

Compiled Scheme files can be linked with C code, provided the Scheme code was compiled
in ``embedded'' mode by passing @code{-DC_EMBEDDED} to the C compiler (this will
disable generation of a @code{main()} function). @code{csc} will do this, when given
the @code{-embedded} option. Alternatively pass @code{-embedded} to @code{csc}.

The following C API is available:

@deftypefn {C function} void CHICKEN_parse_command_line (int argc, char *argv[], int *heap, int *stack int *symbols)
Parse the programs command-line contained in @code{argc} and
@code{argv} and return the heap-, stack- and symbol table limits
given by runtime options of the form @code{-:...}, or choose default
limits. The library procedure @code{argv} can access the command-line
only if this function has been called by the containing application.
@end deftypefn

@deftypefn {C function} int CHICKEN_initialize (int heap, int stack, int symbols, void *toplevel)
Initializes the Scheme execution context and memory. @code{heap}
holds the number of bytes that are to be allocated for the secondary
heap. @code{stack} holds the number of bytes for the primary
heap. @code{symbols} contains the size of the symbol table. Passing
@code{0} to one or more of these parameters will select a default
size. 
@code{toplevel} should be a pointer to the toplevel entry point
procedure. You should pass @code{C_toplevel} here. In any subsequent
call to @code{CHICKEN_run} you can simply
pass @code{NULL}.
Calling this function more than once has no effect. If enough
memory is available and initialization was successful, then @code{1}
is returned, otherwise this function returns @code{0}.
@end deftypefn

@deftypefn {C function} C_word CHICKEN_run (void *toplevel)
Starts the Scheme program. Call this function once to execute all toplevel expressions in your
compiled Scheme program. If the runtime system was not initialized before,
then @code{CHICKEN_initialize} is called with default sizes.
@code{toplevel} is the toplevel entry-point procedure, you usually pass @code{C_toplevel} here.
The result value is the continuation that can be used to re-invoke the Scheme code from the
point after it called @code{return-to-host} (see below).

If you just need a Scheme interpreter, you can also pass @code{CHICKEN_default_toplevel} as
the toplevel procedure, which just uses the default library units.
@end deftypefn

Once @code{CHICKEN_run} has been called, Scheme code is executing until all toplevel
expressions have been evaluated or until @code{return-to-host} is called inside the
Scheme program.

@deffn {procedure} return-to-host
@lisp
(return-to-host)
@end lisp
Exits the Scheme code and returns to the invoking context that called @code{CHICKEN_run}
or @code{CHICKEN_continue}.
@end deffn

After @code{return-to-host} has been executed and once @code{CHICKEN_run} returns,
you can invoke callbacks which have been defined with @code{define-external}.
The @code{eval} library unit also provides ``boilerplate'' callbacks, that simplify invoking Scheme
code embedded in a C or C++ application a lot.

@deftypefn {C macro} int CHICKEN_eval (C_word exp, C_word *result)
Evaluates the Scheme object passed in @code{exp}, writing the result value to @code{result}.
The return value is 1 if the operation succeeded,
or 0 if an error occurred. Call @code{CHICKEN_get_error_message} to obtain a description
of the error.
@end deftypefn

@deftypefn {C macro} int CHICKEN_eval_string (char *str, C_word *result)
Evaluates the Scheme expression passed in the string @code{str}, writing the result value to @code{result}.
@end deftypefn

@deftypefn {C macro} int CHICKEN_eval_to_string (C_word exp, char *result, int size)
Evaluates the Scheme expression passed in @code{exp}, writing a textual representation
of the result into @code{result}. @code{size} should specify the maximal size of the result string.
@end deftypefn

@deftypefn {C macro} int CHICKEN_eval_string_to_string (char *str, char *result, int size)
Evaluates the Scheme expression passed in the string @code{str}, writing a textual representation
of the result into @code{result}. @code{size} should specify the maximal size of the result string.
@end deftypefn

@deftypefn {C macro} int CHICKEN_apply (C_word func, C_word args, C_word *result)
Applies the procedure passed in @code{func} to the list of arguments @code{args}, writing the result value to @code{result}.
@end deftypefn

@deftypefn {C macro} int CHICKEN_apply_to_string (C_word func, C_word args, char *result, int size)
Applies the procedure passed in @code{func} to the list of arguments @code{args}, writing a textual 
representation of the result into @code{result}.
@end deftypefn

@deftypefn {C macro} int CHICKEN_read (char *str, C_word *result)
Reads a Scheme object from the string @code{str}, writing the result value to @code{result}.
@end deftypefn

@deftypefn {C macro} int CHICKEN_load (char *filename)
Loads the Scheme file @code{filename} (either in source form or compiled).
@end deftypefn

@deftypefn {C macro} void CHICKEN_get_error_message (char *result, int size)
Returns a textual description of the most recent error that occurred in executing embedded Scheme code.
@end deftypefn

@deftypefn {C macro} int CHICKEN_yield (int *status)
If threads have been spawned during earlier invocations of embedded Scheme code, then this function
will run the next scheduled thread for one complete time-slice. This is useful, for example, inside
an ``idle'' handler in a GUI application with background Scheme threads. Note that the 
@code{srfi-18} library unit has to be linked in for this.
@end deftypefn


An example:

@verbatim
% cat x.scm
;;; x.scm

(define (bar x) (gc) (* x x))

(define-external (baz (int i)) double
  (sqrt i) 

% cat y.c
/* y.c */

#include "chicken.h"
#include <assert.h>

extern double baz(int);

int main() {
  char buffer[ 256 ];
  int status;
  C_word val = C_SCHEME_UNDEFINED;
  C_word *data[ 1 ];
  
  data[ 0 ] = &val;

  CHICKEN_run(C_toplevel);

  status = CHICKEN_read("(bar 99)", &val);
  assert(status);

  C_gc_protect(data, 1);

  printf("data: %08x\n", val);

  status = CHICKEN_eval_string_to_string("(bar)", buffer, 255);
  assert(!status);

  CHICKEN_get_error_message(buffer, 255);
  printf("ouch: %s\n", buffer);

  status = CHICKEN_eval_string_to_string("(bar 23)", buffer, 255);
  assert(status);

  printf("-> %s\n", buffer);
  printf("data: %08x\n", val);

  status = CHICKEN_eval_to_string(val, buffer, 255);
  assert(status);
  printf("-> %s\n", buffer);

  printf("->` %g\n", baz(22));

  return 0;
}

% csc x.scm y.c -embedded
@end verbatim

It is also possible to re-enter the computation following the call to @code{return-to-host} by calling
@code{CHICKEN_continue}:

@deftypefn {C function} C_word CHICKEN_continue (C_word k)
Re-enters Scheme execution. @code{k} is the continuation received from the previous invocation
of @code{CHICKEN_run} or @code{CHICKEN_continue}. When @code{return-to-host} is called again,
this function returns another continuation that can be used to restart again.

Note: if you invoke callbacks prior to calling @code{CHICKEN_continue}, make sure that the
continuation is not reclaimed by garbage collection. This can be avoided by using @code{C_gc_protect}
or gc-roots.
@end deftypefn


Another example:

@verbatim
% cat x.scm
(require-extension srfi-18)

(define m (make-mutex))

(define (t)
  (mutex-lock! m)
  (thread-sleep! 1)
  (print (thread-name (current-thread)))
  (mutex-unlock! m)
  (t) )

(thread-start! (make-thread t 'PING!))
(thread-start! (make-thread t 'PONG!))

(let loop ()
  (return-to-host)
  (thread-yield!)
  (loop) )

% cat y.c
#include "chicken.h"

int main()
{
  C_word k = CHICKEN_run(C_toplevel);
  
  for(;;)
    k = CHICKEN_continue(k);

  return 0;
}

% csc x.scm y.c -embedded
@end verbatim


A simpler interface For handling GC-safe references to Scheme data are the so called ``gc-roots'':

@deftypefn {C function} void* CHICKEN_new_gc_root ()
Returns a pointer to a ``GC root'', which is an object that holds a reference to a Scheme value
that will always be valid, even after a garbage collection. The content of the gc root is initialized to
an unspecified value.
@end deftypefn

@deftypefn {C function} void CHICKEN_delete_gc_root (void *root)
Deletes the gc root.
@end deftypefn

@deftypefn {C macro} C_word CHICKEN_gc_root_ref (void *root)
Returns the value stored in the gc root.
@end deftypefn

@deftypefn {C macro} void CHICKEN_gc_root_set (void *root, C_word value)
Sets the content of the GC root to a new value.
@end deftypefn


Sometimes it is handy to access global variables from C code:

@deftypefn {C function} void* CHICKEN_global_lookup (char *name)
Returns a GC root that holds the global variable with the name @code{name}. If no such variable
exists, @code{NULL} is returned.
@end deftypefn

@deftypefn {C function} C_word CHICKEN_global_ref (void *global)
Returns the value of the global variable referenced by the GC root @code{global}.
@end deftypefn

@deftypefn {C function} void CHICKEN_global_set (void *global, C_word value)
Sets the value of the global variable referenced by the GC root @code{global} to @code{value}.
@end deftypefn


@node Callbacks
@section Callbacks 


To enable an external C function to call back to Scheme, the form
@code{foreign-safe-lambda} (or @code{foreign-safe-lambda*})
has to be used. This generates special code to save and restore important
state information during execution of C code. There are two ways of
calling Scheme procedures from C: the first is to invoke the runtime
function @code{C_callback} with the closure to be called and the number
of arguments.  The second is to define an externally visible wrapper
function around a Scheme procedure with the @code{define-external}
form.

Note: the names of all functions, variables and macros exported by the
CHICKEN runtime system start with ``@code{C_}''. It is advisable to
use a different naming scheme for your own code to avoid name clashes.
Callbacks (defined by @code{define-external})
do not capture the lexical environment.

Non-local exits leaving the scope of the invocation of a callback from Scheme into C
will not remove the C call-frame from the stack (and will result in a memory
leak).



@deffn {syntax} define-external
@lisp
(define-external [QUALIFIERS] (NAME (ARGUMENTTYPE1 VARIABLE1) ...) RETURNTYPE BODY ...)
(define-external NAME TYPE [INIT])
@end lisp
The first form defines an externally callable Scheme
procedure. @code{NAME} should be a symbol, which, when converted to a
string, represents a legal C identifier. @code{ARGUMENTTYPE1 ...} and
@code{RETURNTYPE} are foreign type specifiers for the argument variables
@code{VAR1 ...} and the result, respectively.  @code{QUALIFIERS}
is an optional qualifier for the foreign procedure definition, like
@code{__stdcall}.

@verbatim
(define-external (foo (c-string x)) int (string-length x))
@end verbatim

The second form of @code{define-external} can be used to define
variables that are accessible from foreign code. It declares
a global variable named by the symbol @code{NAME} that
has the type @code{TYPE}. @code{INIT} can be an arbitrary
expression that is used to initialize the variable. @code{NAME} is
accessible from Scheme just like any other foreign variable defined by
@code{define-foreign-variable}.  

@verbatim
(define-external foo int 42)
((foreign-lambda* int ()
  "C_return(foo);"))           ==> 42
@end verbatim

@b{Note:} don't be tempted to
assign strings or bytevectors to external variables. Garbage collection
moves those objects around, so it is very bad idea to assign pointers
to heap-data. If you have to do so, then copy the data object into
statically allocated memory (for example by using @code{object-evict}).

Results of type @code{scheme-object} returned by @code{define-external}
are always allocated in the secondary heap, that is, not in the stack.


@end deffn

@deftypefn {C function} C_word C_callback (C_word closure, int argc)
This function can be used to invoke the Scheme procedure @code{closure}.
@code{argc} should contain the number of arguments that are passed to
the procedure on the temporary stack. Values are put onto the temporary
stack with the @code{C_save} macro.
@end deftypefn

@deftypefn {C function} void C_callback_adjust_stack_limits (C_word *ptr)
The runtime-system uses the stack as a special allocation area and
internally holds pointers to estimated limits to distinguish between Scheme
data objects inside the stack from objects outside of it.
If you invoke callbacks at wildly differing stack-levels,
these limits may shift from invocation to invocation. Callbacks defined
with @code{define-external} will perform appropriate adjustments automatically,
but if you invoke @code{C_callback} manually, you should perform a
@code{C_callback_adjust_stack_limits} to make sure the internal limits are
set properly. @code{ptr} should point to some data object on the stack. The
call will make sure the limits are adjusted so that the value pointed to
by @code{ptr} is located in the stack.
@end deftypefn



@node Locations
@section Locations 


It is also possible to define variables containing unboxed C data,
so called @emph{locations}. It should be noted that locations may
only contain simple data, that is: everything that fits into a
machine word, and double-precision floating point values. 



@deffn {syntax} define-location
@lisp
(define-location NAME TYPE [INIT])
@end lisp
Identical to @code{(define-external NAME TYPE [INIT])}, but the variable
is not accessible from outside of the current compilation unit (it is 
declared @code{static}).

@end deffn
@deffn {syntax} let-location
@lisp
(let-location ((NAME TYPE [INIT]) ...) BODY ...)
@end lisp
Defines a lexically bound location.

@end deffn
@deffn {syntax} location
@lisp
(location NAME)
(location X)
@end lisp
This form returns a pointer object
that contains the address of the variable @code{NAME}. 
If the argument to @code{location} is not a location defined by @code{define-location},
@code{define-external} or @code{let-location}, then

@verbatim
(location X)
@end verbatim

is essentially equivalent to 

@verbatim
(make-locative X)
@end verbatim

(See the manual chapter or @code{locatives} for more information about
locatives.

Note that @code{(location X)} may be abbreviated as @code{#$X}.

@verbatim
(define-external foo int)
((foreign-lambda* void (((pointer int) ip)) "*ip = 123;") 
  (location foo))
foo                                                                               ==> 123
@end verbatim

This facility is especially useful in situations, where a C function
returns more than one result value:

@verbatim
#>
#include <math.h>
<#

(define modf
  (foreign-lambda double "modf" double (pointer double)) )

(let-location ([i double])
  (let ([f (modf 1.99 (location i))])
    (print "i=" i ", f=" f) ) )
@end verbatim
@end deffn



@code{location} returns a value of type @code{c-pointer}, when given
the name of a callback-procedure defined with @code{define-external}.

@node Other support procedures
@section Other support procedures


@deffn {procedure} argc+argv
@lisp
(argc+argv)
@end lisp
Returns two values: an integer and a foreign-pointer object representing the @code{argc}
and @code{argv} arguments passed to the current process.
@end deffn



@node The Easy Foreign Function Interface
@section The @emph{Easy} Foreign Function Interface

The compiler contains a builtin parser for a restricted subset of C and C++ that
allows the easy generation of foreign variable declarations, procedure bindings and
C++ class wrappers. The parser is invoked via the declaration-specifier
@code{foreign-parse}, which extracts binding information and generates
the necessary code. An example:

@verbatim
(foreign-declare "
#include <math.h>

#define my_pi 3.14
")

(foreign-parse "extern double sin(double);")

(print (sin 3.14))
@end verbatim

The parser would generate code that is equivalent to

@verbatim
(foreign-declare "
#include <math.h>

#define my_pi 3.14
")

(define-foreign-variable my_pi float "my_pi")
(define sin (foreign-lambda double "sin" double))
@end verbatim

Note that the read syntax @code{#>[SPEC] ... <#}
provides a somewhat simpler way of using the parser. The example above could
alternatively be expressed as

@verbatim
#>!
#define my_pi 3.14

extern double sin(double);
<#

(print (sin 3.14))
@end verbatim

Another example, here using C++. Consider the following class:

@verbatim
// file: foo.h

class Foo {
 private:
  int x_;
 public:
  Foo(int x);
  void setX(int x);
  int getX();
};
@end verbatim

To generate a wrapper class that provides generic functions for the
constructor and the @code{setX} and @code{getX} methods, we
can use the following class definition:

@verbatim
; file: test-foo.scm

(require-extension tinyclos)

#>!
#include "Foo.h"
<#

(define x (make <Foo> 99))
(print (getX x))              ; prints ``99''
(setX x 42)
(print (getX x))              ; prints ``42''
(destroy x)
@end verbatim

Provided the file @code{foo.o} contains the implementation of the class @code{Foo}, the
given example could be compiled like this (assuming a UNIX like environment):

@verbatim
% csc test-foo.scm foo.o -c++
@end verbatim

Here is another example, a minimal ``Hello world'' application for QT. We can
see the three different ways of embedding C/C++ code in Scheme:

@verbatim
; compile like this: 
; csc hello.scm -c++ -C -IQTDIR/include -L "-LQTDIR/lib -lqt"

(require-extension tinyclos)

; Include into generated code, but don't parse:
#>
#include <qapplication.h>
#include <qpushbutton.h>
<#

; Parse but don't embed: we only want wrappers for a few classes:
#>?
class QWidget 
{
public:
  void resize(int, int);
  void show();
};

class QApplication 
{
public:
  QApplication(int, char **);
  ~QApplication();
  void setMainWidget(QWidget *);
  void exec();
};

class QPushButton : public QWidget
{
public:
  QPushButton(char *, QWidget *);
  ~QPushButton();
}
<#

(define a (apply make <QApplication> (receive (argc+argv))))
(define hello (make <QPushButton> "hello world!" #f))
(resize hello 100 30)
(setMainWidget a hello)
(show hello)
(exec a)
(destroy hello)
(destroy a)
@end verbatim


@menu
* #> ... <# Syntax::            
* General operation::           
* Pseudo declarations::         
* Grammar::                     
* C notes::                     
* C++ notes::
@end menu

@node #> ... <# Syntax
@subsection @code{#> ... <#} Syntax

Occurrences of the special read syntax @code{#>[SPEC ...] ...<#} will be handled according to
@code{SPEC}: 

If @code{SPEC} is the @code{?} character, the text following up to the next @code{<#}
will be processed as a @code{(declare (foreign-parse "..."))} declaration (the code will be processed
by the FFI parser described in this section).

If @code{SPEC} is the @code{!} character, the text will be embedded as 

@verbatim
(foreign-parse(declare "...")
@end verbatim

It will be both included verbatim in the declaration section of the generated C/C++ file and processed by the FFI parser.

If @code{SPEC} is the @code{:} character, the text will be so it will be executed at the location where it appears.

If @code{SPEC} is a list of the form @code{(TAG ...)}, then each @code{TAG} (which should be a symbol)
specifies what should be done with the text: 

@table @code
@item declare
(foreign-declare "...")
@item parse
(foreign-parse "...")
@item execute
(foreign-code "...")
@end table

If any other character follows the @code{#>}, then the complete text will be included verbatim in the declaration
part of the generated file (as in a @code{foreign-declare} form). 


@node General operation
@subsection General operation

The parser will generally perform the following functions

1) Translate macro, enum-definitions and constants into @code{define-foreign-variable} or @code{define-constant} forms

2) Translate function prototypes into @code{foreign-lambda} forms

3) Translate variable declarations into accessor procedures

4) Handle basic preprocessor operations

5) Translate simple C++ class definitions into TinyCLOS wrapper classes and methods

Basic token-substitution of macros defined via @code{#define} is performed. The
preprocessor commands @code{#ifdef}, @code{#ifndef}, @code{#else}, @code{#endif}, @code{#undef} and @code{#error}
are handled. The preprocessor commands @code{#if} and @code{#elif} are not supported and will signal 
an error when encountered by the parser, because C expressions (even if constant) are not parsed.
The preprocessor command @code{#pragma} is allowed but will be ignored.

During processing of @code{foreign-parse} declarations the macro @code{CHICKEN} is defined (similar
to the C compiler option @code{-DCHICKEN}).

Macro- and type-definitions are available in subsequent @code{foreign-parse} declarations.
C variables declared generate a procedure with zero or one argument with the same name
as the variable. When called with no arguments, the procedure returns the current value of the
variable. When called with an argument, then the variable is set to the value of that argument.
C and C++ style comments are supported. Variables declared as @code{const}
will generate normal Scheme variables, bound to the initial value of the variable.

Function-, member-function and constructor/destructor definitions may be preceded by the @code{___safe}
qualifier, which marks the function as (possibly) performing a callback into Scheme. If a wrapped function
calls back into Scheme code, and @code{___safe} has not been given very strange and hard to debug
problems will occur. For backward compatibilty, @code{___callback} is also allowed in place of @code{___safe}.

Functions and member functions prefixed with @code{___discard} and a result type that maps to
a Scheme string (@code{c-string}), will have their result type changed to @code{c-string*} instead.

Constants (as declared by @code{#define} or @code{enum}) are not visible outside of the current
Compilation units unless the @code{export_constants} pseudo declaration has been used. 
Only numeric or character constants are directly supported.

When given the option @code{-ffi}, CHICKEN will compile a C/C++ file in ``Scheme'' mode, that is,
it wraps the C/C++ source inside @code{#>! ... <#} and compiles it while generating Scheme
bindings for exported definitions.

Function-arguments may be preceded by @code{___in}, @code{___out} and @code{___inout}
qualifiers to specify values that are passed by reference to a function, or returned by
reference. Only basic types (booleans, numbers and characters) can be passed using this method. 
During the call a pointer to a temporary piece of storage containing the initial value (or a random 
value, for @code{___out} parameters) will
be allocated and passed to the wrapped function. This piece of storage is subject to
garbage collection and will move, should a callback into Scheme occur that triggers
a garbage collection. Multiple @code{__out} and @code{___inout} parameters will
be returned as multiple values, preceded by the normal return value of thhe function
(if not @code{void}). Here is a simple example:

@verbatim
#>!
#ifndef CHICKEN
#include <math.h>
#endif

double modf(double x, ___out double *iptr);
<#

(let-values ([(frac int) (modf 33.44)])
  ...)
@end verbatim

Function-arguments may be preceded by @code{___length(ID)}, where @code{ID} designates
the name of another argument that must refer to a number vector or string argument. The value
of the former argument will be computed at run-time and thus can be omitted:

@verbatim
#>!
(require-extension srfi-4)

double sumarray(double *arr, ___length(arr) int len)
{
  double sum = 0;

  while(len--) sum += *(arr++);

  return sum;
}
<#

(print (sumarray (f64vector 33 44 55.66)))
@end verbatim

The length variable may be positioned anywhere in the argument list. Length markers may only be
specified for arguments passed as SRFI-4 byte-vectors, byte-vectors (as provided by the
@code{lolevel} library unit) or strings.

Structure and union definitions containing actual field declarations generate getter procedures 
(and setter procedures when
declared @code{___mutable} or the @code{mutable_fields} pseudo declaration has been used)
The names of these procedures are computed by concatenating the struct (or union) name,
a hyphen (@code{"-"}) and the field name, and the string @code{"-set!"}, in the case of
setters. Structure definitions with fields may not be used in positions where a type
specifier is normally expected. The field accessors operate on struct/union pointers only.
Additionally a zero-argument procedure named @code{make-<structname>} will be generated
that allocates enough storage to hold an instance of the structure (or union).
Prefixing the definition with @code{___abstract} will omit the creation procedure.

@verbatim
#>!
struct My_struct { int x; ___mutable float y; };

typedef struct My_struct My_struct;

My_struct *make_struct(int x, float y) 
{
  My_struct *s = (My_struct *)malloc(sizeof(My_struct));
  s->x = x;
  s->y = y;
  return s;
}
<#
@end verbatim

will generate the following definitions:

@lisp
(make-My_struct) -> PTR
(My_struct-x PTR) -> INT
(My_struct-y PTR) -> FLOAT
(My_struct-y-set! PTR FLOAT)
(make_struct INT FLOAT) -> PTR
@end lisp

Nested structs or unions are not supported (but pointers to nested structs/unions are).

All specially handled tokens preceded with @code{___} are defined as C macros in the
headerfile @code{chicken.h} and will usually expand into nothing, so they don't
invalidate the processed source code.

C++ @code{namespace} declarations of the form @code{namespace NAME @{ ... @}} recognized but will
be completely ignored.

Keep in mind that this is not a fully general C/C++ parser. Taking an arbitrary headerfile and feeding
it to CHICKEN will in most cases not work or generate riduculuous amounts of code. This FFI
facility is for carefully written headerfiles, and for declarations directly embedded into
Scheme code.

@node Pseudo declarations
@subsection Pseudo declarations

Using the @code{___declare(DECL, VALUE)} form, pseudo declarations can be embedded into
processed C/C++ code to provide additional control over the wrapper generation. Pseudo declarations
will be ignored when processed by the system's C/C++ compiler.

@itemize

@item abstract [values: <string>]
Marks the C++ class given in @code{<string>} as being abstract, i.e. no constructor will
be defined. Alternatively, a class definition may be prefixed with @code{___abstract}.

@item class_finalizers [values: yes, no]
Automatically generates calls to @code{set-finalizer!} so that any unused references to
instances of subsequently defined C++ class wrappers will be destroyed. This should be used
with care: if the embedded C++ object which is represented by the reclaimed TinyCLOS instance
is still in use in foreign code, then unpredictable things will happen.
@item mutable_fields [values: yes, no]
Specifies that all struct or union fields should generate setter procedures (the default is to
generate only setter procedures for fields declared @code{___mutable}).


@item destructor_name [values: <string>]
Specifies an alternative name for destructor methods (the default is @code{destroy}.

@item export_constants [values: yes (default), no]
Define a global variable for constant-declarations (as with @code{#define} or @code{enum}),
making the constant available outside the current compilation unit. Use the values
@code{yes}/@code{1} for switching constant export on, or @code{no}/@code{0} for switching
it off.

@item exception_handler [values: <string>]
Defines C++ code to be executed when an exception is triggered inside a C++ class member
function. The code should be one or more @code{catch} forms that perform any actions 
that should be taken in case an exception is thrown by the wrapped member function:

@verbatim
#>!
___declare(exception_handler, "catch(...) { return 0; }")

class Foo {
 public:
  Foo *bar(bool f) { if(f) throw 123; else return this; }
};
<#

(define f1 (make <Foo>))
(print (bar f1 #f))
(print (bar f1 #t))
@end verbatim

will print @code{<Foo>} and @code{#f}, respectively.

@item full_specialization [values: yes, no]
Enables ``full specialization'' mode. In this mode all wrappers for functions, member functions
and static member functions are created as fully specialized TinyCLOS methods. This can be
used to handle overloaded C++ functions properly. Only a certain set of foreign argument types
can be mapped to TinyCLOS classes, as listed in the following table:

@table @code
@item char
<char>
@item bool
<bool>
@item c-string
<string>
@item unsigned-char
<exact>
@item byte
<exact>
@item unsigned-byte
<exact>
@item [unsigned-]int
<exact>
@item [unsigned-]short
<exact>
@item [unsigned-]long
<integer>
@item [unsigned-]integer
<integer>
@item float
<inexact>
@item double
<inexact>
@item number
<number>
@item (enum _)char
<exact>
@item (const T)char
(as T)
@item (function ...)
<pointer>
@item c-pointer
<pointer>
@item (pointer _)
<pointer>
@item (c-pointer _)
<pointer>
@item u8vector
<u8vector>
@item s8vector
<s8vector>
@item u16vector
<u16vector>
@item s16vector
<s16vector>
@item u32vector
<u32vector>
@item s32vector
<s32vector>
@item f32vector
<f32vector>
@item f64vector
<f64vector>
@end table


All other foreign types are specialized as @code{<top>}.

Full specialization can be enabled globally, or only for sections of code by
enclosing it in

@verbatim
___declare(full_specialization, yes)
...
int foo(int x);
int foo(char *x);
...
___declare(full_specialization, no)
@end verbatim

Alternatively, member function definitions may be prefixed by @code{___specialize} for specializing
only specific members.

@item prefix [values: <string>]

Sets a prefix that should be be added to all generated Scheme identifiers. For example

@verbatim
___declare(prefix, "mylib:")
#define SOME_CONST     42
@end verbatim

would generate the following code:

@verbatim
(define-constant mylib:SOME_CONST 42)
@end verbatim

To switch prefixing off, use the values @code{no} or @code{0}. Prefixes are not applied to
Class names.

@item rename [value: <string>]

Defines to what a certain C/C++ name should be renamed. The value for this declaration
should have the form @code{"<c-name>;<scheme-name>"}, where @code{<c-name>} specifies
the C/C++ identifier occurring in the parsed text and @code{<scheme-name>} gives
the name used in generated wrapper code.

@item scheme [value: <string>]

Embeds the Scheme expression @code{<string>} in the generated Scheme code.

@item substitute [value: <string>]

Declares a name-substitution for all generated Scheme identifiers. The value for this
declaration should be a string containing a regular expression and a replacement string
(separated by the @code{;} character):

@verbatim
___declare(substitute, "^SDL_;sdl:")

extern void SDL_Quit();
@end verbatim

generates

@verbatim
(define sdl:Quit
  (foreign-lambda integer "SDL_Quit") )
@end verbatim

@item transform [values: <string>]

Defines an arbitrary transformation procedure for names that match a given regular expression.
The value should be a string containing a regular expression and a Scheme expression that
evaluates to a procedure of one argument. If the regex matches, the procedure will be called
at compile time with the match-result (as returned by @code{string-match}) and should return
a string with the desired transformations applied:

@verbatim
(require-for-syntax 'srfi-13)

#>!
___declare(transform, "([A-Z]+)_(.*);(lambda (x) (string-append (cadr x) \"-\" (string-downcase (caddr x))))")

void FOO_Bar(int x) { return x * 2; }
<#

(print (FOO-bar 33))
@end verbatim

@item default_renaming [value: <string>]

Chooses a standard name-transformation, converting underscores (@code{_}) to hyphens (@code{-}) and
transforming ``CamelCase'' into ``camel-case''. All uppercase characters are also converted to lowercase.
The result is prefixed with the argument string (equivalent to the @code{prefix} pseudo declaration).

@item type [value: <string>]

Declares a foreign type transformation, similar to @code{define-foreign-type}. 
The value should be a list of two to four items, separated by the @code{;} character:
a C typename, a Scheme foreign type specifier and optional argument- and result-value
conversion procedures.

@verbatim
;;;; foreign type that converts to unicode (assumes 4-byte wchar_t):
;
; - Note: this is rather kludgy and is only meant to demonstrate the `type'
;         pseudo-declaration

(require-extension srfi-4)

(define mbstowcs (foreign-lambda int "mbstowcs" nonnull-u32vector c-string int))

(define (str->ustr str)
  (let* ([len (string-length str)]
         [us (make-u32vector (add1 len) 0)] )
    (mbstowcs us str len)
    us) )

#>!
___declare(type, "unicode;nonnull-u32vector;str->ustr")

static void foo(unicode ws)
{
  printf("\"%ls\"\n", ws);
}
<#

(foo "this is a test!")
@end verbatim

@item opaque [value: <string>]

Similar to @code{type}, but provides automatic argument- and result conversions
to wrap a value into a structure:

@verbatim
#>?
___declare(opaque, "myfile;(pointer \"FILE\")")

myfile fopen(char *, char *);
<#

(fopen "somefile" "r")   ==> <myfile>
@end verbatim

@code{___declare(opaque, "TYPENAME;TYPE")} is basically equivalent to
@code{___declare(type, "TYPENAME;TYPE;TYPE->RECORD;RECORD->TYPE")} where
@code{TYPE->RECORD} and @code{RECORD->TYPE} are compiler-generated conversion
functions that wrap objects of type @code{TYPE} into a record and back.

@end itemize

@node Grammar
@subsection Grammar

The parser understand the following grammar:

@verbatim
PROGRAM = PPCOMMAND
        | DECLARATION ";"

PPCOMMAND = "#define" ID [TOKEN ...]
          | "#ifdef" ID
          | "#ifndef" ID
          | "#else"
          | "#endif"
          | "#undef" ID
          | "#error" TOKEN ...
          | "#include" INCLUDEFILE
          | "#import" INCLUDEFILE
          | "#pragma" TOKEN ...

DECLARATION = FUNCTION
            | VARIABLE
            | ENUM
            | TYPEDEF
            | CLASS
            | CONSTANT
            | STRUCT
            | NAMESPACE
            | "___declare" "(" PSEUDODECL "," <tokens> ")"

STRUCT = ("struct" | "union") ID ["{" {["___mutable"] TYPE {"*"} ID {"," {"*"} ID}} "}]

NAMESPACE = "namespace" ID "{" DECLARATION ... "}"

INCLUDEFILE = "\"" ... "\""
            | "<" ... ">"

FUNCTION = {"___callback" | "___safe" | "___specialize" | "___discard"} [STORAGE] TYPE ID "(" ARGTYPE "," ... ")" [CODE]
         | {"___callback" | "___safe" | "___specialize" | "___discard"} [STORAGE] TYPE ID "(" "void" ")" [CODE]

ARGTYPE = [IOQUALIFIER] TYPE [ID ["[" ... "]"]]

IOQUALIFIER = "___in" | "___out" | "___inout" | LENQUALIFIER

LENQUALIFIER = "___length" "(" ID ")"

VARIABLE = [STORAGE] ENTITY ["=" INITDATA]

ENTITY = TYPE ID ["[" ... "]"]

STORAGE = "extern" | "static" | "volatile" | "inline"

CONSTANT = "const" TYPE ID "=" INITDATA

PSEUDODECL = "export_constants"
           | "prefix"
           | "substitute"
           | "abstract"
           | "type"
           | "scheme"
           | "rename"
           | "transform"
           | "full_specialization"
           | "destructor_name"
           | "class_finalizers"
           | "exception_handler"
           | "mutable_fields"

ENUM = "enum" "{" ID ["=" (NUMBER | ID)] "," ... "}"

TYPEDEF = "typedef" TYPE ["*" ...] [ID]

TYPE = ["const"] BASICTYPE [("*" ... | "&" | "<" TYPE "," ... ">" | "(" "*" [ID] ")" "(" TYPE "," ... ")")]

BASICTYPE = ["unsigned" | "signed"] "int" 
          | ["unsigned" | "signed"] "char" 
          | ["unsigned" | "signed"] "short" ["int"]
          | ["unsigned" | "signed"] "long" ["int"]
          | ["unsigned" | "signed"] "___byte" 
          | "size_t"
          | "float"
          | "double"
          | "void"
          | "bool"
          | "___bool"
          | "___scheme_value"
          | "___scheme_pointer"
          | "___byte_vector"
          | "___pointer" TYPE "*"
          | "C_word"
          | "___fixnum"
          | "___number"
          | "___symbol"
          | "___u32"
          | "___s32"
          | "___s64"
          | "__int64"
          | "int64_t"
          | "struct" ID
          | "union" ID
          | "enum" ID
          | ID

CLASS = ["___abstract"] "class" ID [":" [QUALIFIER] ID "," ...] "{" MEMBER ... "}"

MEMBER = [QUALIFIER ":"] ["virtual"] (MEMBERVARIABLE | CONSTRUCTOR | DESTRUCTOR | MEMBERFUNCTION)

MEMBERVARIABLE = TYPE ID ["=" INITDATA]

MEMBERFUNCTION = {"___callback" | "static" | "___specialize" | "___discard"} TYPE ID "(" ARGTYPE "," ... ")" ["const"] ["=" "0"] [CODE]
               | {"___callback" | "static" | "___specialize" | "___discard"} TYPE ID "(" "void" ")" ["const"] ["=" "0"] [CODE]

CONSTRUCTOR = ["___callback" | "___safe"] ["explicit"] ID "(" ARGTYPE "," ... ")" [BASECONSTRUCTORS] [CODE]

DESTRUCTOR = ["___callback" | "___safe"] "~" ID "(" ["void"] ")" [CODE]

QUALIFIER = ("public" | "private" | "protected")

NUMBER = <a C integer or floating-point number, in decimal, octal or hexadecimal notation>

INITDATA = <everything up to end of chunk>

BASECONSTRUCTORS = <everything up to end of chunk>

CODE = <everything up to end of chunk>
@end verbatim

The following table shows how argument-types are translated:


@table @code
@item [unsigned] char
char
@item [unsigned] short
[unsigned-]short
@item [unsigned] int
[unsigned-]integer
@item [unsigned] long
[unsigned-]long
@item ___u32
unsigned-integer32
@item ___s32
integer32
@item ___s64
integer64
@item int64_t
integer64
@item __int64
integer64
@item float
float
@item double
double
@item size_t
unsigned-integer
@item bool
int
@item ___bool
int
@item ___fixnum
int
@item ___number
number
@item ___symbol
symbol
@item ___scheme_value
scheme-object
@item C_word
scheme-object
@item ___scheme_pointer
scheme-pointer
@item char *
c-string
@item signed char *
s8vector
@item [signed] short *
s16vector
@item [signed] int *
s32vector
@item [signed] long *
s32vector
@item unsigned char *
u8vector
@item unsigned short *
u16vector
@item unsigned int *
u32vector
@item unsigned long *
u32vector
@item float *
f32vector
@item double *
f64vector
@item ___byte_vector
byte-vector
@item CLASS *
(instance CLASS <CLASS>)
@item CLASS &
(instance-ref CLASS <CLASS>)
@item TYPE *
(pointer TYPE)
@item TYPE &
(ref TYPE)
@item TYPE<T1, ...>
(template TYPE T1 ...)
@item TYPE1 (*)(TYPE2, ...)
(function TYPE1 (TYPE2 ...))
@end table


The following table shows how result-types are translated:

@table @code
@item void
void
@item [unsigned] char
char
@item [unsigned] short
[unsigned-]short
@item [unsigned] int
[unsigned-]integer
@item [unsigned] long
[unsigned-]long
@item ___u32
unsigned-integer32
@item ___s32
integer32
@item ___s64
integer64
@item int64_t
integer64
@item __int64
integer64
@item float
float
@item double
double
@item size_t
unsigned-integer
@item bool
bool
@item ___bool
bool
@item ___fixnum
int
@item ___number
number
@item ___symbol
symbol
@item ___scheme_value
scheme-object
@item char *
c-string
@item TYPE *
(pointer TYPE)
@item TYPE &
(ref TYPE)
@item TYPE<T1, ...>
(template TYPE T1 ...)
@item TYPE1 (*)(TYPE2, ...)
(function TYPE1 (TYPE2 ...))
@item CLASS *
(instance CLASS <CLASS>)
@item CLASS &
(instance-ref CLASS <CLASS>)
@end table

The @code{___pointer} argument marker disables automatic simplification of pointers to numbers: normally
arguments of type @code{int *} are handled as SRFI-4 @code{s32vector} number vectors. To force treatment
as a pointer argument, precede the argument type with @code{___pointer}.


@node C notes
@subsection C notes

Foreign variable definitions for macros are not exported from the current compilation unit, but
definitions for C variables and functions are. 

@code{foreign-parse} does not embed the text into
the generated C file, use @code{foreign-declare} for that (or even better, use the @code{#>! ... <#} syntax
which does both).

Functions with variable number of arguments are not supported.

@node C++ notes
@subsection C++ notes

Each C++ class defines a TinyCLOS class, which is a subclass of @code{<c++-object>}. Instances of this class
contain a single slot named @code{this}, which holds a pointer to a heap-allocated C++ instance.
The name of the TinyCLOS class is obtained by putting the C++ classname between angled brackets (@code{<...>}).
TinyCLOS classes are not seen by C++ code.

The C++ constructor is invoked by the @code{initialize} generic, which accepts as many arguments
as the constructor. If no constructor is defined, a default-constructor will be provided taking no arguments.
To allow creating class instances from pointers created in foreign code, the @code{initialize}
generic will optionally accept an arguments list of the form @code{'this POINTER}, where @code{POINTER}
is a foreign pointer object. This will create a TinyCLOS instance for the given C++ object.

To release the storage allocated for a C++ instance invoke the @code{destroy} generic
(the name can be changed by using the @code{destructor_name} pseudo declaration).

Static member functions are wrapped in a Scheme procedure named @code{<class>::<member>}.

Member variables and non-public member functions are ignored. 

Virtual member functions are not seen by C++ code. Overriding a virtual member function with a TinyCLOS
method will not work when the member function is called by C++.

Operator functions and default arguments are not supported.

Exceptions must be explicitly handled by user code and may not be thrown beyond an invocation
of C++ by Scheme code.


@node C interface
@section C interface


The following functions and macros are available for C code that invokes
Scheme or foreign procedures that are called by Scheme:



@deftypefn {C macro} void C_save (C_word x)
Saves the Scheme data object @code{x} on the temporary stack.
@end deftypefn

@deftypefn {C macro} void C_restore
Pops and returns the topmost value from the temporary stack.
@end deftypefn

@deftypefn {C macro} C_word C_fix (int integer)
@deftypefnx {C macro} C_word C_make_character (int char_code)
@deftypefnx {C macro} C_word C_SCHEME_END_OF_LIST
@deftypefnx {C macro} C_word C_SCHEME_END_OF_FILE
@deftypefnx {C macro} C_word C_SCHEME_FALSE
@deftypefnx {C macro} C_word C_SCHEME_TRUE
These macros return immediate Scheme data objects.
@end deftypefn

@deftypefn {C function} C_word C_string (C_word **ptr, int length, char *string)
@deftypefnx {C function} C_word C_string2 (C_word **ptr, char *zero_terminated_string)
@deftypefnx {C function} C_word C_intern2 (C_word **ptr, char *zero_terminated_string)
@deftypefnx {C function} C_word C_intern3 (C_word **ptr, char *zero_terminated_string, C_word initial_value)
@deftypefnx {C function} C_word C_pair (C_word **ptr, C_word car, C_word cdr)
@deftypefnx {C function} C_word C_flonum (C_word **ptr, double number)
@deftypefnx {C function} C_word C_int_to_num (C_word **ptr, int integer)
@deftypefnx {C function} C_word C_mpointer (C_word **ptr, void *pointer)
@deftypefnx {C function} C_word C_vector (C_word **ptr, int length, ...)
@deftypefnx {C function} C_word C_list (C_word **ptr, int length, ...)
These functions allocate memory from @code{ptr} and initialize a fresh
data object. The new data object is returned. @code{ptr} should be the
@b{address} of an allocation pointer created with @code{C_alloc}.
@end deftypefn

@deftypefn {C macro} C_word* C_alloc (int words)
Allocates memory from the C stack (@code{C_alloc}) and returns a pointer to
it. @code{words} should be the number of words needed for all data
objects that are to be created in this function.  Note that stack-allocated
data objects have to be passed to Scheme callback functions, or they will
not be seen by the garbage collector. This is really only usable for
callback procedure invocations, make sure not to use it in normal code,
because the allocated memory will be re-used after the foreign procedure
returns. When invoking Scheme callback procedures a minor garbage
collection is performed, so data allocated with @code{C_alloc}
will already have moved to a safe place.

Note that @code{C_alloc} is really just a wrapper around @code{alloca},
and can also be simulated by declaring a stack-allocated array of
@code{C_word}s:
@end deftypefn

@deftypefn {C macro} int C_SIZEOF_LIST (int length)
@deftypefnx {C macro} int C_SIZEOF_STRING (int length)
@deftypefnx {C macro} int C_SIZEOF_VECTOR (int length)
@deftypefnx {C macro} int C_SIZEOF_INTERNED_SYMBOL (int length)
@deftypefnx {C macro} int C_SIZEOF_PAIR
@deftypefnx {C macro} int C_SIZEOF_FLONUM
@deftypefnx {C macro} int C_SIZEOF_POINTER
@deftypefnx {C macro} int C_SIZEOF_LOCATIVE
@deftypefnx {C macro} int C_SIZEOF_TAGGED_POINTER
These are macros that return the size in words needed for a data object
of a given type.
@end deftypefn

@deftypefn {C macro} int C_character_code (C_word character)
@deftypefnx {C macro} int C_unfix (C_word fixnum)
@deftypefnx {C macro} double C_flonum_magnitude (C_word flonum)
@deftypefnx {C function} char* C_c_string (C_word string)
@deftypefnx {C function} int C_num_to_int (C_word fixnum_or_flonum)
@deftypefnx {C function} void* C_pointer_address (C_word pointer)
These macros and functions can be used to convert Scheme data objects
back to C data. Note that @code{C_c_string()} returns a pointer
to the character buffer of the actual Scheme object and is not
zero-terminated.
@end deftypefn

@deftypefn {C macro} int C_header_size (C_word x)
@deftypefnx {C macro} int C_header_bits (C_word x)
Return the number of elements and the type-bits of the non-immediate
Scheme data object @code{x}.
@end deftypefn

@deftypefn {C macro} C_word C_block_item (C_word x, int index)
This macro can be used to access slots of the non-immediate Scheme data
object @code{x}.  @code{index} specifies the index of the slot to
be fetched, starting at 0. Pairs have 2 slots, one for the @b{car}
and one for the @b{cdr}. Vectors have one slot for each element.
@end deftypefn

@deftypefn {C macro} C_word C_u_i_car (C_word x)
@deftypefnx {C macro} C_word C_u_i_car (C_word x)
Aliases for @code{C_block_item(x, 0)} and @code{C_block_item(x, 1)}, respectively.
@end deftypefn

@deftypefn {C macro} void* C_data_pointer (C_word x)
Returns a pointer to the data-section of a non-immediate Scheme object.
@end deftypefn

@deftypefn {C macro} C_word C_make_header (C_word bits, C_word size)
A macro to build a Scheme object header from its bits and size parts.
@end deftypefn

@deftypefn {C function} C_word C_mutate (C_word *slot, C_word val)
Assign the Scheme value @code{val} to the location specified by
@code{slot}.  If the value points to data inside the nursery (the first
heap-generation), then the garbage collector will remember to handle the
data appropriately. Assigning nursery-pointers directly will otherwise
result in lost data. Note that no copying takes place at the moment
when @code{C_mutate} is called, but later - at the next (minor) garbage
collection.
@end deftypefn

@deftypefn {C macro} C_word C_symbol_value (C_word symbol)
Returns the global value of the variable with the name @code{symbol}. If the
variable is unbound @code{C_SCHEME_UNBOUND} is returned. You can set a variable's
value with @code{C_mutate(&C_symbol_value(SYMBOL), VALUE)}.
@end deftypefn

@deftypefn {C function} void C_gc_protect (C_word *ptrs[], int n)
Registers @code{n} variables at address @code{ptrs} to be garbage collection roots.
The locations should not contain pointers to data allocated in the nursery, only
immediate values or pointers to heap-data are valid. Any
assignment of potential nursery data into a root-array should be done
via @code{C_mutate()}. The variables have to be initialized to sensible values
before the next garbage collection starts (when in doubt, set all locations
in @code{ptrs} to @code{C_SCHEME_UNDEFINED})
@code{C_gc_protect} may not called before the runtime system has been
initialized (either by @code{CHICKEN_initialize}, @code{CHICKEN_run} or
@code{CHICKEN_invoke}.

For a slightly simpler interface to creating and using GC roots see
@code{CHICKEN_new_gc_root}.
@end deftypefn

@deftypefn {C function} void C_gc_unprotect (int n)
Removes the last @code{n} registered variables from the set of
root variables.
@end deftypefn

@deftypevr {C Variable} void (*C_post_gc_hook)(int mode)
If not @code{NULL}, the function pointed to by this variable will be called
after each garbage collection with a flag indicating what kind of collection
was performed (either @code{0} for a minor collection or @code{1} for a major
collection). Minor collections happen very frequently, so the hook function
should not consume too much time. The hook function may not invoke Scheme
callbacks.
@end deftypevr


An example:

@verbatim
% cat foo.scm
#>
extern int callout(int, int, int);
<#

(define callout (foreign-safe-lambda int "callout" int int int))

(define-external (callin (scheme-object xyz)) int
  (print "This is 'callin': " xyz)
  123)

(print (callout 1 2 3))

% cat bar.c
#include <stdio.h>
#include "chicken.h"

extern int callout(int, int, int);
extern int callin(C_word x);

int callout(int x, int y, int z)
{
  C_word *ptr = C_alloc(C_SIZEOF_LIST(3));
  C_word lst;

  printf("This is 'callout': %d, %d, %d\n", x, y, z);
  lst = C_list(&ptr, 3, C_fix(x), C_fix(y), C_fix(z));
  return callin(lst);  /* Note: `callin' will have GC'd the data in `ptr' */
}

% csc foo.scm bar.c -o foo
% foo
This is 'callout': 1, 2, 3
This is 'callin': (1 2 3)
123
@end verbatim


@b{Notes:}
@itemize

@item Scheme procedures can call C functions, and C functions can call
Scheme procedures, but for every pending C stack frame, the available
size of the first heap generation (the ``nursery'') will be decreased,
because the C stack is identical to the nursery. On systems with a small
nursery this might result in thrashing, since the C code between the
invocation of C from Scheme and the actual calling back to Scheme might
build up several stack-frames or allocates large amounts of stack data.
To prevent this it is advisable to increase the default nursery size,
either when compiling the file (using the @code{-nursery} option)
or when running the executable (using the @code{-:s} runtime option).

@item Calls to Scheme/C may be nested arbitrarily, and Scheme
continuations can be invoked as usual, but keep in mind that C stack
frames will not be recovered, when a Scheme procedure call from C does
not return normally.

@item When multiple threads are running concurrently, and control switches
from one thread to another, then the continuation of the current thread
is captured and saved. Any pending C stack frame still active from a
callback will remain on the stack until the threads is re-activated
again. This means that in a multithreading situation, when C callbacks
are involved, the available nursery space can be smaller than expected.
So doing many nested Scheme->C->Scheme calls can reduce the available
memory up to the point of thrashing. It is advisable to have only a
single thread with pending C stack-frames at any given time.

@item Pointers to Scheme data objects should not be stored in local or
global variables while calling back to Scheme.  Any Scheme object not
passed back to Scheme will be reclaimed or moved by the garbage collector.

@item Calls from C to Scheme are never tail-recursive.

@item Continuations captured via @code{call-with-current-continuation}
and passed to C code can be invoked like any other Scheme procedure.

@end itemize


@node chicken-setup
@chapter chicken-setup

@menu
* Extension libraries::
* Installing extensions::
* Creating extensions::
* Procedures and macros available in setup scripts::
* Examples for extensions::
* @code{chicken-setup} reference::
* Windows notes::
@end menu


@node Extension libraries
@section Extension libraries

Extension libraries are extensions to the core functionality provided
by the basic CHICKEN system, to be built and installed separately.
The mechanism for loading compiled extensions is based on dynamically
loadable code and as such is only available on systems on which
loading compiled code at runtime is supported. Currently this are
most UNIX-compatible platforms that provide the @code{libdl} functionality
like Linux, Solaris, BSD or Mac OS X.
Windows with the Microsoft tools is partially supported.

Note: Extension may also be normal applications or shell scripts.


@node Installing extensions
@section Installing extensions

To install an extension library, run the @code{chicken-setup} program
with the extension name as argument. If the extension consists of a 
single Scheme file, then it is compiled and installed in the extension
@emph{repository}. If it is an archive containing addition files, then
the files are extracted and the contained @emph{setup} script is
executed. This setup script is a normal Scheme source file, which
will be interpreted by @code{chicken-setup}. The complete language supported
by @code{csi} is available, and the library units 
@code{srfi-1 regex utils posix tcp} are loaded. Additional
libraries can of course be loaded at run-time.

The setup script should perform all necessary steps to build the 
new library (or application). After a successful build, the extension
can be installed by invoking one of the procedures
@code{install-extension}, @code{install-program} or @code{install-script}.
These procedures will copy a number of given files into the extension
repository or in the path where the CHICKEN executables are located (in the
case of executable programs or scripts). Additionally the list of
installed files, and user-defined metadata is stored in the repository.

If no extension name is given on the command-line, and if none of the
options @code{-list}, @code{-version}, @code{-repository} (without argument),
@code{-program-path} (without argument), @code{-fetch} or @code{-docindex}
is given, then all @code{.setup} scripts in the current directory are
processed.


@node Creating extensions
@section Creating extensions

Extensions can be created by creating an (optionally gzipped) @code{tar} 
archive named @code{EXTENSION.egg}
containing all needed files plus a @code{.setup} script in the root directory.
After @code{chicken-setup} has extracted the files, the setup script will be
invoked. There are no additional constraints on the structure of the archive,
but the setup script has to be in the root path of the archive.


@node Procedures and macros available in setup scripts
@section Procedures and macros available in setup scripts

@deffn {procedure} install-extension
@lisp
(install-extension ID FILELIST [INFOLIST])
@end lisp
Installs the extension library with the name @code{ID}. All files given in the list of strings
@code{FILELIST} will be copied to the extension repository. It should be noted here that
the extension id has to be identical to the name of the file implementing the extension. The
extension may load or include other files, or may load other extensions at runtime specified
by the @code{require-at-runtime} property.

@code{FILELIST} may be a filename, a list of filenames, or a list of pairs of
the form @code{(SOURCE DEST)} (if you want to copy into a particular sub-directory - the
destination directory will be created as needed). If @code{DEST} is a relative pathname,
it will be copied into the extension repository.

The optional argument @code{INFOLIST} should be an association list that
maps symbols to values, this list will be stored as @code{ID.setup} at the same
location as the extension code. Currently the following properties are used:

@deffn {property} syntax
@lisp
(syntax)
@end lisp
Marks the extension as syntax-only. No code is compiled, the extension is intended
as a file containing macros to be loaded at compile/macro-expansion time.
@end deffn

@deffn {property} require-at-runtime
@lisp
(require-at-runtime ID ...)
@end lisp
Specifies extensions that should be loaded (via @code{require}) at runtime. This is mostly
useful for syntax extensions that need additional support code at runtime.
@end deffn

@deffn {property} version
@lisp
(version STRING)
@end lisp
Specifies version string.
@end deffn

@deffn {property} documentation
@lisp
(documentation FILENAME)
@end lisp
The filename of a HTML document containing extension-specific documentation.
This file should be given in the file-list passed to @code{install-extension} and
a link to it will be automatically included in the index page (accessible via
@code{chicken-setup -docindex}).
@end deffn

@deffn {property} examples
@lisp
(examples FILENAME ...)
@end lisp
Copies the given files into the examples directory, which is usually 
@code{$prefix/share/chicken/examples} (equivalent to @code{$CHICKEN_HOME/examples}
or @code{(make-pathname (chicken-home) "examples")}).
@end deffn

@deffn {property} exports
@lisp
(exports EXPORT ...)
@end lisp
Add export-information to the generated extension-information. @code{EXPORT} may be
a symbol naming an exported toplevel variable or a string designating a file with
exported variables, as generated by the @code{-emit-exports} option or the
@code{emit-exports} declaration specifier.
@end deffn

All other properties are currently ignored. The @code{FILELIST} argument may also be a single
string.

@end deffn

@deffn {procedure} install-program
@lisp
(install-program ID FILELIST [INFOLIST])
@end lisp
Similar to @code{install-extension}, but installs an executable program in the
executable path (usually @code{/usr/local/bin}).
@end deffn

@deffn {procedure} install-script
@lisp
(install-script ID FILELIST [INFOLIST])
@end lisp
Similar to @code{install-program}, but additionally changes the file permissions of all
files in @code{FILELIST} to executable (for installing shell-scripts).
@end deffn


@deffn {syntax} run
@lisp
(run FORM ...)
@end lisp
Runs the shell command @code{FORM}, which is wrapped in an implicit @code{quasiquote}. 
@code{(run (csc ...))} is treated specially and passes @code{-v} (if @code{-verbose} has been given
to @code{chicken-setup}) and @code{-feature compiling-extension} options to the compiler.
@end deffn

@deffn {syntax} compile
@lisp
(compile FORM ...)
@end lisp
Equivalent to @code{(run (csc FORM ...))}.
@end deffn

@deffn {syntax} make
@lisp
(make ((TARGET (DEPENDENT ...) COMMAND ...) ...) ARGUMENTS)
@end lisp
A ``make'' macro that executes the expressions @code{COMMAND ...}, when any of the dependents
@code{DEPENDENT ...} have changed, to build @code{TARGET}. This is the same as the @code{make}
extension, which is available separately. For more information, see
@uref{http://www.call-with-current-continuation.org/eggs/make.html, make}.
@end deffn

@deffn {procedure} patch
@lisp
(patch WHICH REGEX SUBST)
@end lisp
Replaces all occurrences of the regular expression @code{REGEX} with the string @code{SUBST},
in the file given in @code{WHICH}. If @code{WHICH} is a string, the file will be patched and
overwritten. If @code{WHICH} is a list of the form @code{OLD NEW}, then a different file named
@code{NEW} will be generated.
@end deffn

@deffn {procedure} copy-file
@lisp
(copy-file FROM TO)
@end lisp
Copies the file or directory (recursively) given in the string @code{FROM} to the destination
file or directory @code{TO}.
@end deffn

@deffn {procedure} move-file
@lisp
(move-file FROM TO)
@end lisp
Moves the file or directory (recursively) given in the string @code{FROM} to the destination
file or directory @code{TO}.
@end deffn

@deffn {procedure} remove-file*
@lisp
(remove-file* PATH)
@end lisp
Removes the file or directory given in the string @code{PATH}.
@end deffn


@deffn {procedure} create-directory
@lisp
(create-directory PATH)
@end lisp
Creates the directory given in the string @code{PATH}, with all parent directories as needed.
@end deffn

@deffn {procedure} find-library 
@lisp
(find-library NAME PROC)
@end lisp
Returns @code{#t} if the library named @code{libNAME.[a|so]} (unix) or @code{NAME.lib} (windows)
could be found by compiling and linking a test program. @code{PROC} should be the name of a
C function that must be provided by the library. If no such library was found or the function could not
be resolved, @code{#f} is returned.
@end deffn

@deffn {procedure} find-header
@lisp
(find-header NAME)
@end lisp
Returns @code{#t} if a C include-file with the given name is available, or @code{#f} otherwise.
@end deffn

@deffn {procedure} test-compile
@lisp
(test-compile CODE #!key cflags ldflags compile-only)
@end lisp
Returns @code{#t} if the C code in @code{CODE} compiles and links successfully, or @code{#f} otherwise.
The keyword parameters @code{cflags} and @code{ldflags} accept additional compilation and
linking flags. If @code{compile-only} is true, then no linking step takes place.
@end deffn

@deffn {parameter} installation-prefix
Holds the prefix under which CHICKEN executables and libraries have been installed (either
the value of the environment variable @code{CHICKEN_PREFIX} or whatever prefix was
specified at the time the system was built.
@end deffn

@deffn {parameter} program-path
Holds the path where executables are installed and defaults to either @code{$CHICKEN_PREFIX/bin},
if the environment variable @code{CHICKEN_PREFIX} is set, @code{$CHICKEN_HOME} or the
path where the CHICKEN binaries (@code{chicken}, @code{csi}, etc.) are installed.
@end deffn

@deffn {parameter} setup-root-directory
Contains the path of the directory where @code{chicken-setup} was invoked.
@end deffn

@deffn {parameter} setup-build-directory
Contains the path of the directory where the extension is built. This is not necessarily identical
to @code{setup-root-directory}.
@end deffn

@deffn {parameter} setup-verbose-flag
Reflects the setting of the @code{-verbose} option, i.e. is @code{#t}, if @code{-verbose} was
given.
@end deffn

@deffn {parameter} setup-install-flag
Reflects the setting of the @code{--no-install} option, i.e. is @code{#f}, if @code{-no-install} was
given.
@end deffn


@node Examples for extensions
@section Examples for extensions

The simplest case is a single file that does not export any syntax. For example

@lisp
;;;; hello.scm

(define (hello name)
  (print "Hello, " name " !") )
@end lisp

After entering 

@verbatim
$ chicken-setup hello
@end verbatim

at the shell prompt, the file @code{hello.scm} will be compiled into a dynamically loadable library,
with the default compiler options @code{-optimize-level 2 -no-trace -shared}. If the
compilation succeeds, @code{hello.so} will be stored in the repository, together with a file named
@code{hello.setup} (not to be confused with a setup script - this @code{.setup} file just contains
an a-list with metadata).

Use it like any other CHICKEN extension:

@verbatim
$ csi -q
#;1> (require-extension hello)
; loading /usr/local/lib/chicken/hello.so ...
#;2> (hello "me")
Hello, me!
#;3>
@end verbatim

For more elaborate build operations, when installing applications or scripts, or when
additional metadata should be stored for an extension, a @code{setup} script is required
and the script and all additional files should be packaged in a gzipped @code{tar} archive.

Here we create a simple application:

@lisp
;;;; hello2.scm

(print "Hello, ")
(for-each (lambda (x) (printf "~A " x)) (command-line-arguments))
(print "!")
@end lisp

We also need a setup script:

@lisp
;;;; hello2.setup

(run (csc hello2.scm))  ; compile `hello2'
(install-program 'hello2 "hello2") ; name of the extension and files to be installed
@end lisp

To use it, just run @code{chicken-setup} in the same directory:

@verbatim
$ chicken-setup hello2
@end verbatim

Now the program @code{hello2} will be installed in the same location as the other CHICKEN
tools (like @code{chicken}, @code{csi}, etc.), which will normally be @code{/usr/local/bin}.
Note that you need write-permissions for those locations.

Uninstallation is just as easy:

@verbatim
$ chicken-setup -uninstall hello2
@end verbatim

@code{chicken-setup} provides a @code{make} macro, so building operations can be of
arbitrary complexity. When running @code{chicken-setup} with an argument @code{NAME},
for which no associated file @code{NAME.setup}, @code{NAME.egg} or @code{NAME.scm}
exists will ask you to download the extension via HTTP from the default URL
@code{http://www.call-with-current-continuation.org/eggs}. You can use the 
@code{-host} option to specify an alternative source location.

If the given extension name contains a path prefix and the @code{-host} option
is given, then @code{chicken-setup} can also download and install eggs from
an arbitrary HTTP server. Alternatively you can pass a full URL (including the
@code{http://} prefix. Note that no dependency checks are done when downloading
eggs directly with the URL syntax.

Finally a somewhat more complex example: We want to package a syntax extension with
additional support code that is to be loaded at run-time of any Scheme code that
uses that extension. We create a ``glass'' lambda, a procedure with free variables
that can be manipulated from outside:

@lisp
;;;; glass.scm

(define-macro (glass-lambda llist vars . body)
  ;; Low-level macros are fun!
  (let ([lvar (gensym)]
	[svar (gensym)] 
	[x (gensym)]
	[y (gensym)] 
	[yn (gensym)] )
    `(let ,(map (lambda (v) (list v #f)) vars)
       (define (,svar ,x . ,y)
	 (let* ([,yn (pair? ,y)]
		[,y (and ,yn (car ,y))] )
	   (case ,x
	     ,@@(map (lambda (v)
		      `([,v] (if ,yn 
				 (set! ,v ,y)
				 ,v) ) )
		    vars)
	     (else (error "variable not found" ,x)) ) ) )
       (define ,lvar (lambda ,llist ,@@body))
       (extend-procedure ,lvar ,svar) ) ) )
@end lisp

Here some support code that needs to be loaded at runtime:

@lisp
;;;; glass-support.scm

(require-extension lolevel)

(define glass-lambda-accessor procedure-data)
(define (glass-lambda-ref gl v) ((procedure-data gl) v))
(define (glass-lambda-set! gl v x) ((procedure-data gl) v x))
@end lisp

The setup script looks like this:

@lisp
(run (csc -s -O2 -d0 glass-support.scm))

(install-extension
  'glass
  '("glass.scm" "glass-support.so")
  '((syntax) (require-at-runtime glass-support)) )
@end lisp

The invocation of @code{install-extension} provides the files that
are to be copied into the extension repository, and a metadata list that
specifies that the extension @code{glass} is a syntax extension and that,
if it is declared to be used by other code (either with the @code{require-extension}
or @code{require-for-syntax} form), then client code should perform an implicit
@code{(require 'glass-support)} at startup.

This can be conveniently packaged as an ``egg'':

@verbatim
$ tar cfz glass.egg glass.setup glass.scm glass-support.scm
@end verbatim

And now we use it:

@verbatim
$ chicken-setup glass
$ csi -quiet
#;1> (require-extension glass)
; loading /usr/local/lib/chicken/glass.scm ...
; loading /usr/local/lib/chicken/glass-support.so ...
#;2> (define foo (glass-lambda (x) (y) (+ x y)))
#;3> (glass-lambda-set! foo 'y 99)
#;4> (foo 33)
132
@end verbatim


@node @code{chicken-setup} reference
@section @code{chicken-setup} reference

Available options:

@itemize
@item @code{-h  -help}
Show usage information and exit.
@item @code{-V  -version}
Display version and exit.
@item @code{-R  -repository [PATHNAME]}
When used without an argument, the path of the extension repository is displayed on standard
output. When given an argument, the repository pathname (and the @code{repository-path} parameter)
will be set to @code{PATHNAME} for all subsequent operations. The default repository path is
the installation library directory (usually @code{/usr/local/lib/chicken}), or (if set) the
directory given in the environment variable @code{CHICKEN_REPOSITORY}.
@code{PATHNAME} should be an absolute pathname.
@item @code{-P  -program-path [PATHNAME]}
When used without an argument, the path for executables is displayed on standard output. 
When given an argument, the program path for installing executables and scripts will be set to
@code{PATHNAME} for all subsequent operations.
@code{PATHNAME} should be an absolute pathname.
@item @code{-h  -host HOSTNAME[:PORT]}
Specifies alternative host for downloading extensions, optionally with a TCP port number (which
defaults to 80).
@item @code{-u  -uninstall EXTENSION}
Removes all files that were installed for @code{EXTENSION} from the file-system, together
with any metadata that has been stored.
@item @code{-l  -list [NAME ...]}
List all installed extensions or show extension information.
@item @code{-r  -run FILENAME}
Load and execute given file.
@item @code{-s  -script FILENAME}
Executes the given Scheme source file with all remaining arguments and exit. The ``she-bang''
shell script header is recognized, so you can write Scheme scripts that use @code{chicken-setup}
just as with @code{csi}.
@item @code{-e  -eval EXPRESSION}
Evaluates the given expression(s).
@item @code{-v  -verbose}
Display additional debug information.
@item @code{-k  -keep}
Keep temporary files and directories.
@item @code{-c  -csc-option OPTION}
Passes @code{OPTION} as an extra argument to invocations of the compiler-driver (@code{csc}). This
works only if @code{csc} is invoked as @code{(run (csc ...))}.
@item @code{-d  -dont-ask}
Do not ask the user before trying to download required extensions.
@item @code{-n  -no-install}
Do not install generated binaries and/or support files. Any invocations of @code{install-program},
@code{install-extension} or @code{install-script} will be be no-ops.
@item @code{-i  -docindex}
Displays the path to the index-page of any installed extension-documentation. If the index page
does not exist, it is created.
@item @code{-check}
Downloads the repository-index and lists locally installed extensions for which a newer
release is available for download.
@item @code{--}
Ignore all following arguments.
@end itemize

Note that the options are processed exactly in the order in which they appear in the command-line.


@node Windows notes
@section Windows notes

@code{chicken-setup} works on Windows, when compiled with Visual C++, but depends on the @code{tar}
and @code{gunzip} tools to extract the contents of an egg. The best way is to download an egg
either manually (or with @code{chicken-setup -fetch}) and extract its contents with a separate program 
(like @code{winzip}). the @code{CHICKEN_REPOSITORY} environment variable has to be set (in addition
to @code{CHICKEN_HOME}) to a directory where your compiled extensions should be located.

The @code{.setup} scripts will not always work under Windows, and the extensions may require libraries
that are not provided for Windows or work differently. Under these circumstances it is recommended
to perform the required steps to build an extension manually.


@node Additional files
@chapter Additional files


In addition to library units the following files are provided. Use them
by including the file in your code with the @code{include} special form.


@menu
* chicken-more-macros.scm::     
* chicken-ffi-macros.scm::      
@end menu


@node  chicken-more-macros.scm
@section @code{chicken-more-macros.scm}

This file contains the definitions of all non-standard syntax forms.
You normally don't use this file directly, unless you have the following
situation: you use non-standard macros at run-time (in evaluated code)
in a compiled program and you want non-standard syntax to be available. In this case, add 

@lisp
(require-extension chicken-more-macros)
@end lisp

to your code. This will load the definitions for non-standard macros available in
code evaluated by the program.

See also the FAQ for a discussion about the different macro systems and their 
ideosyncrasies.


@node  chicken-ffi-macros.scm
@section @code{chicken-ffi-macros.scm}

This file contains the definitions of macros for interfacing to foreign code,
and the definitions contained in this file are automatically made
available in compiled code.


@node Data Representation
@chapter Data Representation


There exist two different kinds of data objects in the CHICKEN system:
immediate and non-immediate objects. Immediate objects are represented
by a tagged machine word, which is usually of 32 bits length (64 bits
on 64-bit architectures). The immediate objects come in four different
flavors:

@itemize

@item @b{fixnums}, that is, small exact integers, distinguished by
the lowest order bit in the machine word set to 1. This gives fixnums
a range of 31 bits for the actual numeric value (63 bit on 64 bit
architectures).

@item @b{characters}, where the lowest four bits of machine words
containing characters are equal to @code{C_CHARACTER_BITS}. The
ASCII code of the character is encoded in bits 9 to 16, counting from
1 and starting at the lowest order position.

@item @b{booleans}, where the lowest four bits of machine words
containing booleans are equal to @code{C_BOOLEAN_BITS}. Bit 5
(counting from 0 and starting at the lowest order position) is one if
the boolean designates true, or 0 if it is false.

@item other values: the empty list, void and end-of-file. The lowest
four bits of machine words containing these values are equal to
@code{C_SPECIAL_BITS}. Bits 5 to 8 contain an identifying
number for this type of object.  The following constants are
defined: @code{C_SCHEME_END_OF_LIST C_SCHEME_UNDEFINED
C_SCHEME_END_OF_FILE}

@end itemize

Non-immediate objects are blocks of data represented by a pointer into
the heap. The first word of the data block contains a header, which gives
information about the type of the object. The header has the size of a
machine word, usually 32 bits (64 bits on 64 bit architectures).

@itemize

@item bits 1 to 24 (starting at the lowest order position) contain the
length of the data object, which is either the number of bytes in a
string (or byte-vector) or the the number of elements for a vector or
for a structure type.

@item bits 25 to 28 contain the type code of the object.

@item bits 29 to 32 contain miscellaneous flags used for garbage
collection or internal data type dispatching.
These flags are:
@table @code

@item C_GC_FORWARDING_BIT

Flag used for forwarding garbage collected object pointers.

@item C_BYTEBLOCK_BIT

Flag that specifies whether this data object contains raw bytes (a string
or byte-vector) or pointers to other data objects.

@item C_SPECIALBLOCK_BIT

Flag that specifies whether this object contains a ``special'' non-object
pointer value in its first slot. An example for this kind of objects
are closures, which are a vector-type object with the code-pointer as
the first item.

@item C_8ALIGN_BIT

Flag that specifies whether the data area of this block should be aligned
on an 8-byte boundary (floating-points numbers, for example).

@end table

@end itemize


The actual data follows immediately after the header. Note that
block-addresses are always aligned to the native machine-word
boundary. Scheme data objects map to blocks in the following manner:

@itemize

@item pairs: vector-like object (type bits @code{C_PAIR_TYPE}),
where the car and the cdr are contained in the first and second slots,
respectively.

@item vectors: vector object (type bits @code{C_VECTOR_TYPE}).

@item strings: byte-vector object (type bits @code{C_STRING_TYPE}).

@item procedures: special vector object (type bits
@code{C_CLOSURE_TYPE}). The first slot contains a pointer to a
compiled C function. Any extra slots contain the free variables (since
a flat closure representation is used).

@item flonum: a byte-vector object (type bits
@code{C_FLONUM_BITS}). Slots one and two (or a single slot on
64 bit architectures) contain a 64-bit floating-point number, in the
representation used by the host systems C compiler.

@item symbol: a vector object (type bits @code{C_SYMBOL_TYPE}). Slots
one and two contain the toplevel variable value and the print-name
(a string) of the symbol, respectively.

@item port: a special vector object (type bits
@code{C_PORT_TYPE}). The first slot contains a pointer to a file-
stream, if this is a file-pointer, or NULL if not. The other slots
contain housekeeping data used for this port.

@item structure: a vector object (type bits
@code{C_STRUCTURE_TYPE}). The first slot contains a symbol that
specifies the kind of structure this record is an instance of. The other
slots contain the actual record items.

@item pointer: a special vector object (type bits
@code{C_POINTER_TYPE}). The single slot contains a machine pointer.

@item tagged pointer: similar to a pointer (type bits 
@code{C_TAGGED_POINTER_TYPE}), but the object contains an additional
slot with a tag (an arbitrary data object) that identifies the type
of the pointer.

@end itemize


Data objects may be allocated outside of the garbage collected heap, as
long as their layout follows the above mentioned scheme. But care has to
be taken not to mutate these objects with heap-data (i.e. non-immediate
objects), because this will confuse the garbage collector.


For more information see the header file @code{chicken.h}.


@node Bugs and limitations
@chapter Bugs and limitations


@itemize

@item Compiling large files takes too much time.

@item If a known procedure has unused arguments, but is always called
without those parameters, then the optimizer ``repairs'' the procedure
in certain situations and removes the parameter from the lambda-list.

@item @code{port-position} currently works only for input ports.

@item Leaf routine optimization can theoretically result in code that
thrashes, if tight loops perform excessively many mutations.

@end itemize


@node FAQ
@chapter FAQ

@section General 

@itemize

@item Why yet another Scheme implementation?

   Since Scheme is a relatively simple language, a large number of implementations exist and
   each has its specific advantages and disadvantages. Some are fast, some provide a rich
   programming environment. Some are free, others are tailored to specific domains, and so on. The reasons
   for the existance of CHICKEN are:

   CHICKEN is portable because it generates C code that runs on a large number of platforms.

   CHICKEN is extendable, since its code generation scheme and runtime system/garbage collector fits
   neatly into a C environment.

   CHICKEN is free and can be freely distributed, including its source code.

   CHICKEN offers better performance than nearly all interpreter based implementations, but still
   provides full Scheme semantics.

   As far as I know, CHICKEN is the first implementation of Scheme that uses Henry Baker's
     ``Cheney on the M.T.A'' concept.

@item What to do if I find a bug?

   Send e-mail to @code{felix@@call-with-current-continuation.org}
   with some hints about the problem, like
   version/build of the compiler, platform, system configuration, code that
   causes the bug, etc.


@item Why are values defined with @code{define-foreign-variable} or @code{define-constant} or @code{define-inline} not seen outside of the containing source file?

  Accesses to foreign variables are translated directly into C constructs that access the variable,
  so the Scheme name given to that variable does only exist during compile-time.
  The same goes for constant- and inline-definitions: The name is only there to tell the compiler
  that this reference is to be replaced with the actual value.


@item How does @code{cond-expand} know which features are registered in used units?

   Each unit used via @code{(declare (uses ...))} is registered as a feature and
   so a symbol with the unit-name can be tested by @code{cond-expand} during macro-expansion-time.
   Features registered using the @code{register-feature!} procedure are only
   available during run-time of the compiled file. You can use the @code{eval-when} form
   to register features at compile time.


@item How can I cut down the size of an executable?

   If you don't need @code{eval} or the stuff in the @code{extras} library unit, 
   you can just use the @code{library} unit:

@verbatim
	(declare (uses library))
	(display "Hello, world!\n")
@end verbatim

   (Don't forget to compile with the @code{-explicit-use} option)
   Compiled with Visual C++ this generates an excutable of around 240 kilobytes.
   It is theoretically possible to compile something without the library, but
   a program would have to implement quite a lot of support code on its own.


@item Why does a loop that doesn't @code{cons} still trigger garbage collections?

   Under CHICKENs implementation policy, tail recursion is achieved simply by avoiding to
   return from a function call. Since the programs is CPS converted, a continuous 
   sequence of nested procedure calls is performed. At some stage the stack-space
   has to run out and the current procedure and its parameters (including the current continuation) are stored somewhere
   in the runtime system. Now a minor garbage collection occurs and rescues all live
   data from the stack (the first heap generation) and moves it into the the second heap generation. Than the stack is cleared (using
   a @code{longjmp}) and execution can continue from the saved state.
   With this method arbitrary recursion (in tail- or non-tail position) can happen, 
   provided the application doesn't run out of heap-space.
   (The difference between a tail- and a non-tail call is that the tail-call has no
   live data after it invokes its continuation - and so the amount of heap-space needed stays constant)


@item How can I obtain faster executables?

   There are a number of declaration specifiers that should be used to speed up
   compiled files: declaring @code{(standard-bindings)} is mandatory, since this enables
   most optimizations. Even if some standard procedures should be redefined, you can
   list untouched bindings in the declaration.
   Declaring @code{(extended-bindings)} lets the compiler choose faster versions of certain
   internal library functions. This might give another speedup. You can also use the
   the @code{usual-integrations} declaration, which is identical to declaring
   @code{standard-bindings} and @code{extended-bindings}
   (note that @code{usual-integrations} is set by default).
   Declaring @code{(block)} tells the compiler that global procedures are not changed
   outside the current compilation unit, this gives the compiler some more 
   opportunities for optimization.
   If no floating point arithmetic is required, then declaring @code{(number-type fixnum)}
   can give a big performance improvement, because the compiler can now inline
   most arithmetic operations. 
   Declaring @code{(unsafe)} will switch off most safety checks.
   If threads are not used, you can declare @code{(disable-interrupts)}.
   You should always use maximum optimizations settings for your C compiler.
   Good GCC compiler options on Pentium (and compatible) hardware are:
   @code{-Os -fomit-frame-pointer -fno-strict-aliasing}
   Some programs are very sensitive to the setting of the nursery (the first heap-generation). You
   should experiment with different nursery settings (either by compiling with the @code{-nursery}
   option or by using the @code{-:s...} runtime option).


@item Why does the linker complain about a missing function @code{_C_..._toplevel}?

   This message indicates that your program uses a library-unit, but that the
   object-file or library was not supplied to the linker. If you have the unit
   @code{foo}, which is contained in @code{foo.o} than you have to supply it to the
   linker like this (assuming a GCC environment):

@verbatim
   % csc program.scm foo.o -o program
@end verbatim


@item Why does the linker complain about a missing function @code{_C_toplevel}?

   This means you have compiled a library unit as an application. When a unit-declaration (as in @code{(declare (unit ...))})
   is given, then this file has a specially named toplevel entry procedure. Just remove the declaration,
   or compile this file to an object-module and link it to your application code.


@item Why are constants defined by @code{define-constant} not honoured in @code{case} constructs?

   @code{case} expands into a cascaded @code{if} expression, where the first item in each arm
   is treated as a quoted list. So the @code{case} macro can not infer wether
   a symbol is to be treated as a constant-name (defined via @code{define-constant}) or
   a literal symbol.


@item When I compile a file with @code{-unsafe} or unsafe declarations, it crashes during execution.

   The compiler option @code{-unsafe} or the declaration @code{(declare (unsafe))} disable
   certain safety-checks to improve performance, so code that would normally
   trigger an error will work unexpectedly or even crash the running application.
   It is advisable to develop and debug a program in safe mode (without unsafe
   declarations) and use this feature only if the application works properly.


@item Which non-standard procedures are treated specially when the @code{extended-bindings} or @code{usual-integrations} declaration or compiler option is used?

  The following extended bindings are handled specially: 

@code{bitwise-and} @code{bitwise-ior} @code{bitwise-xor} @code{bitwise-not} @code{add1} @code{sub1}
 @code{fx+}
@code{fx-} @code{fx*} @code{fx/} @code{fxmod}
  @code{fx=} @code{fx>} @code{fx>=} @code{fixnum?} @code{fxneg} @code{fxmax} @code{fxmin}
@code{fxand} @code{fxior} @code{fxxor} @code{fxnot} @code{fxshl} @code{fxshr}
@code{fp+}
@code{fp-} @code{fp*} @code{fp/} @code{atom?}
  @code{fp=} @code{fp>} @code{fp>=} @code{fpneg} @code{fpmax} @code{fpmin}
  @code{arithmetic-shift} @code{signum} @code{flush-output} @code{thread-specific} @code{thread-specific-set!}
  @code{not-pair?} @code{null-list?} @code{print} @code{print*} @code{u8vector->bytevector}
  @code{s8vector->bytevector} @code{u16vector->bytevector} @code{s16vector->bytevector}
  @code{u32vector->bytevector}
  @code{s32vector->bytevector} @code{f32vector->bytevector} @code{f64vector->bytevector} @code{block-ref}
  @code{byte-vector-length}
  @code{u8vector-length}
  @code{s8vector-length}
  @code{u16vector-length}
  @code{s16vector-length}
  @code{u32vector-length}
  @code{s32vector-length}
  @code{f32vector-length}
  @code{f64vector-length}
  @code{u8vector-ref}
  @code{s8vector-ref}
  @code{u16vector-ref}
  @code{s16vector-ref}
  @code{u32vector-ref}
  @code{s32vector-ref}
  @code{f32vector-ref}
  @code{f64vector-ref}
  @code{u8vector-set!}
  @code{s8vector-set!}
  @code{u16vector-set!}
  @code{s16vector-set!}
  @code{u32vector-set!}
  @code{s32vector-set!}
  @code{hash-table-ref}
   @code{block-set!} @code{number-of-slots}
    @code{first} @code{second} @code{third} @code{fourth} @code{null-pointer?} @code{pointer->object}
    @code{make-record-instance}
   @code{locative-ref} @code{locative-set!} @code{locative?} @code{locative->object} @code{identity}
    @code{cpu-time} @code{error} @code{call/cc}


@item Why does @code{define-reader-ctor} not work in my compiled program?

  The following piece of code does not work as expected:

@lisp
(eval-when (compile)
  (define-reader-ctor 'integer->char integer->char) )
(print #,(integer->char 33))
@end lisp

  The problem is that the compiler reads the complete source-file before doing any processing on it,
  so the sharp-comma form is encountered before the reader-ctor is defined. A possible solution is to include
  the file containing the sharp-comma form, like this:

@lisp
(eval-when (compile)
  (define-reader-ctor 'integer->char integer->char) )

(include "other-file")
@end lisp

@lisp
;;; other-file.scm:
(print #,(integer->char 33))
@end lisp


@item Why do I get a warning when I define a global variable named @code{match}?

  Even when the @code{match} unit is not used, the macros from that package are visible in the compiler.
  The reason for this is that macros can not be accessed from library units (only when explicitly evaluated in running
  code). To speed up macro-expansion time, the compiler and the interpreter both already provide the compiled 
  @code{match-...} macro definitions. Macros shadowed lexically are no problem, but global definitions
  of variables named identically to (global) macros are useless - the macro definition shadows the global
  variable.
  This problem can be solved in one of three ways:
  
  - Use a different name
  
  - Undefine the macro, like this:

@lisp
(eval-when (compile eval) (undefine-macro! 'match))
@end lisp  


@item How can I enable case sensitive reading/writing in user code?

  To enable the @code{read} procedure to read symbols and identifiers case sensitive, you can set the
  parameter @code{case-sensitivity} to @code{#t}.


@item When I use callback functions (from Scheme to C and back to Scheme again), I get weird crashes.

  There are two reasons why code involving callbacks can crash out of know apparent reason. The first is that it is
  important to use @code{foreign-safe-lambda/foreign-safe-lambda*} for the C code that is
  to call back into Scheme. If this is not done than sooner or later the available stack space will be exhausted.
  The second reason is that if the C code uses a large amount of stack storage, or if Scheme-to-C-to-Scheme calls are
  nested deeply, then the available nursery space on the stack will run low. To avoid this it might be advisable
  to run the compiled code with a larger nursery setting, i.e. run the code with @code{-:s...} and a larger
  value than the default (for example @code{-:s300k}), or use the @code{-nursery} compiler option.
  Note that this can decrease runtime performance on some platforms.


@item How can I change @code{match-error-control} during compilation?

  Use @code{eval-when}, like this:

  @lisp
  (eval-when (compile)
    (match-error-control #:unspecified) )
  @end lisp


@item Why doesn't CHICKEN support the full numeric tower by default?

  The short answer:

  @lisp
  % chicken-setup numbers
  % csi -q
  #;1> (use numbers)
  @end lisp

  The long answer:

  There are a number of reasons for this:
  
  - For most applications of Scheme fixnums (exact word-sized integers) and flonums (64-bit floating-point
   numbers) are more than sufficient;
  
  - Interfacing to C is simpler;
  
  - Dispatching of arithmetic operations is more efficient.

  There is an extension based on the GNU Multiprecision Package that implements most of the full
  numeric tower, see http://www.call-with-current-continuation.org/eggs/numbers.html.
  

@item Toplevel-continuations captured in interpreted code don't seem to work.

  Consider the following piece of code:

@lisp  
  (define k (call-with-current-continuation (lambda (k) k)))
  (k k)
@end lisp

  When compiled, this will loop endlessly. But when interpreted, @code{(k k)} will return
  to the read-eval-print loop! This happens because the continuation captured will eventually read the
  next toplevel expression from the standard-input (or an input-file if loading from a file). At the moment
  @code{k} was defined, the next expression was @code{(k k)}. But when @code{k}
  is invoked, the next expression will be whatever follows after @code{(k k)}.
  In other words, invoking a captured continuation will not rewind the file-position of the input source.
  A solution is to wrap the whole code into a @code{(begin ...)} expression, so all toplevel
  expressions will be loaded together.


@item How can I specialize a generic function method to match instances of every class?

  Specializing a method on @code{<object>} doesn't work on primitive data objects like
  numbers, strings, etc. so for example

@lisp
  (define-method (foo (x <my-class>)) ...)
  (define-method (foo (x <object>)) ...)
  (foo 123)
@end lisp

  will signal an error, because to applicable method can be found. To specialize a method for primitive
  objects, use @code{<top>}:

@lisp
  (define-method (foo (x <top>)) ...)
@end lisp


@item Does CHICKEN support native threads?

  Currently native threads are not supported. The runtime system is not reentrant, and the garbage-collection
  algorithm would be made much more complicated, since the location of every object (whether it is allocated
  on the stack or on the heap or completely outside the GC-able data space) has to be checked - this would
  be rather complex and inefficient in a situation where multiple threads are involved.


@end itemize


@section Platform specific


@itemize

@item How do I generate a DLL under MS Windows (tm) ?

   Use @code{csc} in combination with the @code{-dll} option:

@verbatim
   C:\> csc foo.scm -dll
@end verbatim

@item How do I generate a GUI application under Windows(tm)?

   Invoke @code{csc} with the @code{-windows} option. Or pass the @code{-DC_WINDOWS_GUI}
   option to the C compiler and link with the GUI version of the runtime system (that's @code{libchicken-gui[-static].lib}.
   The GUI runtime displays error messages in a message box and does some rudimentary command-line
   parsing.

@item Compiling very large files under Windows with the Microsoft C compiler fails with a message indicating insufficient heap space.

  It seems that the Microsoft C compiler can only handle files up to a certain size, and it doesn't utilize virtual memory as
  well as the GNU C compiler, for example. Try closing running applications. If that fails, try to break up the Scheme code
  into several library units.

@item When I run @code{csi} inside an emacs buffer under Windows, nothing happens.

  Invoke @code{csi} with the @code{-:c} runtime option. Under Windows the interpreter thinks it
  is not running under control of a terminal and doesn't print the prompt and does not flush the output stream properly.

@item I load compiled code dynamically in a Windows GUI application and it crashes.

  Code compiled into a DLL to be loaded dynamically must be linked with the same runtime system as the loading
  application. That means that all dynamically loaded entities (including extensions built and installed with
  @code{chicken-setup}) must be compiled with the @code{-windows} @code{csc} option.

@item On Windows, @code{csc.exe} seems to be doing something wrong.

  The Windows development tools include a C# compiler with the same name. Either invoke @code{csc.exe} with a full
  pathname, or put the directory where you installed CHICKEN in front of the MS development tool path in the @code{PATH}
  environment variable.

@end itemize


@section Customization


@itemize

@item How do I run custom startup code before the runtime-system is invoked?

   When you invoke the C compiler for your translated Scheme source program, add the C compiler option
   @code{-DC_EMBEDDED}, or pass @code{-embedded} to the @code{csc}
   driver program, so no entry-point function will be generated (@code{main()}).
   When your are finished with your startup processing, invoke:

@verbatim
   CHICKEN_main(argc, argv, C_toplevel);
@end verbatim

  where @code{C_toplevel} is the entry-point into the compiled Scheme code. You
  should add the following  declarations at the head of your code:

@verbatim
  #include "chicken.h"
  extern void C_toplevel(C_word,C_word,C_word) C_noret;
@end verbatim

@item How can I add compiled user passes?

  To add a compiled user pass instead of an interpreted one, create a library unit and recompile
  the main unit of the compiler (in the file @code{chicken.scm}) with an additional @code{uses}
  declaration. Then link all compiler modules and your (compiled) extension to create a new version of
  the compiler, like this (assuming all sources are in the
  current directory):

@verbatim
  % cat userpass.scm
  ;;;; userpass.scm - My very own compiler pass

  (declare (unit userpass))

  ;; Perhaps more user passes/extensions are added:
  (let ([old (user-pass)])
    (user-pass
      (lambda (x)
        (let ([x2 (do-something-with x)])
	  (if old
	      (old x2)
	      x2) ) ) ) )
  ...
  % csc -c -x userpass.scm
  % csc chicken.scm -c -o chicken-extended.o -uses userpass
  % gcc chicken-extended.o support.o easyffi.o compiler.o optimizer.o batch-driver.o c-platform.o \
    c-backend.o userpass.o `csc -ldflags -libs` -o chicken-extended
@end verbatim

  On platforms that support it (Linux ELF, Solaris, Windows + VC++), compiled code can be loaded via @code{-extend}
  just like source files (see @code{load} in the User's Manual).

@end itemize


@section Macros

@itemize

@item Why doesn't my fancy macro work in compiled code?

   Macro bodies that are defined and used in a compiled source-file are
   evaluated during compilation and so have no access to definitions in the
   compiled file. Note also that during compile-time macros are only available in
   the same source file in which they are defined. Files included via @code{include}
   are considered part of the containing file.

@item Why are macros not visible outside of the compilation unit in which they are defined?

   Macros are defined during compile time, so when a file has been compiled, the definitions are gone. An exception
   to this rule are macros defined with @code{define-macro}, which are also visible at run-time, i.e.
   in @code{eval}. To use macros defined in other files, use the @code{include} special
   form.

@end itemize


@node Acknowledgements
@chapter Acknowledgements


Also many thanks to
Nico Amtsberg, William Annis, Marc Baily, Peter Barabas, Jonah Beckford, Arto Bendiken, Peter Bex, Jean-Fran@,{c}ois Bignolles, Dave Bodenstab, 
Fabian B@"ohlke, T. Kurt Bond, 
Ashley Bone, Dominique Boucher, 
Terence Brannon, Roy Bryant, Adam Buchbinder, Hans Bulfone, Category 5, Taylor Campbell, Franklin Chen, 
Thomas Chust, Gian Paolo Ciceri, 
John Cowan, Grzegorz Chrupa@l{}a,
James Crippen, Tollef Fog Heen, Alejandro Forero Cuervo, Linh Dang,
Brian Denheyer, Chris Double, Jarod Eells, Petter Egesund, Steve Elkins, Daniel B. Faken, Graham Fawcett, Fizzie, Kimura Fuyuki, 
Tony Garnock-Jones, Martin Gasbichler, 
Joey Gibson, 
Johannes Gr@o{}dem, Damian Gryski, Mario Domenech Goulart, Andreas Gustafsson, Sven Hartrumpf,
Jun-ichiro itojun Hagino, Matthias Heiler, Karl M. Hegbloom, William P. Heinemann, Bill Hoffman, Bruce Hoult, Hans H@"ubner,
Markus H@"ulsmann, Goetz Isenmann,
David Janssens, Christian Jaeger, Dale Jordan, Valentin Kamyshenko, Daishi Kato, Peter Keller, 
Ron Kneusel, Matthias Koeppe, Krysztof Kowa@l{}czyk, Todd R. Kueny Sr, Goran Krampe, Micky Latowicki, John Lenz, Kirill Lisovsky, 
Kon Lovett, Dennis Marti, Charles Martin, Bob McIsaac, Alain Mellan, 
Eric Merrit, Perry Metzger,
Scott G. Miller, Mikael, Bruce Mitchener, Chris Moline,
Eric E. Moore, Julian Morrison, Dan Muresan, Lars Nilsson, Ian Oversby, o.t., Gene Pavlovsky, Levi Pearson, Nicolas Pelletier, Carlos Pita, 
Pupeno, Davide Puricelli, Doug Quale, 
Eric Raible, Joel Reymont, Andreas Rottman, David Rush, Lars Rustemeier, Oskar Schirmer, Burton Samograd, 
Reed Sheridan, Ronald Schr@"oder,
Spencer Schumann, Alex Shinn, Shmul, Jeffrey B. Siegal, Andrey Sidorenko, Michele Simionato, Volker Stolz, Dorai Sitaram, 
Robert Skeels, Jason Songhurst, Clifford Stein, Sunnan, Zbigniew Szadkowski, Mike Thomas, Christian Tismer, 
Andre van Tonder, John Tobey, Henrik Tramberend, 
Vladimir Tsichevsky, 
Neil van Dyke, Sander Vesik, Panagiotis Vossos, Shawn Wagner, Peter Wang,
Ed Watkeys, Thomas Weidner, Matthew Welland, Joerg Wittenberger, Peter Wright, Mark Wutka,
Richard Zidlicky and Houman Zolfaghari for bug-fixes, tips and suggestions.

Special thanks to Brandon van Every for contributing the CMake (http://www.cmake.org) support and for helping
with Windows build issues.

Also special thanks to Benedikt Rosenau for his constant encouragement.

CHICKEN contains code from several people:

@itemize
@item Eli Barzilay: some performance tweaks used in TinyCLOS.
@item Mikael Djurfeldt: topological sort used by compiler.
@item Marc Feeley: pretty-printer.
@item Aubrey Jaffer: implementation of @code{dynamic-wind}.
@item Gregor Kiczales: original implementation of TinyCLOS.
@item Richard O'Keefe: sorting routines.
@item Olin Shivers: implementation of @code{let-optionals[*]} and
reference implementations of SRFI-1, SRFI-13 and SRFI-14.
@item Dorai Sitaram: the PREGEXP regular expression package
@item Andrew Wilcox: queues.
@item Andrew Wright: pattern matcher.
@end itemize



@node Bibliography
@unnumbered Bibliography

@table @asis
@item Henry Baker: @emph{CONS Should Not CONS Its Arguments, Part II: Cheney on the M.T.A.}
@code{http://home.pipeline.com/\~hbaker1/CheneyMTA.html}
@item Revised^5 Report on the Algorithmic Language Scheme
@code{http://www.schemers.org/Documents/Standards/R5RS}
@end table

@node Index
@unnumbered Index
@printindex fn

@bye
