;;; scheme-complete.el              -*- Emacs-Lisp -*-

;;; Smart tab completion for Emacs

;;; This code is written by Alex Shinn and placed in the Public
;;; Domain.  All warranties are disclaimed.

;;; This file provides a single function, `scheme-smart-complete',
;;; which you can use for intelligent, context-sensitive completion
;;; for any Scheme implementation.  To use it just load this file and
;;; bind that function to a key in your preferred mode:
;;;
;;; (autoload 'scheme-smart-complete "scheme-complete" nil t)
;;; (eval-after-load 'scheme
;;;   '(progn (define-key scheme-mode-map "\e\t" 'scheme-smart-complete)))
;;;
;;; Alternately, you may want to just bind TAB to the
;;; `scheme-complete-or-indent' function, which indents at the start
;;; of a line and otherwise performs the smart completion:
;;;
;;; (eval-after-load 'scheme
;;;   '(progn (define-key scheme-mode-map "\t" 'scheme-complete-or-indent)))
;;;
;;; If you use eldoc-mode (included in Emacs), you can also get live
;;; scheme documentation with:
;;;
;;; (add-hook 'scheme-mode-hook
;;;   (lambda ()
;;;     (setq eldoc-info-function 'scheme-get-current-symbol-info)
;;;     (eldoc-mode)))
;;;
;;; That's all there is to it.

;;; History:
;;;   0.1: 2007/09/11 - initial release
;;;
;;;   What is this talk of 'release'? Klingons do not make software
;;;   'releases'. Our software 'escapes' leaving a bloody trail of
;;;   designers and quality assurance people in its wake.

(require 'cl)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; info

(defvar *scheme-r5rs-info*
  '((define (:syntax identifier value) () nil "define a new variable")
    (set! (:syntax identifier value) () nil "set the value of a variable")
    (let (:syntax vars body ...) () nil "bind new local variables in parallel")
    (let* (:syntax vars body ...) () nil "bind new local variables sequentially")
    (letrec (:syntax vars body ...) () nil "bind new local variables recursively")
    (lambda (:syntax params body ...) () nil "procedure syntax")
    (if (:syntax cond then else) () nil "conditional evaluation")
    (cond (:syntax clause ...) () nil "try each clause until one succeeds")
    (case (:syntax expr clause ...) () nil "look for EXPR among literal lists")
    (delay (:syntax expr) () nil "create a promise to evaluate EXPR")
    (and (:syntax expr ...) () nil "evaluate EXPRs while true, return last")
    (or (:syntax expr ...) () nil "return the first true EXPR")
    (begin (:syntax expr ...) () nil "evaluate each EXPR in turn and return the last")
    (do (:syntax vars finish body ...) () nil "simple iterator")
    (quote (:syntax expr) () nil "represent EXPR literally without evaluating it")
    (quasiquote (:syntax expr) () nil "quote literals allowing escapes")
    (unquote (:syntax expr) () nil "escape an expression inside quasiquote")
    (unquote-splicing (:syntax expr) () nil "escape and splice a list expression inside quasiquote")
    (define-syntax (:syntax identifier body ...) () nil "create a macro")
    (let-syntax (:syntax syntaxes body ...) () nil "a local macro")
    (letrec-syntax (:syntax syntaxes body ...) () nil "a local macro")
    (syntax-rules (:syntax literals clauses ...) () nil "simple macro language")
    (eqv? (obj1 obj2) () nil "returns #t if OBJ1 and OBJ2 are the same object")
    (eq? (obj1 obj2) () nil "finer grained version of EQV?")
    (equal? (obj1 obj2) () nil "recursive equivalence")
    (not (obj) () nil "returns #t iff OBJ is false")
    (boolean? (obj) () nil "returns #t iff OBJ is #t or #f")
    (number? (obj) () nil "returns #t iff OBJ is a number")
    (complex? (obj) () nil "returns #t iff OBJ is a complex number")
    (real? (obj) () nil "returns #t iff OBJ is a real number")
    (rational? (obj) () nil "returns #t iff OBJ is a rational number")
    (integer? (obj) () nil "returns #t iff OBJ is an integer")
    (exact? (z) () nil "returns #t iff Z is exact")
    (inexact? (z) () nil "returns #t iff Z is inexact")
    (= (z1 z2 ...) () nil "returns #t iff the arguments are all equal")
    (< (x1 x2 ...) () nil "returns #t iff the arguments are monotonically increasing")
    (> (x1 x2 ...) () nil "returns #t iff the arguments are monotonically decreasing")
    (<= (x1 x2 ...) () nil "returns #t iff the arguments are monotonically nondecreasing")
    (>= (x1 x2 ...) () nil "returns #t iff the arguments are monotonically nonincreasing")
    (zero? (z) ())
    (positive? (x))
    (negative? (x))
    (odd? (n))
    (even? (n))
    (max (x1 x2 ...) () nil "returns the maximum of the arguments")
    (min (x1 x2 ...) () nil "returns the minimum of the arguments")
    (+ (z1 ...))
    (* (z1 ...))
    (- (z1 ...))
    (/ (z1 ...))
    (abs (x) () nil "returns the absolute value of X")
    (quotient (n1 n2) () nil "integer division")
    (remainder (n1 n2) () nil "same sign as N1")
    (modulo (n1 n2) () nil "same sign as N2")
    (gcd (n1 ...) () nil "greatest common divisor")
    (lcm (n2 ...) () nil "least common multiple")
    (numerator (rational))
    (denominator (rational))
    (floor (x) () nil "largest integer not larger than X")
    (ceiling (x) () nil "smallest integer not smaller than X")
    (truncate (x) () nil "drop fractional part")
    (round (x) () nil "round to even (banker's rounding)")
    (rationalize (x y) () nil "rational number differing from X by at most Y")
    (exp (z) () nil "e^Z")
    (log (z) () nil "natural logarithm of Z")
    (sin (z) () nil "sine function")
    (cos (z) () nil "cosine function")
    (tan (z) () nil "tangent function")
    (asin (z) () nil "arcsine function")
    (acos (z) () nil "arccosine function")
    (atan (z) () nil "arctangent function")
    (sqrt (z) () nil "principal square root of Z")
    (expt (z1 z2) () nil "returns Z1 raised to the Z2 power")
    (make-rectangular (x1 x2) () nil "create a complex number")
    (make-polar (x1 x2) () nil "create a complex number")
    (real-part (z))
    (imag-part (z))
    (magnitude (z))
    (angle (z) ())
    (exact->inexact (z))
    (inexact->exact (z))
    (number->string (z :optional radix))
    (string->number (str :optional radix))
    (pair? (obj) () nil "returns #t iff OBJ is a pair")
    (cons (obj1 obj2) () nil "create a newly allocated pair")
    (car (pair))
    (cdr (pair))
    (set-car! (pair obj))
    (set-cdr! (pair obj))
    (caar (pair))
    (cadr (pair))
    (cdar (pair))
    (cddr (pair))
    (caaar (pair))
    (caadr (pair))
    (cadar (pair))
    (caddr (pair))
    (cdaar (pair))
    (cdadr (pair))
    (cddar (pair))
    (cdddr (pair))
    (caaaar (pair))
    (caaadr (pair))
    (caadar (pair))
    (caaddr (pair))
    (cadaar (pair))
    (cadadr (pair))
    (caddar (pair))
    (cadddr (pair))
    (cdaaar (pair))
    (cdaadr (pair))
    (cdadar (pair))
    (cdaddr (pair))
    (cddaar (pair))
    (cddadr (pair))
    (cdddar (pair))
    (cddddr (pair))
    (null? (obj) () nil "returns #t iff OBJ is the empty list")
    (list? (obj) () nil "returns #t iff OBJ is a proper list")
    (list (obj ...) () nil "returns a newly allocated list")
    (length (list))
    (append (list ...) () nil "concatenates the list arguments")
    (reverse (list))
    (list-tail (list k) () nil "returns the Kth cdr of LIST")
    (list-ref (list k) () nil "returns the Kth element of LIST")
    (memq (obj list) () nil "the sublist of LIST whose car is eq? to OBJ")
    (memv (obj list) () nil "the sublist of LIST whose car is eqv? to OBJ")
    (member (obj list) () nil "the sublist of LIST whose car is equal? to OBJ")
    (assq (obj list) () nil "the element of LIST whose car is eq? to OBJ")
    (assv (obj list) () nil "the element of LIST whose car is eqv? to OBJ")
    (assoc (obj list) () nil "the element of LIST whose car is equal? to OBJ")
    (symbol? (obj) () nil "returns #t iff OBJ is a symbol")
    (symbol->string (symbol))
    (string->symbol (str))
    (char? (obj) () nil "returns #t iff OBJ is a character")
    (char=? (ch1 ch2))
    (char<? (ch1 ch2))
    (char>? (ch1 ch2))
    (char<=? (ch1 ch2))
    (char>=? (ch1 ch2))
    (char-ci=? (ch1 ch2))
    (char-ci<? (ch1 ch2))
    (char-ci>? (ch1 ch2))
    (char-ci<=? (ch1 ch2))
    (char-ci>=? (ch1 ch2))
    (char-alphabetic? (ch))
    (char-numeric? (ch))
    (char-whitespace? (ch))
    (char-upper-case? (ch))
    (char-lower-case? (ch))
    (char->integer (ch))
    (integer->char (int))
    (char-upcase (ch))
    (char-downcase (ch))
    (string? (obj) () nil "returns #t iff OBJ is a string")
    (make-string (k :optional ch) () nil "a new string of length k")
    (string (ch ...) () nil "a new string made of the char arguments")
    (string-length (str) () nil "the number of characters in STR")
    (string-ref (str i) () nil "the Ith character of STR")
    (string-set! (str i ch) () nil "set the Ith character of STR to CH")
    (string=? (str1 str2))
    (string-ci=? (str1 str2))
    (string<? (str1 str2))
    (string>? (str1 str2))
    (string<=? (str1 str2))
    (string>=? (str1 str2))
    (string-ci<? (str1 str2))
    (string-ci>? (str1 str2))
    (string-ci<=? (str1 str2))
    (string-ci>=? (str1 str2))
    (substring (str start end))
    (string-append (str ...) () nil "concatenate the string arguments")
    (string->list (str))
    (list->string (list))
    (string-copy (str))
    (string-fill! (str ch) () nil "set every char in STR to CH")
    (vector? (obj) () nil "returns #t iff OBJ is a vector")
    (make-vector (len :optional fill) () nil "a new vector of K elements")
    (vector (obj ...))
    (vector-length (vec) () nil "the number of elements in VEC")
    (vector-ref (vec i) () nil "the Ith element of VEC")
    (vector-set! (vec i obj) () nil "set the Ith element of VEC to OBJ")
    (vector->list (vec))
    (list->vector (list))
    (vector-fill! (vec obj) () nil "set every element in VEC to OBJ")
    (procedure? (obj) () nil "returns #t iff OBJ is a procedure")
    (apply (proc obj ...) () nil "procedure application")
    (map (proc list) () nil "a new list of PROC applied to every element of LIST")
    (for-each (proc list) () nil "apply PROC to each element of LIST in order")
    (force (promise) () nil "force the delayed value of PROMISE")
    (call-with-current-continuation (proc) () nil "goto on steroids")
    (values (obj ...) () nil "send multiple values to the calling continuation")
    (call-with-values (producer consumer))
    (dynamic-wind (before-thunk thunk after-thunk))
    (scheme-report-environment (int) () nil "INT should be 5")
    (null-environment (int) () nil "INT should be 5")
    (call-with-input-file (path proc))
    (call-with-output-file (path proc))
    (input-port? (obj) () nil "returns #t iff OBJ is an input port")
    (output-port? (obj) () nil "returns #t iff OBJ is an output port")
    (current-input-port () () nil "the default input for read procedures")
    (current-output-port () () nil "the default output for write procedures")
    (with-input-from-file (path thunk))
    (with-output-to-file (path thunk))
    (open-input-file (path))
    (open-output-file (path))
    (close-input-port (input-port))
    (close-output-port (output-port))
    (read (:optional input-port) () nil "read a datum")
    (read-char (:optional input-port) () nil "read a single character")
    (peek-char (:optional input-port))
    (eof-object? (obj) () nil "returns #t iff OBJ is the end-of-file object")
    (char-ready? (:optional input-port))
    (write (object :optional output-port) () nil "write a datum")
    (display (object :optional output-port) () nil "display")
    (newline (:optional output-port) () nil "send a linefeed")
    (write-char (char :optional output-port) () nil "write a single character")
  ))

(defvar *scheme-srfi-info*
  [
   ;; SRFI 0
   ("Feature-based conditional expansion construct"
    (cond-expand (:syntax)))
   
   ;; SRFI 1
   ("List Library"
    (xcons (object object))
    (cons* (object ...))
    (make-list (integer :optional object))
    (list-tabulate (integer procedure))
    (list-copy (list))
    (circular-list (object ...))
    (iota (integer :optional integer integer))
    (proper-list? (object))
    (circular-list? (object))
    (dotted-list? (object))
    (not-pair? (object))
    (null-list? (object))
    (list= (procedure list ...))
    (first (pair))
    (second (pair))
    (third (pair))
    (fourth (pair))
    (fifth (pair))
    (sixth (pair))
    (seventh (pair))
    (eighth (pair))
    (ninth (pair))
    (tenth (pair))
    (car+cdr (pair))
    (take (pair integer))
    (drop (pair integer))
    (take-right (pair integer))
    (drop-right (pair integer))
    (take! (pair integer))
    (drop-right! (pair integer))
    (split-at (pair integer))
    (split-at! (pair integer))
    (last (pair))
    (last-pair (pair))
    (length+ (object))
    (concatenate (list))
    (append! (list ...))
    (concatenate! (list))
    (reverse! (list))
    (append-reverse (list list))
    (append-reverse! (list list))
    (zip (list ...))
    (unzip1 (list))
    (unzip2 (list))
    (unzip3 (list))
    (unzip4 (list))
    (unzip5 (list))
    (count (procedure list ...))
    (fold (procedure object list ...))
    (unfold (procedure procedure procedure object :optional procedure))
    (pair-fold (procedure object list ...))
    (reduce (procedure object list ...))
    (fold-right (procedure object list ...))
    (unfold-right (procedure procedure procedure object :optional object))
    (pair-fold-right (procedure object list ...))
    (reduce-right (procedure object list ...))
    (append-map (procedure list ...))
    (append-map! (procedure list ...))
    (map! (procedure list ...))
    (pair-for-each (procedure list ...))
    (filter-map (procedure list ...))
    (map-in-order (procedure list ...))
    (filter (procedure list))
    (partition (procedure list))
    (remove (procedure list))
    (filter! (procedure list))
    (partition! (procedure list))
    (remove! (procedure list))
    (find (procedure list))
    (find-tail (procedure list))
    (any (procedure list ...))
    (every (procedure list ...))
    (list-index (procedure list ...))
    (take-while (procedure list))
    (drop-while (procedure list))
    (take-while! (procedure list))
    (span (procedure list))
    (break (procedure list))
    (span! (procedure list))
    (break! (procedure list))
    (delete (object list :optional procedure))
    (delete-duplicates (list :optional procedure))
    (delete! (object list :optional procedure))
    (delete-duplicates! (list :optional procedure))
    (alist-cons (object object list))
    (alist-copy (list))
    (alist-delete (object list))
    (alist-delete! (object list))
    (lset<= (procedure list ...))
    (lset= (procedure list ...))
    (lset-adjoin (procedure list object ...))
    (lset-union (procedure list ...))
    (lset-union! (procedure list ...))
    (lset-intersection (procedure list ...))
    (lset-intersection! (procedure list ...))
    (lset-difference (procedure list ...))
    (lset-difference! (procedure list ...))
    (lset-xor (procedure list ...))
    (lset-xor! (procedure list ...))
    (lset-diff+intersection (procedure list ...))
    (lset-diff+intersection! (procedure list ...))

    )

   ;; SRFI 2
   ("AND-LET*: an AND with local bindings, a guarded LET* special form"
    (and-let* (:syntax)))

   ()

   ;; SRFI 4
   ("Homogeneous numeric vector datatypes"

    (u8vector? (obj))
    (make-u8vector (size integer))
    (u8vector (integer ...))
    (u8vector-length (u8vector))
    (u8vector-ref (u8vector i))
    (u8vector-set! (u8vector i u8value))
    (u8vector->list (u8vector))
    (list->u8vector (list))

    (s8vector? (obj))
    (make-s8vector (size integer))
    (s8vector (integer ...))
    (s8vector-length (s8vector))
    (s8vector-ref (s8vector i))
    (s8vector-set! (s8vector i s8value))
    (s8vector->list (s8vector))
    (list->s8vector (list))

    (u16vector? (obj))
    (make-u16vector (size integer))
    (u16vector (integer ...))
    (u16vector-length (u16vector))
    (u16vector-ref (u16vector i))
    (u16vector-set! (u16vector i u16value))
    (u16vector->list (u16vector))
    (list->u16vector (list))

    (s16vector? (obj))
    (make-s16vector (size integer))
    (s16vector (integer ...))
    (s16vector-length (s16vector))
    (s16vector-ref (s16vector i))
    (s16vector-set! (s16vector i s16value))
    (s16vector->list (s16vector))
    (list->s16vector (list))

    (u32vector? (obj))
    (make-u32vector (size integer))
    (u32vector (integer ...))
    (u32vector-length (u32vector))
    (u32vector-ref (u32vector i))
    (u32vector-set! (u32vector i u32value))
    (u32vector->list (u32vector))
    (list->u32vector (list))

    (s32vector? (obj))
    (make-s32vector (size integer))
    (s32vector (integer ...))
    (s32vector-length (s32vector))
    (s32vector-ref (s32vector i))
    (s32vector-set! (s32vector i s32value))
    (s32vector->list (s32vector))
    (list->s32vector (list))

    (u64vector? (obj))
    (make-u64vector (size integer))
    (u64vector (integer ...))
    (u64vector-length (u64vector))
    (u64vector-ref (u64vector i))
    (u64vector-set! (u64vector i u64value))
    (u64vector->list (u64vector))
    (list->u64vector (list))

    (s64vector? (obj))
    (make-s64vector (size integer))
    (s64vector (integer ...))
    (s64vector-length (s64vector))
    (s64vector-ref (s64vector i))
    (s64vector-set! (s64vector i s64value))
    (s64vector->list (s64vector))
    (list->s64vector (list))

    (f32vector? (obj))
    (make-f32vector (size integer))
    (f32vector (number ...))
    (f32vector-length (f32vector))
    (f32vector-ref (f32vector i))
    (f32vector-set! (f32vector i f32value))
    (f32vector->list (f32vector))
    (list->f32vector (list))

    (f64vector? (obj))
    (make-f64vector (size integer))
    (f64vector (number ...))
    (f64vector-length (f64vector))
    (f64vector-ref (f64vector i))
    (f64vector-set! (f64vector i f64value))
    (f64vector->list (f64vector))
    (list->f64vector (list))
    )

   ;; SRFI 5
   ("A compatible let form with signatures and rest arguments"
    (let (:syntax)))

   ;; SRFI 6
   ("Basic String Ports"
    (open-input-string (string))
    (open-output-string ())
    (get-output-string (string-port)))

   ;; SRFI 7
   ("Feature-based program configuration language"
    (program (:syntax))
    (feature-cond (:syntax)))

   ;; SRFI 8
   ("receive: Binding to multiple values"
    (receive (:syntax)))

   ;; SRFI 9
   ("Defining Record Types"
    (define-record-type (:syntax)))

   ;; SRFI 10
   ("Sharp-Comma External Form"
    (define-reader-ctor (:syntax)))

   ;; SRFI 11
   ("Syntax for receiving multiple values"
    (let-values (:syntax))
    (let-values* (:syntax)))

   ()

   ;; SRFI 13
   ("String Library"
    (string-map (proc s :optional start end) s)
    (string-map! (proc s :optional start end) unspecific)
    (string-fold (kons knil s :optional start end) value)
    (string-fold-right (kons knil s :optional start end) value)
    (string-unfold (p f g seed :optional base make-final) string)
    (string-unfold-right (p f g seed :optional base make-final) string)
    (string-tabulate (proc len) string)
    (string-for-each (proc s :optional start end) unspecific)
    (string-for-each-index (proc s :optional start end) unspecific)
    (string-every (pred s :optional start end))
    (string-any (pred s :optional start end))
    (string-hash (s :optional bound start end))
    (string-hash-ci (s :optional bound start end))
    (string-compare (string1 string2 lt-proc eq-proc gt-proc :optional start end))
    (string-compare-ci (string1 string2 lt-proc eq-proc gt-proc :optional start end))
    (string< (string1 string2 :optional start1 end1 start2 end2))
    (string-titlecase (string :optional start end))
    (string-upcase (string :optional start end))
    (string-downcase (string :optional start end))
    (string-titlecase! (string :optional start end))
    (string-upcase! (string :optional start end))
    (string-downcase! (string :optional start end))
    (string-take (string nchars))
    (string-drop (string nchars))
    (string-take-right (string nchars))
    (string-drop-right (string nchars))
    (string-pad (string k :optional char start end))
    (string-pad-right (string k :optional char start end))
    (string-trim (string :optional char/char-set/pred start end))
    (string-trim-right (string :optional char/char-set/pred start end))
    (string-trim-both (string :optional char/char-set/pred start end))
    (string-filter (char/char-set/pred string :optional start end))
    (string-delete (char/char-set/pred string :optional start end))
    (string-index (string char/char-set/pred :optional start end))
    (string-index-right (string char/char-set/pred :optional end start))
    (string-skip (string char/char-set/pred :optional start end))
    (string-skip-right (string char/char-set/pred :optional end start))
    (string-count (string char/char-set/pred :optional start end))
    (string-prefix-length (string1 string2 :optional start1 end1 start2 end2))
    (string-suffix-length (string1 string2 :optional start1 end1 start2 end2))
    (string-prefix-length-ci (string1 string2 :optional start1 end1 start2 end2))
    (string-suffix-length-ci (string1 string2 :optional start1 end1 start2 end2))
    (string-prefix? (string1 string2 :optional start1 end1 start2 end2))
    (string-suffix? (string1 string2 :optional start1 end1 start2 end2))
    (string-prefix-ci? (string1 string2 :optional start1 end1 start2 end2))
    (string-suffix-ci? (string1 string2 :optional start1 end1 start2 end2))
    (string-contains (string pattern :optional s-start s-end p-start p-end))
    (string-contains-ci (string pattern :optional s-start s-end p-start p-end))
    (string-fill! (string char :optional start end))
    (string-copy! (to tstart from :optional fstart fend))
    (string-copy (s :optional start end) string)
    (substring/shared (s start :optional end) string)
    (string-reverse (s :optional start end))
    (string-reverse! (s :optional start end))
    (reverse-list->string (char-list))
    (string->list (s :optional start end))
    (string-concatenate (string-list))
    (string-concatenate/shared (string-list))
    (string-append/shared (s ...))
    (string-concatenate-reverse (string-list :optional final-string end))
    (string-concatenate-reverse/shared (string-list :optional final-string end))
    (xsubstring (s from :optional to start end))
    (string-xcopy! (target tstart s from :optional to start end))
    (string-null? (s))
    (string-join (string-list :optional delim grammar))
    (string-tokenize (string :optional token-chars start end))
    (string-replace (s1 s2 start1 end1 :optional start2 end2))
    (string-kmp-partial-search (pat rv s i :optional c= p-start s-start s-end) integer)
    (make-kmp-restart-vector (s :optional c= start end) vector)
    (kmp-step (pat rv c i c= p-start) integer)
    )

   ;; SRFI 14
   ("Character-Set Library"
    (char-set? (obj) bool)
    (char-set= (obj ...) bool)
    (char-set<= (obj ...) bool)
    (char-set-hash (obj :optional int) int)
    (char-set-cursor (obj) int)
    (char-set-ref (obj int) ch)
    (char-set-cursor-next (obj int) int)
    (end-of-char-set? (obj) bool)
    (char-set-fold (proc obj obj) obj)
    (char-set-unfold (proc proc proc obj :optional obj) obj)
    (char-set-unfold! (proc proc proc obj obj) obj)
    (char-set-for-each (proc obj))
    (char-set-map (proc obj) obj)
    (char-set-copy (obj) obj)
    (char-set (ch ...) obj)
    (list->char-set (obj :optional obj) obj)
    (list->char-set! (obj obj) obj)
    (string->char-set (obj :optional obj) obj)
    (string->char-set! (obj obj) obj)
    (ucs-range->char-set (int int :optional bool obj) obj)
    (ucs-range->char-set! (int int bool obj) obj)
    (char-set-filter (proc obj :optional obj) obj)
    (char-set-filter! (proc obj obj) obj)
    (->char-set (obj) obj)
    (char-set-size (obj) int)
    (char-set-count (proc obj) int)
    (char-set-contains? (ch obj) bool)
    (char-set-every (proc obj) bool)
    (char-set-any (proc obj) obj)
    (char-set-adjoin (obj ch ...) obj)
    (char-set-delete (obj ch ...) obj)
    (char-set-adjoin! (obj ch ...) obj)
    (char-set-delete! (obj ch ...) obj)
    (char-set->list (obj) obj)
    (char-set->string (obj) str)
    (char-set-complement (obj) obj)
    (char-set-union (:optional obj) obj)
    (char-set-intersection (:optional obj) obj)
    (char-set-xor (:optional obj) obj)
    (char-set-difference (obj :optional obj) obj)
    (char-set-diff+intersection (obj obj ...) (values obj obj))
    (char-set-complement! (obj) obj)
    (char-set-union! (obj :optional obj) obj)
    (char-set-intersection! (obj :optional obj) obj)
    (char-set-xor! (obj :optional obj) obj)
    (char-set-difference! (obj :optional obj) obj)
    (char-set-diff+intersection! (obj obj obj ...) (values obj obj))
    (char-set:lower-case (:variable))
    (char-set:upper-case (:variable))
    (char-set:letter (:variable))
    (char-set:digit (:variable))
    (char-set:letter+digit (:variable))
    (char-set:graphic (:variable))
    (char-set:printing (:variable))
    (char-set:whitespace (:variable))
    (char-set:blank (:variable))
    (char-set:iso-control (:variable))
    (char-set:punctuation (:variable))
    (char-set:symbol (:variable))
    (char-set:hex-digit (:variable))
    (char-set:ascii (:variable))
    (char-set:empty (:variable))
    (char-set:full (:variable))
    )

   ()

   ;; SRFI 16
   ("Syntax for procedures of variable arity"
    (case-lambda (:syntax)))

   ;; SRFI 17
   ("Generalized set!"
    (set! (:syntax)))

   ;; SRFI 18
   ("Multithreading support"
    (current-thread ())
    (thread? (obj))
    (make-thread (thunk :optional name))
    (thread-name (thread))
    (thread-specific (thread))
    (thread-specific-set! (thread obj))
    (thread-base-priority (thread))
    (thread-base-priority-set! (thread number))
    (thread-priority-boost (thread))
    (thread-priority-boost-set! (thread number))
    (thread-quantum (thread))
    (thread-quantum-set! (thread number))
    (thread-start! (thread))
    (thread-yield! ())
    (thread-sleep! (number))
    (thread-terminate! (thread))
    (thread-join! (thread :optional timeout timeout-val))
    (mutex? (obj))
    (make-mutex (:optional name))
    (mutex-name (mutex))
    (mutex-specific (mutex))
    (mutex-specific-set! (mutex obj))
    (mutex-state (mutex))
    (mutex-lock! (mutex :optional timeout thread))
    (mutex-unlock! (mutex :optional condition-variable timeout))
    (condition-variable? (obj))
    (make-condition-variable (:optional name))
    (condition-variable-name (condition-variable))
    (condition-variable-specific (condition-variable))
    (condition-variable-specific-set! (condition-variable obj))
    (condition-variable-signal! (condition-variable))
    (condition-variable-broadcast! (condition-variable))
    (current-time ())
    (time? (obj))
    (time->seconds (time))
    (seconds->time (x))
    (current-exception-handler ())
    (with-exception-handler (handler thunk))
    (raise (obj))
    (join-timeout-exception? (obj))
    (abandoned-mutex-exception? (obj))
    (terminated-thread-exception? (obj))
    (uncaught-exception? (obj))
    (uncaught-exception-reason (exc))
    )

   ;; SRFI 19
   ("Time Data Types and Procedures"
    (current-date (:optional tz-offset) date)
    (current-julian-day () jdn)
    (current-modified-julian-day () mjdn)
    (current-time (:optional time-type) time)
    (time-resolution (:optional time-type) nanoseconds)
    (make-time (type nanosecond second))
    (time? (obj))
    (time-type (time))
    (time-nanosecond (time))
    (time-second (time))
    (set-time-type! (time))
    (set-time-nanosecond! (time))
    (set-time-second! (time))
    (copy-time (time))
    (time<=? (time1 time2))
    (time<? (time1 time2))
    (time=? (time1 time2))
    (time>=? (time1 time2))
    (time>? (time1 time2))
    (time-difference (time1 time2))
    (time-difference! (time1 time2))
    (add-duration (time duration))
    (add-duration! (time duration))
    (subtract-duration (time duration))
    (subtract-duration! (time duration))
    (make-date (nanosecond second minute hour day month year zone-offset))
    (date? (obj))
    (date-nanosecond (date))
    (date-second (date))
    (date-minute (date))
    (date-hour (date))
    (date-day (date))
    (date-month (date))
    (date-year (date))
    (date-zone-offset (date))
    (date-year-day (date))
    (date-week-day (date))
    (date-week-number (date))
    (date->julian-day (date))
    (date->modified-julian-day (date))
    (date->time-monotonic (date))
    (date->time-tai (date))
    (date->time-utc (date))
    (julian-day->date (date))
    (julian-day->time-monotonic (date))
    (julian-day->time-tai (date))
    (julian-day->time-utc (date))
    (modified-julian-day->date (date))
    (modified-julian-day->time-monotonic (date))
    (modified-julian-day->time-tai (date))
    (modified-julian-day->time-utc (date))
    (time-monotonic->date (date))
    (time-monotonic->julian-day (date))
    (time-monotonic->modified-julian-day (date))
    (time-monotonic->time-monotonic (date))
    (time-monotonic->time-tai (date))
    (time-monotonic->time-tai! (date))
    (time-monotonic->time-utc (date))
    (time-monotonic->time-utc! (date))
    (time-tai->date (date))
    (time-tai->julian-day (date))
    (time-tai->modified-julian-day (date))
    (time-tai->time-monotonic (date))
    (time-tai->time-monotonic! (date))
    (time-tai->time-utc (date))
    (time-tai->time-utc! (date))
    (time-utc->date (date))
    (time-utc->julian-day (date))
    (time-utc->modified-julian-day (date))
    (time-utc->time-monotonic (date))
    (time-utc->time-monotonic! (date))
    (time-utc->time-tai (date))
    (time-utc->time-tai! (date))
    (date->string (date :optional format-string))
    (string->date (input-string template-string))
    )

   ()

   ;; SRFI 21
   ("Real-time multithreading support"
    srfi-18)                            ; same as srfi-18

   ;; SRFI 22
   ("Running Scheme Scripts on Unix"
    )

   ;; SRFI 23
   ("Error reporting mechanism"
    (error (reason-string arg ...)))

   ()

   ;; SRFI 25
   ("Multi-dimensional Array Primitives"
    (array? (obj))
    (make-array (shape :optional init))
    (shape (bound ...))
    (array (shape obj ...))
    (array-rank (array))
    (array-start (array))
    (array-end (array))
    (array-shape (array))
    (array-ref (array i ...))
    (array-set! (array obj ...))
    (share-array (array shape proc))
    )

   ;; SRFI 26
   ("Notation for Specializing Parameters without Currying"
    (cut (:syntax))
    (cute (obj ...)))

   ;; SRFI 27
   ("Sources of Random Bits"
    (random-integer (n))
    (random-real ())
    (default-random-source ())
    (make-random-source ())
    (random-source? (obj))
    (random-source-state-ref (random-source))
    (random-source-state-set! (random-source state))
    (random-source-randomize! (random-source))
    (random-source-pseudo-randomize! (random-source i j))
    (random-source-make-integers (random-source))
    (random-source-make-reals (random-source))
    )

   ;; SRFI 28
   ("Basic Format Strings"
    (format (port-or-boolean format-string arg ...)))

   ;; SRFI 29
   ("Localization"
    (current-language (:optional symbol))
    (current-country (:optional symbol))
    (current-locale-details (:optional list))
    (declare-bundle! (bundle-name association-list))
    (store-bundle (bundle-name))
    (load-bundle! (bundle-name))
    (localized-template (package-name message-template-name))
    )

   ;; SRFI 30
   ("Nested Multi-line Comments"
    )

   ;; SRFI 31
   ("A special form for recursive evaluation"
    (rec (:syntax)))

   ()

   ()

   ;; SRFI 34
   ("Exception Handling for Programs"
    (guard (:syntax))
    (raise (obj))
    )

   ;; SRFI 35
   ("Conditions"
    (make-condition-type (id parent field-name-list))
    (condition-type? (obj))
    (make-condition (condition-type))
    (condition? (obj))
    (condition-has-type? (condition condition-type))
    (condition-ref (condition field-name))
    (make-compound-condition (condition ...))
    (extract-condition (condition condition-type))
    (define-condition-type (:syntax))
    (condition (:syntax))
    )

   ;; SRFI 36
   ("I/O Conditions"
    (&error (:variable))
    (&i/o-error (:variable))
    (&i/o-port-error (:variable))
    (&i/o-read-error (:variable))
    (&i/o-write-error (:variable))
    (&i/o-closed-error (:variable))
    (&i/o-filename-error (:variable))
    (&i/o-malformed-filename-error (:variable))
    (&i/o-file-protection-error (:variable))
    (&i/o-file-is-read-only-error (:variable))
    (&i/o-file-already-exists-error (:variable))
    (&i/o-no-such-file-error (:variable))
    )

   ;; SRFI 37
   ("args-fold: a program argument processor"
    (args-fold
     (arg-list option-list unrecognized-option-proc operand-proc seed ...))
    (option-processor (option name arg seeds ...))
    (operand-processor (operand seeds ...))
    (option (name-list required-arg? optional-arg? option-proc))
    (option-names (option))
    (option-required-arg? (option))
    (option-optional-arg? (option))
    (option-processor (option))
    )

   ;; SRFI 38
   ("External Representation for Data With Shared Structure"
    (write-with-shared-structure (obj :optional port optarg))
    (read-with-shared-structure (:optional port))
    )

   ;; SRFI 39
   ("Parameter objects"
    (make-parameter (init-value :optional converter))
    (parameterize (:syntax)))

   ;; SRFI 40
   ("A Library of Streams"
    (stream-null (:variable))
    (stream-cons (:syntax obj stream))
    (stream? (obj))
    (stream-null? (obj))
    (stream-pair? (obj))
    (stream-car (stream))
    (stream-cdr (stream))
    (stream-delay (:syntax expr))
    (stream (obj ...))
    (stream-unfoldn (generator-proc seed n))
    (stream-map (proc stream ...))
    (stream-for-each (proc stream ...))
    (stream-filter (pred stream))
    )

   ()

   ;; SRFI 42
   ("Eager Comprehensions"
    (list-ec (:syntax))
    (append-ec (:syntax))
    (sum-ec (:syntax))
    (min-ec (:syntax))
    (max-ec (:syntax))
    (any?-ec (:syntax))
    (every?-ec (:syntax))
    (first-ec (:syntax))
    (do-ec (:syntax))
    (fold-ec (:syntax))
    (fold3-ec (:syntax))
    (:list (:syntax))
    (:string (:syntax))
    (:vector (:syntax))
    (:integers (:syntax))
    (:range (:syntax))
    (:real-range (:syntax))
    (:char-range (:syntax))
    (:port (:syntax))
    (:do (:syntax))
    (:let (:syntax))
    (:parallel (:syntax))
    (:while (:syntax))
    (:until (:syntax))
    )

   ;; SRFI 43
   ("Vector Library"
    (vector-unfold (f length initial-seed ...))
    (vector-unfold-right (f length initial-seed ...))
    (vector-tabulate (f size))
    (vector-copy (vec :optional start end fill))
    (vector-reverse-copy (vec :optional start end))
    (vector-append (vec ...))
    (vector-concatenate (vector-list))
    (vector-empty? (obj))
    (vector= (eq-proc vec ...))
    (vector-fold (kons knil vec ...))
    (vector-fold-right (kons knil vec ...))
    (vector-map (f vec ...))
    (vector-map! (f vec ...))
    (vector-for-each (f vec ...))
    (vector-count (pred vec ...))
    (vector-index (pred vec ...))
    (vector-index-right (pred vec ...))
    (vector-skip (pred vec ...))
    (vector-skip-right (pred vec ...))
    (vector-binary-search (vec value cmp-proc))
    (vector-any (pred vec ...))
    (vector-every (pred vec ...))
    (vector-swap! (vec i j))
    (vector-reverse! (vec :optional start end))
    (vector-copy! (target-vec t-start source-vec :optional start end))
    (vector-reverse-copy! (target-vec t-start source-vec :optional start end))
    (reverse-vector-to-list (vec :optional start end))
    (reverse-list-to-vector (list))
    )

   ;; SRFI 44
   ("Collections"
    )

   ;; SRFI 45
   ("Primitives for expressing iterative lazy algorithms"
    (delay (:syntax expr))
    (lazy (:syntax expr))
    (force (promise))
    (eager (promise))
    )

   ;; SRFI 46
   ("Basic Syntax-rules Extensions"
    (syntax-rules (:syntax)))

   ;; SRFI 47
   ("Array"
    (make-array (prototype k ...))
    (ac64 (:optional z))
    (ac32 (:optional z))
    (ar64 (:optional x))
    (ar32 (:optional x))
    (as64 (:optional n))
    (as32 (:optional n))
    (as16 (:optional n))
    (as8 (:optional n))
    (au64 (:optional n))
    (au32 (:optional n))
    (au16 (:optional n))
    (au8 (:optional n))
    (at1 (:optional bool))
    (make-shared-array (array mapper k ...))
    (array-rank (obj))
    (array-dimensions (array))
    (array-in-bounds? (array k ...))
    (array-ref (array k ...))
    (array-set! (array obj k ...))
    )

   ;; SRFI 48
   ("Intermediate Format Strings"
    (format (port-or-boolean format-string arg ...)))

   ;; SRFI 49
   ("Indentation-sensitive syntax"
    )

   ()

   ;; SRFI 51
   ("Handling rest list"
    (rest-values (caller rest-list :optional args-number-limit default))
    (arg-and (:syntax))
    (arg-ands (:syntax))
    (err-and (:syntax))
    (err-ands (:syntax))
    (arg-or (:syntax))
    (arg-ors (:syntax))
    (err-or (:syntax))
    (err-ors (:syntax))
    )

   ()

   ()

   ;; SRFI 54
   ("Formatting"
    (cat (obj ...)))

   ;; SRFI 55
   ("require-extension"
    (require-extension (:syntax)))

   ()

   ;; SRFI 57
   ("Records"
    (define-record-type (:syntax))
    (define-record-scheme (:syntax))
    (record-update (:syntax))
    (record-update! (:syntax))
    (record-compose (:syntax)))

   ;; SRFI 58
   ("Array Notation"
    )

   ;; SRFI 59
   ("Vicinity"
    (program-vicinity ())
    (library-vicinity ())
    (implementation-vicinity ())
    (user-vicinity ())
    (home-vicinity ())
    (in-vicinity (vicinity filename))
    (sub-vicinity (vicinity name))
    (make-vicinity (dirname))
    (path-vicinity (path))
    (vicinity:suffix? (ch))
    )

   ;; SRFI 60
   ("Integers as Bits"
    (bitwise-and (n ...))
    (bitwise-ior (n ...))
    (bitwise-xor (n ...))
    (bitwise-not (n))
    (bitwise-if (mask n m))
    (any-bits-set? (n m))
    (bit-count (n))
    (integer-length (n))
    (first-bit-set (n))
    (bit-set? (i n))
    (copy-bit (index n bool))
    (bit-field (n start end))
    (copy-bit-field (to-int from-int start end))
    (arithmetic-shift (n count))
    (rotate-bit-field (n count start end))
    (reverse-bit-field (n start end))
    (integer->list (k :optional len))
    (list->integer (list))
    )

   ;; SRFI 61
   ("A more general cond clause"
    (cond (:syntax)))

   ;; SRFI 62
   ("S-expression comments"
    )

   ;; SRFI 63
   ("Homogeneous and Heterogeneous Arrays"
    )

   ;; SRFI 64
   ("A Scheme API for test suites"
    (test-assert (:syntax))
    (test-eqv (:syntax))
    (test-equal (:syntax))
    (test-eq (:syntax))
    (test-approximate (:syntax))
    (test-error (:syntax))
    (test-read-eval-string (string))
    (test-begin (:syntax suite-name :optional count))
    (test-end (:syntax suite-name))
    (test-group (:syntax suite-name decl-or-expr ...))
    (test-group-with-cleanup (:syntax suite-name decl-or-expr ...))
    (test-match-name (name))
    (test-match-nth (n :optional count))
    (test-match-any (specifier ...))
    (test-match-all (specifier ...))
    (test-skip (:syntax specifier))
    (test-expect-fail (:syntax specifier))
    (test-runner? (obj))
    (test-runner-current (:optional runner))
    (test-runner-get ())
    (test-runner-simple ())
    (test-runner-null ())
    (test-runner-create ())
    (test-runner-factory (:optional factory))
    (test-apply (:syntax runner specifier ...))
    (test-with-runner (:syntax runner decl-or-expr ...))
    (test-result-kind (:optional runner))
    (test-passed? (:optional runner))
    (test-result-ref (runner prop-name (:optional default)))
    (test-result-set! (runner prop-name value))
    (test-result-remove (runner prop-name))
    (test-result-clear (runner))
    (test-result-alist (runner))
    (test-runner-on-test-begin (runner :optional proc))
    (test-runner-on-test-begin! (runner :optional proc))
    (test-runner-on-test-end (runner :optional proc))
    (test-runner-on-test-end! (runner :optional proc))
    (test-runner-on-group-begin (runner :optional proc))
    (test-runner-on-group-begin! (runner :optional proc))
    (test-runner-on-group-end (runner :optional proc))
    (test-runner-on-group-end! (runner :optional proc))
    (test-runner-on-bad-count (runner :optional proc))
    (test-runner-on-bad-count! (runner :optional proc))
    (test-runner-on-bad-end-name (runner :optional proc))
    (test-runner-on-bad-end-name! (runner :optional proc))
    (test-runner-on-final (runner :optional proc))
    (test-runner-on-final! (runner :optional proc))
    (test-runner-pass-count (runner))
    (test-runner-fail-count (runner))
    (test-runner-xpass-count (runner))
    (test-runner-skip-count (runner))
    (test-runner-test-name (runner))
    (test-runner-group-path (runner))
    (test-runner-group-stack (runner))
    (test-runner-aux-value (runner))
    (test-runner-aux-value! (runner))
    (test-runner-reset (runner))
    )

   ()

   ;; SRFI 66
   ("Octet Vectors"
    (make-u8vector (len n))
    (u8vector (n ...))
    (u8vector->list (u8vector))
    (list->u8vector (octet-list))
    (u8vector-length u8vector)
    (u8vector-ref (u8vector k))
    (u8vector-set! (u8vector k n))
    (u8vector=? (u8vector-1 u8vector-2))
    (u8vector-compare (u8vector-1 u8vector-2))
    (u8vector-copy! (source source-start target target-start n))
    (u8vector-copy (u8vector))
    )

   ;; SRFI 67
   ("Compare Procedures"
    )

   ()

   ;; SRFI 69
   ("Basic hash tables"
    )

   ;; SRFI 70
   ("Numbers"
    )

   ;; SRFI 71
   ("LET-syntax for multiple values"
    )

   ;; SRFI 72
   ("Simple hygienic macros"
    )

   ()

   ;; SRFI 74
   ("Octet-Addressed Binary Blocks"
    )

   ])

(defvar *scheme-chicken-modules*
  '((extras
     (->string (obj))
     (alist->hash-table (alist))
     (alist-ref (alist key :optional eq-fn default))
     (alist-update! (key value alist :optional eq-fn))
     (atom? (obj))
     (binary-search (vec proc))
     (butlast (list) () nil "drops the last element of list")
     (call-with-input-string (string proc))
     (call-with-output-string (proc))
     (chop (list k))
     (complement (proc))
     (compose (f1 f2 ...))
     (compress (boolean-list list))
     (conc (obj ...))
     (conjoin (pred ...))
     (constantly (obj ...))
     (disjoin (pred ...))
     (each (proc ...))
     (flatten (list1 ...))
     (flip (proc))
     (format (format-string arg ...))
     (fprintf (port format-string arg ...))
     (hash (obj :optional n))
     (hash-by-identity (obj :optional n))
     (hash-table->alist (hash-table))
     (hash-table-copy (hash-table))
     (hash-table-delete! (hash-table key))
     (hash-table-equivalence-function (hash-table))
     (hash-table-exists? (hash-table key))
     (hash-table-fold (hash-table f init-value))
     (hash-table-hash-function (hash-table))
     (hash-table-keys (hash-table))
     (hash-table-merge! (hash-table1 hash-table2))
     (hash-table-ref (hash-table key :optional thunk))
     (hash-table-ref/default (hash-table key default))
     (hash-table-remove! (hash-table proc))
     (hash-table-set! (hash-table key value))
     (hash-table-size (hash-table))
     (hash-table-update! (hash-table key proc :optional thunk))
     (hash-table-update!/default (hash-table key proc default))
     (hash-table-values (hash-table))
     (hash-table-walk (hash-table proc))
     (hash-table? (obj))
     (identity (obj))
     (intersperse (list obj))
     (join (list-of-lists :optional list))
     (list->queue (list))
     (list-of (pred))
     (make-hash-table (:optional eq-fn hash-fn size))
     (make-input-port (read-proc ready?-pred close-proc :optional peek-proc))
     (make-output-port (write-proc close-proc :optional flush-proc))
     (make-queue ())
     (merge (list1 list2 less-fn))
     (merge! (list1 list2 less-fn))
     (noop (obj ...))
     (pp (obj :optional output-port))
     (pretty-print (obj :optional output-port))
     (pretty-print-width (:optional new-width))
     (printf (format-string arg ...))
     (project (n))
     (queue->list (queue))
     (queue-add! (queue obj))
     (queue-empty? (queue))
     (queue-first (queue))
     (queue-last (queue))
     (queue-push-back! (queue obj))
     (queue-push-back-list! (queue list))
     (queue-remove! (queue))
     (queue? (obj))
     (random (n))
     (randomize (:optional x))
     (rassoc (key list :optional eq-fn))
     (read-file (:optional file-or-port reader-fn max-count))
     (read-line (:optional port limit))
     (read-lines (:optional port max))
     (read-string (:optional n port))
     (read-string! (n dest :optional port start))
     (read-token (predicate :optional port))
     (shuffle (list))
     (sort (sequence less-fn))
     (sort! (sequence less-fn))
     (sorted? (sequence less-fn))
     (sprintf (format-string arg ...))
     (string-chomp (str :optional suffix-str))
     (string-chop (str length))
     (string-ci-hash (str :optional n))
     (string-compare3 (str1 str2))
     (string-compare3-ci (str1 str2))
     (string-hash (str1 :optional n))
     (string-intersperse (list :optional seperator-string))
     (string-split (str :optional delimiter-str keep-empty?))
     (string-translate (str from-str :optional to-str))
     (string-translate* (str list))
     (substring-ci=? (str1 str2 :optional start1 start2 length))
     (substring-index (which-str where-str :optional start))
     (substring-index-ci (which-str where-str :optional start))
     (substring=? (str1 str2 :optional start1 start2 length))
     (tail? (obj list))
     (with-error-output-to-port (output-port thunk))
     (with-input-from-port (port thunk))
     (with-input-from-string (str thunk))
     (with-output-to-port (port thunk))
     (with-output-to-string (thunk))
     (write-line (str :optional port))
     (write-string (str :optional num port))
     )
    (lolevel
     (address->pointer (n))
     (align-to-word (ptr-or-int))
     (allocate (size))
     (block-ref (block index))
     (block-set! (block index obj))
     (byte-vector (n ...))
     (byte-vector->list (byte-vector))
     (byte-vector->string (byte-vector))
     (byte-vector-fill! (byte-vector n))
     (byte-vector-length (byte-vector))
     (byte-vector-ref (byte-vector i))
     (byte-vector-set! (byte-vector i n))
     (byte-vector? (obj))
     (extend-procedure (proc x))
     (extended-procedure? (proc))
     (free (pointer))
     (global-bound? (sym))
     (global-make-unbound! (sym))
     (global-ref (sym))
     (global-set! (sym obj))
     (list->byte-vector (list))
     (locative->object (locative))
     (locative-ref (locative))
     (locative-set! (locative obj))
     (locative? (obj))
     (make-byte-vector (size :optional init-n))
     (make-locative (obj :optional index))
     (make-record-instance (sym arg ...))
     (make-static-byte-vector (size :optional init-n))
     (make-weak-locative (obj :optional index))
     (move-memory! (from to :optional bytes from-offset to-offset))
     (null-pointer ())
     (null-pointer? (pointer))
     (number-of-bytes (block))
     (number-of-slots (block))
     (object->pointer (obj))
     (object-become! (alist))
     (object-copy (obj))
     (object-evict (obj :optional allocator-proc))
     (object-evict-to-location (obj ptr :optional limit))
     (object-evicted? (obj))
     (object-release (obj :optional releaser-proc))
     (object-size (obj))
     (object-unevict (obj :optional full))
     (pointer->address (ptr))
     (pointer->object (ptr))
     (pointer-f32-ref (ptr))
     (pointer-f32-set! (ptr x))
     (pointer-f64-ref (ptr))
     (pointer-f64-set! (ptr x))
     (pointer-offset (ptr n))
     (pointer-s16-ref (ptr))
     (pointer-s16-set! (ptr n))
     (pointer-s32-ref (ptr))
     (pointer-s32-set! (ptr n))
     (pointer-s8-ref (ptr))
     (pointer-s8-set! (ptr n))
     (pointer-tag (ptr))
     (pointer-u16-ref (ptr))
     (pointer-u16-set! (ptr n))
     (pointer-u32-ref (ptr))
     (pointer-u32-set! (ptr n))
     (pointer-u8-ref (ptr))
     (pointer-u8-set! (ptr n))
     (pointer=? (ptr1 ptr2))
     (pointer? (obj))
     (procedure-data (proc))
     (record->vector (block))
     (record-instance? (obj))
     (set-invalid-procedure-call-handler! (proc))
     (set-procedure-data! (proc obj))
     (static-byte-vector->pointer (byte-vector))
     (string->byte-vector (str))
     (tag-pointer (ptr tag))
     (tagged-pointer? (obj tag))
     (unbound-variable-value (:optional value))
     )
    (posix
     (_exit (:optional n))
     (call-with-input-pipe (cmdline-string proc :optional mode))
     (call-with-output-pipe (cmdline-string proc :optional mode))
     (change-directory (dir))
     (change-file-mode (filename mode))
     (change-file-owner (filename user-n group-n))
     (close-input-pipe (input-port))
     (close-output-pipe (output-port))
     (create-directory (filename))
     (create-fifo (filename :optional mode))
     (create-pipe ())
     (create-session ())
     (create-symbolic-link (old-filename new-filename))
     (current-directory (:optional new-dir))
     (current-effective-group-id ())
     (current-effective-user-id ())
     (current-environment ())
     (current-group-id ())
     (current-process-id ())
     (current-user-id ())
     (delete-directory (dir))
     (directory (:optional dir show-dotfiles?))
     (directory? (filename))
     (duplicate-fileno (old-n :optional new-n))
     (errno/acces (:variable))
     (errno/again (:variable))
     (errno/badf (:variable))
     (errno/busy (:variable))
     (errno/child (:variable))
     (errno/exist (:variable))
     (errno/fault (:variable))
     (errno/intr (:variable))
     (errno/inval (:variable))
     (errno/io (:variable))
     (errno/isdir (:variable))
     (errno/mfile (:variable))
     (errno/noent (:variable))
     (errno/noexec (:variable))
     (errno/nomem (:variable))
     (errno/nospc (:variable))
     (errno/notdir (:variable))
     (errno/perm (:variable))
     (errno/pipe (:variable))
     (errno/rofs (:variable))
     (errno/spipe (:variable))
     (errno/srch (:variable))
     (errno/wouldblock (:variable))
     (fifo? (filename))
     (file-access-time (filename))
     (file-change-time (filename))
     (file-close (file-n))
     (file-execute-access? (filename))
     (file-link (old-filename new-filename))
     (file-lock (port :optional start len))
     (file-lock/blocking (port :optional start len))
     (file-mkstemp (template-filename))
     (file-modification-time (filename))
     (file-open (filename flags :optional mode))
     (file-owner (filename))
     (file-permissions (filename))
     (file-position (port-or-file-n))
     (file-read (file-n size :optional buffer-string))
     (file-read-access? (filename))
     (file-select (read-fd-list write-fd-list :optional timeout))
     (file-size (filename))
     (file-stat (filename :optional follow-link?))
     (file-test-lock (port :optional start len))
     (file-truncate (filename-or-file-n offset))
     (file-unlock (lock))
     (file-write (file-n buffer-string :optional size))
     (file-write-access? (filename))
     (fileno/stderr (:variable))
     (fileno/stdin (:variable))
     (fileno/stdout (:variable))
     (find-files (dir pred :optional action-proc identity limit))
     (get-groups ())
     (get-host-name ())
     (glob (pattern1 ...))
     (group-information (group-name-or-n))
     (initialize-groups (user-name base-group-n))
     (local-time->seconds (vector))
     (local-timezone-abbreviation ())
     (map-file-to-memory (address len protection flag file-n :optional offset))
     (memory-mapped-file-pointer (mmap))
     (memory-mapped-file? (obj))
     (open-input-file* (file-n :optional open-mode))
     (open-input-pipe (cmdline-string :optional mode))
     (open-output-file* (file-n :optional open-mode))
     (open-output-pipe (cmdline-string :optional mode))
     (open/append (:variable))
     (open/binary (:variable))
     (open/creat (:variable))
     (open/excl (:variable))
     (open/fsync (:variable))
     (open/noctty (:variable))
     (open/nonblock (:variable))
     (open/rdonly (:variable))
     (open/rdwr (:variable))
     (open/read (:variable))
     (open/sync (:variable))
     (open/text (:variable))
     (open/trunc (:variable))
     (open/write (:variable))
     (open/wronly (:variable))
     (parent-process-id ())
     (perm/irgrp (:variable))
     (perm/iroth (:variable))
     (perm/irusr (:variable))
     (perm/irwxg (:variable))
     (perm/irwxo (:variable))
     (perm/irwxu (:variable))
     (perm/isgid (:variable))
     (perm/isuid (:variable))
     (perm/isvtx (:variable))
     (perm/iwgrp (:variable))
     (perm/iwoth (:variable))
     (perm/iwusr (:variable))
     (perm/ixgrp (:variable))
     (perm/ixoth (:variable))
     (perm/ixusr (:variable))
     (pipe/buf (:variable))
     (port->fileno (port))
     (process (cmdline-string :optional arg-list env-list))
     (process-execute (filename :optional arg-list env-list))
     (process-fork (:optional thunk))
     (process-group-id)
     (process-run (filename :optional list))
     (process-signal (pid :optional signal))
     (process-wait (:optional pid nohang?))
     (read-symbolic-link (filename))
     (regular-file? (filename))
     (seconds->local-time (seconds))
     (seconds->string (seconds))
     (seconds->utc-time (seconds))
     (set-alarm! (seconds))
     (set-buffering-mode! (port mode :optional buf-size))
     (set-file-position! (port-or-file-n pos :optional whence))
     (set-group-id! (n))
     (set-groups! (group-n-list))
     (set-process-group-id! (process-n n))
     (set-root-directory! (dir) () nil "chroot")
     (set-signal-handler! (sig-n proc))
     (set-signal-mask! (sig-n-list))
     (set-user-id! (n))
     (setenv (name value-string))
     (signal/abrt (:variable))
     (signal/alrm (:variable))
     (signal/chld (:variable))
     (signal/cont (:variable))
     (signal/fpe (:variable))
     (signal/hup (:variable))
     (signal/ill (:variable))
     (signal/int (:variable))
     (signal/io (:variable))
     (signal/kill (:variable))
     (signal/pipe (:variable))
     (signal/prof (:variable))
     (signal/quit (:variable))
     (signal/segv (:variable))
     (signal/stop (:variable))
     (signal/term (:variable))
     (signal/trap (:variable))
     (signal/tstp (:variable))
     (signal/urg (:variable))
     (signal/usr1 (:variable))
     (signal/usr2 (:variable))
     (signal/vtalrm (:variable))
     (signal/winch (:variable))
     (signal/xcpu (:variable))
     (signal/xfsz (:variable))
     (sleep (seconds))
     (symbolic-link? (filename))
     (system-information ())
     (terminal-name (port))
     (terminal-port? (port))
     (time->string (vector))
     (unmap-file-from-memory (mmap :optional len))
     (unsetenv (name))
     (user-information (user-name-or-n))
     (utc-time->seconds (vector))
     (with-input-from-pipe (cmdline-string thunk :optional mode))
     (with-output-to-pipe (cmdline-string thunk :optional mode))
     )
    (regex
     (glob->regexp (pattern))
     (glob? (obj))
     (grep (pattern list))
     (regexp (pattern ignore-case? ignore-space? utf-8?))
     (regexp-escape (string))
     (regexp? (obj))
     (string-match (pattern str :optional start))
     (string-match-positions (pattern str :optional start))
     (string-search (pattern str :optional start))
     (string-search-positions (pattern str :optional start))
     (string-split-fields (pattern str :optional mode start))
     (string-substitute (pattern subst str :optional mode))
     (string-substitute* (str subst-list :optional mode))
     )
    (tcp
     (tcp-abandon-port (port))
     (tcp-accept (listener))
     (tcp-accept-ready? (listener))
     (tcp-addresses (port))
     (tcp-buffer-size (:optional new-size))
     (tcp-close (listener))
     (tcp-connect (host-string :optioanl tcp-port-n))
     (tcp-listen (tcp-port-n :optional backlog-n host-string))
     (tcp-listener-fileno (listener))
     (tcp-listener-port (listener))
     (tcp-listener? (obj))
     (tcp-port-numbers (port))
     )
    (utils
     (absolute-pathname? (pathname))
     (create-temporary-file (:optional ext-str))
     (decompose-pathname (pathname))
     (delete-file* (filename))
     (for-each-argv-line (proc))
     (for-each-line (proc :optional input-port))
     (make-absolute-pathname (dir filename :optional ext-str))
     (make-pathname (dir filename :optional ext-str))
     (pathname-directory (pathname))
     (pathname-extension (pathname))
     (pathname-file (pathname))
     (pathname-replace-directory (pathname dir))
     (pathname-replace-extension (pathname ext-str))
     (pathname-replace-file (pathname filename))
     (pathname-strip-directory (pathname))
     (pathname-strip-extension (pathname))
     (port-for-each (read-fn thunk))
     (port-map (read-fn thunk))
     (read-all (:optional file-or-port))
     (shift! (list :optional default))
     (system* (format-string arg1 ...))
     (unshift! (obj pair))
     )
    ))

(defvar *scheme-chicken-deps*
  '((lolevel extras)
    (posix regex extras utils)
    (srfi-13 srfi-14)
    (tcp extras)
    (ajax md5 url srfi-1 spiffy)
    (aquaterm srfi-4 srfi-13 lolevel regex)
    (args srfi-37)
    (array-lib srfi-1 srfi-4 lolevel miscmacros)
    ))

(defvar *scheme-implemenation-exports*
  '((chicken
     (abort)
     (add1)
     (andmap)
     (any?)
     (argc+argv)
     (argv)
     (bit-set?)
     (bitwise-and)
     (bitwise-ior)
     (bitwise-not)
     (bitwise-xor)
     (blob->string)
     (blob-size)
     (blob?)
     (breakpoint)
     (build-platform)
     (c-runtime)
     (call/cc)
     (case-sensitive)
     (chicken-home)
     (chicken-version)
     (command-line-arguments)
     (condition-predicate)
     (condition-property-accessor)
     (condition?)
     (continuation-capture)
     (continuation-graft)
     (continuation-return)
     (continuation?)
     (copy-read-table)
     (cpu-time)
     (current-error-port)
     (current-exception-handler)
     (current-gc-milliseconds)
     (current-milliseconds)
     (current-read-table)
     (current-seconds)
     (define-reader-ctor)
     (delete-file)
     (disable-interrupts)
     (do-unbreak-all)
     (dynamic-load-libraries)
     (dynamic-wind)
     (enable-interrupts)
     (enable-warnings)
     (errno)
     (error)
     (eval-handler)
     (exit)
     (exit-handler)
     (extension-info)
     (extension-information)
     (feature?)
     (features)
     (file-exists?)
     (finite?)
     (fixnum?)
     (flonum?)
     (flush-output)
     (force)
     (force-finalizers)
     (fp*)
     (fp+)
     (fp-)
     (fp/)
     (fp<)
     (fp<=)
     (fp=)
     (fp>)
     (fp>=)
     (fpmax)
     (fpmin)
     (fpneg)
     (fx*)
     (fx+)
     (fx-)
     (fx/)
     (fx<)
     (fx<=)
     (fx=)
     (fx>)
     (fx>=)
     (fxand)
     (fxior)
     (fxmax)
     (fxmin)
     (fxmod)
     (fxneg)
     (fxnot)
     (fxshl)
     (fxshr)
     (fxxor)
     (gc)
     (gensym)
     (get-call-chain)
     (get-keyword)
     (get-line-number)
     (get-output-string)
     (getenv)
     (getter-with-setter)
     (implicit-exit-handler)
     (invalid-procedure-call-handler)
     (keyword->string)
     (keyword-style)
     (keyword?)
     (load-library)
     (load-noisily)
     (load-relative)
     (load-verbose)
     (machine-byte-order)
     (machine-type)
     (macro?)
     (macroexpand)
     (macroexpand-1)
     (make-blob)
     (make-composite-condition)
     (make-parameter)
     (make-property-condition)
     (make-static-byte-vector)
     (match-error-control)
     (match-error-procedure)
     (memory-statistics)
     (mutate-procedure)
     (on-exit)
     (open-input-string)
     (open-output-string)
     (ormap)
     (port-name)
     (port-position)
     (port?)
     (print)
     (print*)
     (print-backtrace)
     (print-call-chain)
     (print-error-message)
     (procedure-information)
     (program-name)
     (provide)
     (provided?)
     (rational?)
     (read-byte)
     (register-feature!)
     (rename-file)
     (repl)
     (repl-prompt)
     (repository-path)
     (require)
     (reset)
     (reset-handler)
     (return-to-host)
     (reverse-list->string)
     (set-describer!)
     (set-dynamic-load-mode!)
     (set-extension-specifier!)
     (set-finalizer!)
     (set-gc-report!)
     (set-parameterized-read-syntax!)
     (set-port-name!)
     (set-read-syntax!)
     (set-sharp-read-syntax!)
     (setter)
     (signal)
     (signum)
     (singlestep)
     (software-type)
     (software-version)
     (string->blob)
     (string->keyword)
     (string->uninterned-symbol)
     (string-copy)
     (sub1)
     (syntax-error)
     (system)
     (test-feature?)
     (toplevel-command)
     (undefine-macro!)
     (unregister-feature!)
     (vector-copy!)
     (vector-resize)
     (void)
     (warning)
     (with-exception-handler)
     (write-byte)
     )
    (gauche
     (E2BIG (:variable))
     (EACCES (:variable))
     (EADDRINUSE (:variable))
     (EADDRNOTAVAIL (:variable))
     (EADV (:variable))
     (EAFNOSUPPORT (:variable))
     (EAGAIN (:variable))
     (EALREADY (:variable))
     (EBADE (:variable))
     (EBADF (:variable))
     (EBADFD (:variable))
     (EBADMSG (:variable))
     (EBADR (:variable))
     (EBADRQC (:variable))
     (EBADSLT (:variable))
     (EBFONT (:variable))
     (EBUSY (:variable))
     (ECANCELED (:variable))
     (ECHILD (:variable))
     (ECHRNG (:variable))
     (ECOMM (:variable))
     (ECONNABORTED (:variable))
     (ECONNREFUSED (:variable))
     (ECONNRESET (:variable))
     (EDEADLK (:variable))
     (EDEADLOCK (:variable))
     (EDESTADDRREQ (:variable))
     (EDOM (:variable))
     (EDOTDOT (:variable))
     (EDQUOT (:variable))
     (EEXIST (:variable))
     (EFAULT (:variable))
     (EFBIG (:variable))
     (EHOSTDOWN (:variable))
     (EHOSTUNREACH (:variable))
     (EIDRM (:variable))
     (EILSEQ (:variable))
     (EINPROGRESS (:variable))
     (EINTR (:variable))
     (EINVAL (:variable))
     (EIO (:variable))
     (EISCONN (:variable))
     (EISDIR (:variable))
     (EISNAM (:variable))
     (EKEYEXPIRED (:variable))
     (EKEYREJECTED (:variable))
     (EKEYREVOKED (:variable))
     (EL2HLT (:variable))
     (EL2NSYNC (:variable))
     (EL3HLT (:variable))
     (EL3RST (:variable))
     (ELIBACC (:variable))
     (ELIBBAD (:variable))
     (ELIBEXEC (:variable))
     (ELIBMAX (:variable))
     (ELIBSCN (:variable))
     (ELNRNG (:variable))
     (ELOOP (:variable))
     (EMEDIUMTYPE (:variable))
     (EMFILE (:variable))
     (EMLINK (:variable))
     (EMSGSIZE (:variable))
     (EMULTIHOP (:variable))
     (ENAMETOOLONG (:variable))
     (ENAVAIL (:variable))
     (ENETDOWN (:variable))
     (ENETRESET (:variable))
     (ENETUNREACH (:variable))
     (ENFILE (:variable))
     (ENOANO (:variable))
     (ENOBUFS (:variable))
     (ENOCSI (:variable))
     (ENODATA (:variable))
     (ENODEV (:variable))
     (ENOENT (:variable))
     (ENOEXEC (:variable))
     (ENOKEY (:variable))
     (ENOLCK (:variable))
     (ENOLINK (:variable))
     (ENOMEDIUM (:variable))
     (ENOMEM (:variable))
     (ENOMSG (:variable))
     (ENONET (:variable))
     (ENOPKG (:variable))
     (ENOPROTOOPT (:variable))
     (ENOSPC (:variable))
     (ENOSR (:variable))
     (ENOSTR (:variable))
     (ENOSYS (:variable))
     (ENOTBLK (:variable))
     (ENOTCONN (:variable))
     (ENOTDIR (:variable))
     (ENOTEMPTY (:variable))
     (ENOTNAM (:variable))
     (ENOTSOCK (:variable))
     (ENOTTY (:variable))
     (ENOTUNIQ (:variable))
     (ENXIO (:variable))
     (EOPNOTSUPP (:variable))
     (EOVERFLOW (:variable))
     (EPERM (:variable))
     (EPFNOSUPPORT (:variable))
     (EPIPE (:variable))
     (EPROTO (:variable))
     (EPROTONOSUPPORT (:variable))
     (EPROTOTYPE (:variable))
     (ERANGE (:variable))
     (EREMCHG (:variable))
     (EREMOTE (:variable))
     (EREMOTEIO (:variable))
     (ERESTART (:variable))
     (EROFS (:variable))
     (ESHUTDOWN (:variable))
     (ESOCKTNOSUPPORT (:variable))
     (ESPIPE (:variable))
     (ESRCH (:variable))
     (ESRMNT (:variable))
     (ESTALE (:variable))
     (ESTRPIPE (:variable))
     (ETIME (:variable))
     (ETIMEDOUT (:variable))
     (ETOOMANYREFS (:variable))
     (ETXTBSY (:variable))
     (EUCLEAN (:variable))
     (EUNATCH (:variable))
     (EUSERS (:variable))
     (EWOULDBLOCK (:variable))
     (EXDEV (:variable))
     (EXFULL (:variable))
     (F_OK (:variable))
     (LC_ALL (:variable))
     (LC_COLLATE (:variable))
     (LC_CTYPE (:variable))
     (LC_MONETARY (:variable))
     (LC_NUMERIC (:variable))
     (LC_TIME (:variable))
     (RAND_MAX (:variable))
     (R_OK (:variable))
     (SEEK_CUR (:variable))
     (SEEK_END (:variable))
     (SEEK_SET (:variable))
     (SIGABRT (:variable))
     (SIGALRM (:variable))
     (SIGBUS (:variable))
     (SIGCHLD (:variable))
     (SIGCONT (:variable))
     (SIGFPE (:variable))
     (SIGHUP (:variable))
     (SIGILL (:variable))
     (SIGINT (:variable))
     (SIGIO (:variable))
     (SIGIOT (:variable))
     (SIGKILL (:variable))
     (SIGPIPE (:variable))
     (SIGPOLL (:variable))
     (SIGPROF (:variable))
     (SIGPWR (:variable))
     (SIGQUIT (:variable))
     (SIGSEGV (:variable))
     (SIGSTKFLT (:variable))
     (SIGSTOP (:variable))
     (SIGTERM (:variable))
     (SIGTRAP (:variable))
     (SIGTSTP (:variable))
     (SIGTTIN (:variable))
     (SIGTTOU (:variable))
     (SIGURG (:variable))
     (SIGUSR1 (:variable))
     (SIGUSR2 (:variable))
     (SIGVTALRM (:variable))
     (SIGWINCH (:variable))
     (SIGXCPU (:variable))
     (SIGXFSZ (:variable))
     (SIG_BLOCK (:variable))
     (SIG_SETMASK (:variable))
     (SIG_UNBLOCK (:variable))
     (W_OK (:variable))
     (X_OK (:variable))
     (acons)
     (acosh)
     (add-load-path)
     (add-method!)
     (all-modules)
     (allocate-instance)
     (and-let*)
     (any)
     (any$)
     (any-pred)
     (append!)
     (apply$)
     (apply-generic)
     (apply-method)
     (apply-methods)
     (arity)
     (arity-at-least-value)
     (arity-at-least?)
     (ash)
     (asinh)
     (assoc$)
     (atanh)
     (autoload)
     (begin0 (:syntax))
     (bignum?)
     (bit-field)
     (boolean)
     (byte-ready?)
     (call-with-input-string)
     (call-with-output-string)
     (call-with-string-io)
     (case-lambda (:syntax))
     (change-class)
     (change-object-class)
     (char->ucs)
     (char-set)
     (char-set-contains?)
     (char-set-copy)
     (char-set?)
     (check-arg (:syntax))
     (circular-list?)
     (clamp)
     (class-direct-methods)
     (class-direct-slots)
     (class-direct-subclasses)
     (class-direct-supers)
     (class-name)
     (class-of)
     (class-precedence-list)
     (class-redefinition)
     (class-slot-accessor)
     (class-slot-bound?)
     (class-slot-definition)
     (class-slot-ref)
     (class-slot-set!)
     (class-slots)
     (closure-code)
     (closure?)
     (compare)
     (complement)
     (compose)
     (compute-applicable-methods)
     (compute-cpl)
     (compute-get-n-set)
     (compute-slot-accessor)
     (compute-slots)
     (cond-expand (:syntax))
     (condition)
     (condition-has-type?)
     (condition-ref)
     (condition-type?)
     (condition?)
     (copy-bit)
     (copy-bit-field)
     (copy-port)
     (cosh)
     (count$)
     (current-class-of)
     (current-error-port)
     (current-exception-handler)
     (current-load-history)
     (current-load-next)
     (current-load-port)
     (current-module)
     (current-thread)
     (current-time)
     (cut (:syntax))
     (cute)
     (debug-print)
     (debug-print-width)
     (debug-source-info)
     (dec! (:syntax))
     (decode-float)
     (define-class (:syntax))
     (define-condition-type (:syntax))
     (define-constant (:syntax))
     (define-generic (:syntax))
     (define-in-module (:syntax))
     (define-inline (:syntax))
     (define-macro (:syntax))
     (define-method (:syntax))
     (define-module (:syntax))
     (define-reader-ctor)
     (define-values (:syntax))
     (delete$)
     (delete-keyword)
     (delete-keyword!)
     (delete-method!)
     (digit->integer)
     (disasm)
     (dolist (:syntax))
     (dotimes (:syntax))
     (dotted-list?)
     (dynamic-load)
     (eager)
     (eq-hash)
     (eqv-hash)
     (error)
     (errorf)
     (eval-when (:syntax))
     (every$)
     (every-pred)
     (exit)
     (export)
     (export-all)
     (export-if-defined)
     (extend)
     (extract-condition)
     (file-exists?)
     (file-is-directory?)
     (file-is-regular?)
     (filter$)
     (find)
     (find$)
     (find-module)
     (find-tail$)
     (fixnum?)
     (flonum?)
     (fluid-let)
     (flush)
     (flush-all-ports)
     (fmod)
     (fold)
     (fold$)
     (fold-right)
     (fold-right$)
     (for-each$)
     (foreign-pointer-attribute-get)
     (foreign-pointer-attribute-set)
     (foreign-pointer-attributes)
     (format)
     (format/ss)
     (frexp)
     (gauche-architecture)
     (gauche-architecture-directory)
     (gauche-character-encoding)
     (gauche-dso-suffix)
     (gauche-library-directory)
     (gauche-site-architecture-directory)
     (gauche-site-library-directory)
     (gauche-version)
     (gc)
     (gc-stat)
     (gensym)
     (get-keyword)
     (get-keyword*)
     (get-optional (:syntax))
     (get-output-string)
     (get-remaining-input-string)
     (get-signal-handler)
     (get-signal-handler-mask)
     (get-signal-handlers)
     (get-signal-pending-limit)
     (getter-with-setter)
     (global-variable-bound?)
     (global-variable-ref)
     (guard (:syntax))
     (has-setter?)
     (hash)
     (hash-table)
     (hash-table-delete!)
     (hash-table-exists?)
     (hash-table-fold)
     (hash-table-for-each)
     (hash-table-get)
     (hash-table-keys)
     (hash-table-map)
     (hash-table-num-entries)
     (hash-table-pop!)
     (hash-table-push!)
     (hash-table-put!)
     (hash-table-stat)
     (hash-table-type)
     (hash-table-update!)
     (hash-table-values)
     (hash-table?)
     (identifier->symbol)
     (identifier?)
     (identity)
     (import (:syntax))
     (inc! (:syntax))
     (inexact-/)
     (initialize)
     (instance-slot-ref)
     (instance-slot-set)
     (integer->digit)
     (integer-length)
     (is-a?)
     (keyword->string)
     (keyword?)
     (last-pair)
     (lazy)
     (ldexp)
     (let-keywords* (:syntax))
     (let-optionals* (:syntax))
     (let/cc (:syntax))
     (let1 (:syntax))
     (library-exists?)
     (library-fold)
     (library-for-each)
     (library-has-module?)
     (library-map)
     (list*)
     (list-copy)
     (logand)
     (logbit?)
     (logcount)
     (logior)
     (lognot)
     (logtest)
     (logxor)
     (macroexpand)
     (macroexpand-1)
     (make)
     (make-byte-string)
     (make-compound-condition)
     (make-condition)
     (make-condition-type)
     (make-hash-table)
     (make-keyword)
     (make-list)
     (make-module)
     (make-string-pointer)
     (make-weak-vector)
     (map$)
     (member$)
     (merge)
     (merge!)
     (method-more-specific?)
     (min&max)
     (modf)
     (module-exports)
     (module-imports)
     (module-name)
     (module-name->path)
     (module-parents)
     (module-precedence-list)
     (module-table)
     (module?)
     (monotonic-merge)
     (null-list?)
     (object-*)
     (object-+)
     (object--)
     (object-/)
     (object-apply)
     (object-compare)
     (object-equal?)
     (object-hash)
     (open-coding-aware-port)
     (open-input-buffered-port)
     (open-input-fd-port)
     (open-input-string)
     (open-output-buffered-port)
     (open-output-fd-port)
     (open-output-string)
     (pa$)
     (partition$)
     (path->module-name)
     (peek-byte)
     (pop!)
     (port->byte-string)
     (port->list)
     (port->sexp-list)
     (port->string)
     (port->string-list)
     (port-buffering)
     (port-closed?)
     (port-current-line)
     (port-file-number)
     (port-fold)
     (port-fold-right)
     (port-for-each)
     (port-map)
     (port-name)
     (port-position-prefix)
     (port-seek)
     (port-tell)
     (port-type)
     (print)
     (procedure-arity-includes?)
     (procedure-info)
     (profiler-reset)
     (profiler-show)
     (profiler-show-load-stats)
     (profiler-start)
     (profiler-stop)
     (program)
     (promise-kind)
     (promise?)
     (proper-list?)
     (provide)
     (provided?)
     (push! (:syntax))
     (quotient&remainder)
     (raise)
     (read-block)
     (read-byte)
     (read-eval-print-loop)
     (read-from-string)
     (read-line)
     (read-list)
     (read-reference-has-value?)
     (read-reference-value)
     (read-reference?)
     (read-with-shared-structure)
     (read/ss)
     (rec (:syntax))
     (receive (:syntax))
     (redefine-class!)
     (reduce$)
     (reduce-right$)
     (ref)
     (ref*)
     (regexp->string)
     (regexp-case-fold?)
     (regexp-compile)
     (regexp-optimize)
     (regexp-parse)
     (regexp-quote)
     (regexp-replace)
     (regexp-replace*)
     (regexp-replace-all)
     (regexp-replace-all*)
     (regexp?)
     (regmatch?)
     (remove$)
     (report-error)
     (require)
     (require-extension)
     (reverse!)
     (rxmatch)
     (rxmatch-after)
     (rxmatch-before)
     (rxmatch-case)
     (rxmatch-cond)
     (rxmatch-end)
     (rxmatch-if)
     (rxmatch-let)
     (rxmatch-num-matches)
     (rxmatch-start)
     (rxmatch-substring)
     (seconds->time)
     (select-module)
     (set!-values)
     (set-signal-handler!)
     (set-signal-pending-limit)
     (setter)
     (sinh)
     (slot-bound-using-accessor?)
     (slot-bound-using-class?)
     (slot-bound?)
     (slot-definition-accessor)
     (slot-definition-allocation)
     (slot-definition-getter)
     (slot-definition-name)
     (slot-definition-option)
     (slot-definition-options)
     (slot-definition-setter)
     (slot-exists-using-class?)
     (slot-exists?)
     (slot-initialize-using-accessor!)
     (slot-missing)
     (slot-push!)
     (slot-ref)
     (slot-ref-using-accessor)
     (slot-ref-using-class)
     (slot-set!)
     (slot-set-using-accessor!)
     (slot-set-using-class!)
     (slot-unbound)
     (sort)
     (sort!)
     (sort-applicable-methods)
     (sorted?)
     (split-at)
     (stable-sort)
     (stable-sort!)
     (standard-error-port)
     (standard-input-port)
     (standard-output-port)
     (string->regexp)
     (string-byte-ref)
     (string-byte-set!)
     (string-complete->incomplete)
     (string-immutable?)
     (string-incomplete->complete)
     (string-incomplete->complete!)
     (string-incomplete?)
     (string-interpolate)
     (string-join)
     (string-pointer-byte-index)
     (string-pointer-copy)
     (string-pointer-index)
     (string-pointer-next!)
     (string-pointer-prev!)
     (string-pointer-ref)
     (string-pointer-set!)
     (string-pointer-substring)
     (string-pointer?)
     (string-scan)
     (string-size)
     (string-split)
     (string-substitute!)
     (subr?)
     (supported-character-encoding?)
     (supported-character-encodings)
     (symbol-bound?)
     (syntax-error)
     (syntax-errorf)
     (sys-abort)
     (sys-access)
     (sys-alarm)
     (sys-asctime)
     (sys-basename)
     (sys-chdir)
     (sys-chmod)
     (sys-chown)
     (sys-close)
     (sys-crypt)
     (sys-ctermid)
     (sys-ctime)
     (sys-difftime)
     (sys-dirname)
     (sys-exec)
     (sys-exit)
     (sys-fchmod)
     (sys-fdset-max-fd)
     (sys-fdset-ref)
     (sys-fdset-set!)
     (sys-fork)
     (sys-fork-and-exec)
     (sys-fstat)
     (sys-ftruncate)
     (sys-getcwd)
     (sys-getdomainname)
     (sys-getegid)
     (sys-getenv)
     (sys-geteuid)
     (sys-getgid)
     (sys-getgrgid)
     (sys-getgrnam)
     (sys-getgroups)
     (sys-gethostname)
     (sys-getloadavg)
     (sys-getlogin)
     (sys-getpgid)
     (sys-getpgrp)
     (sys-getpid)
     (sys-getppid)
     (sys-getpwnam)
     (sys-getpwuid)
     (sys-gettimeofday)
     (sys-getuid)
     (sys-gid->group-name)
     (sys-glob)
     (sys-gmtime)
     (sys-group-name->gid)
     (sys-isatty)
     (sys-kill)
     (sys-lchown)
     (sys-link)
     (sys-localeconv)
     (sys-localtime)
     (sys-lstat)
     (sys-mkdir)
     (sys-mkfifo)
     (sys-mkstemp)
     (sys-mktime)
     (sys-nanosleep)
     (sys-normalize-pathname)
     (sys-pause)
     (sys-pipe)
     (sys-putenv)
     (sys-random)
     (sys-readdir)
     (sys-readlink)
     (sys-realpath)
     (sys-remove)
     (sys-rename)
     (sys-rmdir)
     (sys-select)
     (sys-select!)
     (sys-setenv)
     (sys-setgid)
     (sys-setlocale)
     (sys-setpgid)
     (sys-setsid)
     (sys-setuid)
     (sys-sigmask)
     (sys-signal-name)
     (sys-sigset)
     (sys-sigset-add!)
     (sys-sigset-delete!)
     (sys-sigset-empty!)
     (sys-sigset-fill!)
     (sys-sigsuspend)
     (sys-sigwait)
     (sys-sleep)
     (sys-srandom)
     (sys-stat)
     (sys-stat->atime)
     (sys-stat->ctime)
     (sys-stat->dev)
     (sys-stat->file-type)
     (sys-stat->gid)
     (sys-stat->ino)
     (sys-stat->mode)
     (sys-stat->mtime)
     (sys-stat->nlink)
     (sys-stat->rdev)
     (sys-stat->size)
     (sys-stat->type)
     (sys-stat->uid)
     (sys-strerror)
     (sys-strftime)
     (sys-symlink)
     (sys-system)
     (sys-time)
     (sys-times)
     (sys-tm->alist)
     (sys-tmpnam)
     (sys-truncate)
     (sys-ttyname)
     (sys-uid->user-name)
     (sys-umask)
     (sys-uname)
     (sys-unlink)
     (sys-unsetenv)
     (sys-user-name->uid)
     (sys-utime)
     (sys-wait)
     (sys-wait-exit-status)
     (sys-wait-exited?)
     (sys-wait-signaled?)
     (sys-wait-stopped?)
     (sys-wait-stopsig)
     (sys-wait-termsig)
     (sys-waitpid)
     (tanh)
     (time)
     (time->seconds)
     (time?)
     (toplevel-closure?)
     (touch-instance!)
     (ucs->char)
     (undefined)
     (undefined?)
     (unless (:syntax))
     (until (:syntax))
     (unwrap-syntax)
     (update! (:syntax))
     (update-direct-method!)
     (update-direct-subclass!)
     (use (:syntax))
     (use-version (:syntax))
     (values-ref (:syntax))
     (vector-copy)
     (vm-dump)
     (vm-get-stack-trace)
     (vm-get-stack-trace-lite)
     (vm-set-default-exception-handler)
     (warn)
     (weak-vector-length)
     (weak-vector-ref)
     (weak-vector-set!)
     (when (:syntax))
     (while (:syntax))
     (with-error-handler)
     (with-error-to-port)
     (with-exception-handler)
     (with-input-from-port)
     (with-input-from-string)
     (with-module (:syntax))
     (with-output-to-port)
     (with-output-to-string)
     (with-port-locking)
     (with-ports)
     (with-signal-handlers)
     (with-string-io)
     (write*)
     (write-byte)
     (write-limited)
     (write-object)
     (write-to-string)
     (write-with-shared-structure)
     (write/ss)
     (x->integer)
     (x->number)
     (x->string)
     )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; utilities

(defun flatten (ls)
  (cond
   ((consp ls) (cons (car ls) (flatten (cdr ls))))
   ((null ls) '())
   (t (list ls))))

(defun in-string-or-comment-p ()
  (let ((orig (point)))
    (save-excursion
      (beginning-of-defun)
      (let ((parses (parse-partial-sexp (point) orig)))
        (or (nth 3 parses) (nth 4 parses))))))

(defun find-file-in-path (file path)
  (car (remove-if-not
        #'(lambda (dir) (file-exists-p (concat dir file)))
        path)))

(defun directory-tree-files (init-dir &optional full match)
  (let ((res '())
        (stack (list init-dir)))
    (while (consp stack)
      (let* ((dir (pop stack))
             (files (cddr (directory-files dir full))))
        (setq res (append (if match
                              (remove-if-not
                               #'(lambda (f) (string-match match f))
                               files)
                            files)
                          res))
        (setq stack
              (append
               (remove-if-not 'file-directory-p
                              (if full
                                  files
                                (mapcar #'(lambda (f) (concat dir "/" f))
                                        files)))
               stack))))
    res))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; variable extraction

(defun extract-let-vars (ls)
  (if (not (consp ls))
      '()
    (remove-if-not 'symbolp (mapcar 'car (remove-if-not 'consp ls)))))

(defun extract-match-clause-vars (x)
  (cond
   ((null x) '())
   ((symbolp x)
    (if (memq x '(_ ___ ...))
        '()
      (list x)))
   ((consp x)
    (case (car x)
      ((and or not)
       (extract-match-clause-vars (cdr x)))
      ((? = $)
       (if (consp (cdr x)) (extract-match-clause-vars (cddr x)) '()))
      ((get! set!)
       (if (consp (cdr x)) (extract-match-clause-vars (cadr x)) '()))
      ((quote) '())
      ((quasiquote) '()) ; XXXX
      (t (union (extract-match-clause-vars (car x))
                (extract-match-clause-vars (cdr x))))))
   ((vectorp x)
    (extract-match-clause-vars (concatenate 'list x)))
   (t
    '())))

(defun extract-match-vars (ls)
  (apply 'append (mapcar 'extract-match-clause-vars
                         (mapcar 'car (remove-if-not 'consp ls)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *current-scheme-implementation* nil)
(make-variable-buffer-local '*current-scheme-implementation*)

(defvar *default-scheme-implementation* 'chicken)

(defvar *scheme-interpreter-alist*
  '(("csi" . chicken)
    ("gosh" . gauche)
    ("gsi" . gambit)
    ))

(defun current-scheme-implementation ()
  (unless *current-scheme-implementation*
    (setq *current-scheme-implementation*
          (save-excursion
            (goto-char (point-min))
            (or (if (looking-at "#! *\\([^ ]+\\)")
                    (let ((script (file-name-nondirectory (match-string 1))))
                      (or (cdr (assoc script *scheme-interpreter-alist*))
                          (intern script))))
                (cond
                 ((re-search-forward "(define-module +\\(.\\)" nil t)
                  (if (equal "(" (match-string 1))
                      'guile
                    'gauche))
                 ((re-search-forward "(use " nil t)
                  'chicken)
                 ((re-search-forward "(module " nil t)
                  'mzscheme))))))
  (or *current-scheme-implementation*
      *default-scheme-implementation*))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun current-local-vars ()
  (let ((vars '())
        (start (save-excursion (beginning-of-defun) (point))))
    (save-excursion
      (while (> (point) start)
        (beginning-of-sexp)
        (let ((sexp (condition-case nil (sexp-at-point)
                      (error (goto-char start) nil))))
          (if (consp sexp)
              (cond
               ((and (eq 'lambda (car sexp)) (consp (cdr sexp)))
                (setq vars (union (flatten (cadr sexp)) vars)))
               ((and (eq 'match (car sexp)) (consp (cdr sexp)))
                (setq vars (union (flatten (extract-match-vars (cddr sexp)))
                                  vars)))
               ((and (memq (car sexp) '(match-let match-let*))
                     (consp (cdr sexp)))
                (setq vars (union (flatten (extract-match-vars (cadr sexp)))
                                  vars)))
               ((and (memq (car sexp) '(let let* letrec and-let*))
                     (consp (cdr sexp)))
                (if (symbolp (cadr sexp)) ; named let
                    (if (and (consp (cddr sexp)) (consp (caddr sexp)))
                        (setq vars (union (extract-let-vars (caddr sexp))
                                          vars)))
                  (if (consp (cadr sexp))
                      (setq vars (union (extract-let-vars (cadr sexp))
                                        vars)))))
               ((and (memq (car sexp) '(defun defmacro))
                     (and (consp (cdr sexp)) (consp (cddr sexp))))
                (setq vars (union (flatten (caddr sexp)) vars)))
               ((and (symbolp (car sexp))
                     (string-match "^define\\(-.*\\)?"
                                   (symbol-name (car sexp)))
                     (and (consp (cdr sexp)) (consp (cadr sexp))))
                (setq vars (union (flatten (cdadr sexp)) vars))))))))
    vars))

(defun extract-import-module-name (sexp &optional mzschemep)
  (case (car sexp)
    ((prefix)
     (extract-import-module-name (if mzschemep (caddr sexp) (cadr sexp))))
    ((prefix-all-except)
     (extract-import-module-name (caddr sexp)))
    ((for only except rename lib library)
     (extract-import-module-name (cadr sexp) mzschemep))
    ((import)
     (extract-import-module-name (cadr sexp) mzschemep))
    ((require)
     (extract-import-module-name (cadr sexp) t))
    (t sexp)))

(defun extract-sexp-modules (sexp)
  (case (car sexp)
    ((begin) (mapcan 'scheme-sexp-modules (cdr sexp)))
    ((cond-expand) (mapcan 'scheme-sexp-modules (mapcan 'cdr (cdr sexp))))
    ((use require-extension)
     (mapcan #'(lambda (x)
                 (if (and (consp x) (eq 'srfi (car x)))
                     (mapcar #'(lambda (i)
                                 (intern (concat "srfi-" (number-to-string i))))
                             (cdr x))
                   (list x)))
             (cdr sexp)))
    ((library module)
     (mapcar #'extract-import-module-name
             (remove-if #'(lambda (x) (memq (car x) '(import require)))
                        (cdr sexp))))
    (t '())))

(defun extract-import-module-imports (sexp &optional mzschemep)
  (case (car sexp)
    ((prefix)
     (let* ((ids (extract-import-module-name
                  (if mzschemep (caddr sexp) (cadr sexp))
                  mzschemep))
            (prefix0 (if mzschemep (cadr sexp) (caddr sexp)))
            (prefix (if (symbolp prefix0) (symbol-name prefix0) prefix0)))
       (mapcar #'(lambda (x) (intern (concat prefix (symbol-name x)))) ids)))
    ((prefix-all-except)
     (let ((prefix
            (if (symbolp (cadr sexp)) (symbol-name (cadr sexp)) (cadr sexp)))
           (exceptions (cddr sexp)))
       (mapcar #'(lambda (x)
                   (if (memq x exceptions)
                       x
                     (intern (concat prefix (symbol-name x)))))
               (extract-import-module-name (caddr sexp) t))))
    ((for)
     (extract-import-module-name (cadr sexp) mzschemep))
    ((rename)
     (if mzschemep
         (list (caddr sexp))
       (mapcar 'cadr (cddr sexp))))
    ((except)
     (remove-if #'(lambda (x) (memq x (cddr sexp)))
                (extract-import-module-imports (cadr sexp) mzschemep)))
    ((only)
     (cddr sexp))
    ((import)
     (extract-import-module-imports (cadr sexp) mzschemep))
    ((require for-syntax)
     (extract-import-module-imports (cadr sexp) t))
    ((library)
     (if (and (stringp (cadr sexp)) (file-exists-p (cadr sexp)))
         (scheme-module-exports (intern (cadr sexp)))))
    ((lib)
     (if (and (equal "srfi" (caddr sexp))
              (stringp (cadr sexp))
              (string-match "^[0-9]+\\." (cadr sexp)))
         (scheme-module-exports
          (intern (file-name-sans-extension (concat "srfi-" (cadr sexp)))))
       (scheme-module-exports
        (intern (apply 'concat (append (cddr sexp) (list (cadr sexp))))))))
    (t sexp)))

(defun extract-sexp-imports (sexp
                             skip-procedure-p
                             skip-syntax-p
                             skip-variable-p)
  (case (car sexp)
    ((begin)
     (mapcan #'(lambda (x)
                 (extract-sexp-imports x skip-procedure-p skip-syntax-p skip-variable-p))
             (cdr sexp)))
    ((cond-expand)
     (mapcan #'(lambda (x)
                 (extract-sexp-imports x skip-procedure-p skip-syntax-p skip-variable-p))
             (mapcan 'cdr (cdr sexp))))
    ((use require-extension)
     (mapcan #'(lambda (x)
                 (scheme-module-exports x skip-procedure-p skip-syntax-p skip-variable-p))
             (extract-sexp-modules sexp)))
    ((library module)
     (mapcar #'extract-import-module-imports
             (remove-if #'(lambda (x) (memq (car x) '(import require)))
                        (cdr sexp))))
    (t '())))

(defun module-symbol-p (sym)
  (memq sym '(use require require-extension begin cond-expand
              module library define-module)))

(defun skip-shebang ()
  ;; skip shebang if present
  (if (looking-at "#!")
      (if (eq 'guile (current-scheme-implementation))
          (re-search-forward "!#" nil t)
        (next-line))))

(defun current-scheme-modules ()
  (let ((mods '()))
    (save-excursion
      (goto-char (point-min))
      (skip-shebang)
      ;; scan for module forms
      (while (not (eobp))
        (if (ignore-errors (progn (forward-sexp) t))
            (let ((end (point)))
              (backward-sexp)
              (when (eq 40 (char-after))
                (forward-char)
                (when (and (not (eq 40 (char-after)))
                           (module-symbol-p (symbol-at-point)))
                  (backward-char)
                  (setq mods
                        (union (extract-sexp-modules
                                (condition-case nil (sexp-at-point)
                                  (error (goto-char end) nil)))
                               mods))))
              (goto-char end))
          ;; terminate on any error (maybe try to recover?)
          (goto-char (point-max)))))
    mods))

(defun current-scheme-imports (&optional skip-procedure-p
                                         skip-syntax-p
                                         skip-variable-p)
  (let ((imports
         (mapcar 'car
                 (remove-if #'(lambda (x)
                                (case (caadr x)
                                  ((:syntax) skip-syntax-p)
                                  ((:variable) skip-variable-p)
                                  (t skip-procedure-p)))
                            (cdr (assq (current-scheme-implementation)
                                       *scheme-implemenation-exports*))))))
    (save-excursion
      (goto-char (point-min))
      (skip-shebang)
      ;; scan for module forms
      (while (not (eobp))
        (if (ignore-errors (progn (forward-sexp) t))
            (let ((end (point)))
              (backward-sexp)
              (when (eq 40 (char-after))
                (forward-char)
                (when (and (not (eq 40 (char-after)))
                           (module-symbol-p (symbol-at-point)))
                  (backward-char)
                  (condition-case nil
                      (setq imports
                            (union (extract-sexp-imports (sexp-at-point)
                                                         skip-procedure-p
                                                         skip-syntax-p
                                                         skip-variable-p)
                                   imports))
                    (error (goto-char end) nil))))
              (goto-char end))
          ;; terminate on any error (maybe try to recover?)
          (goto-char (point-max)))))
    imports))

(defun name-of-define (sexp)
  (if (consp (cadr sexp)) (caadr sexp) (cadr sexp)))

(defun scheme-top-definitions (sexp &optional
                                    skip-procedure-p
                                    skip-syntax-p
                                    skip-variable-p)
  (let ((defs '())
        (stack (list sexp)))
    (while (consp stack)
      (let ((sexp (pop stack)))
        (when (and (consp sexp) (consp (cdr sexp)))
          (case (car sexp)
            ((define-syntax defmacro define-macro)
             (unless skip-syntax-p
               (push (name-of-define sexp) defs)))
            ((define defun)
             (unless (or (and skip-procedure-p
                              (or (eq 'defun (car sexp))
                                  (and (consp (caddr sexp))
                                       (eq 'lambda (caaddr sexp)))))
                         (and skip-variable-p
                              (eq 'define (car sexp))
                              (symbolp (cadr sexp))))
               (push (name-of-define sexp) defs)))
            ((defvar define-class)
             (unless skip-variable-p
               (push (name-of-define sexp) defs)))
            ((define-record-type)
             (unless skip-procedure-p
               (setq defs (cons (caddr sexp)
                                (cons (cadddr sexp)
                                      (append (mapcan 'cdr (cdddr sexp))
                                              defs))))))
            ((begin progn)
             (setq stack (append (cdr sexp) stack)))
            ((cond-expand)
             (setq stack (mapcan 'cdr (cdr sexp))))
            (t
             '())))))
    defs))

(defun current-scheme-globals (&optional skip-procedure-p
                                         skip-syntax-p
                                         skip-variable-p)
  (let ((globals '()))
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (condition-case nil
            (forward-sexp)
          (error (goto-char (point-max))))
        (ignore-errors
          (setq globals
              (append (scheme-top-definitions (sexp-at-point)
                                              skip-procedure-p
                                              skip-syntax-p
                                                    skip-variable-p)
                      globals)))))
    globals))

(defun scheme-module-exports (mod &optional
                                  skip-procedure-p
                                  skip-syntax-p
                                  skip-variable-p)
  (if (not (symbolp mod))
      '()
    (cond
     ((string-match "^srfi-" (symbol-name mod))
      (let ((i (string-to-number (substring (symbol-name mod) 5))))
        (and (< i (length *scheme-srfi-info*))
             (let ((info (cdr (aref *scheme-srfi-info* i))))
               (if (and (consp info) (null (cdr info)) (symbolp (car info)))
                   (scheme-module-exports (car info))
                 (mapcar 'car
                         (remove-if
                          #'(lambda (x)
                              (case (caadr x)
                                ((:syntax) skip-syntax-p)
                                ((:variable) skip-variable-p)
                                (t skip-procedure-p)))
                          info)))))))
     (t
      (case (current-scheme-implementation)
        ((chicken)
         (let ((predefined (assq mod *scheme-chicken-modules*)))
          (if predefined
              (mapcar 'car
                      (remove-if
                       #'(lambda (x)
                           (case (caadr x)
                             ((:syntax) skip-syntax-p)
                             ((:variable) skip-variable-p)
                             (t skip-procedure-p)))
                       (cdr predefined)))
            (let ((path (concat "/usr/local/lib/chicken/1/"
                                (symbol-name mod)
                                ".exports")))
              (if (not (file-exists-p path))
                  '()
                (find-file path)
                (let ((vars '()))
                  (condition-case nil
                      (while (not (eobp))
                        (forward-sexp)
                        (let ((sym (sexp-at-point)))
                          (if sym (push sym vars))))
                    (error (goto-char (point-max))))
                  (kill-buffer (current-buffer))
                  vars))))))
        ((gauche)
         (if skip-procedure-p
             '()
           (let ((path (find-file-in-path
                        (concat (subst-char-in-string ?. ?/ (symbol-name mod))
                                ".scm")
                        (list (concat
                               (car (directory-files
                                     "/usr/local/share/gauche/"
                                     t
                                     "^[0-9]"))
                               "/lib")
                              "/usr/local/share/gauche/site/lib"))))
             (if (not (file-exists-p path))
                 '()
               (find-file path)
               (when (re-search-forward "(export" nil t)
                 (backward-sexp)
                 (backward-char)
                 (let ((vars (cdr (ignore-errors (sexp-at-point)))))
                   (kill-buffer (current-buffer))
                   vars))))))
        ((mzscheme)
         (if skip-procedure-p
             '()
           (let ((path (find-file-in-path
                        (symbol-name mod)
                        '("."
                          "/usr/local/lib/plt/collects"
                          "/usr/local/lib/plt/collects/mzlib"))))
             (if (not (file-exists-p path))
                 '()
               (find-file path)
               (when (re-search-forward "(provide" nil t)
                 (backward-sexp)
                 (backward-char)
                 (let ((vars (cdr (ignore-errors (sexp-at-point)))))
                   (kill-buffer (current-buffer))
                   vars))))))
        (t '()))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; There are currently four general completions we perform, depending
;; on whether we want to include syntax and procedures.

;; all known identifiers
(defun scheme-bound-identifiers ()
  (mapcar
   'symbol-name
   (append
    (current-local-vars)
    (mapcar 'car *scheme-r5rs-info*)
    (current-scheme-globals)
    (current-scheme-imports))))

;; exclude macros as arguments
(defun scheme-bound-non-syntax ()
  (mapcar
   'symbol-name
   (append
    (current-local-vars)
    (mapcar 'car (remove-if #'(lambda (x) (eq (car x) :syntax))
                            *scheme-r5rs-info*))
    (current-scheme-globals nil t)
    (current-scheme-imports nil t))))

;; non-procedures/non-syntax as args to non higher-order functions
(defun scheme-bound-non-procedures ()
  (mapcar
   'symbol-name
   (append (current-local-vars)
           (current-scheme-globals t)
           (current-scheme-imports t))))

;; procedures or syntax in operator position
(defun scheme-bound-non-variables ()
  (mapcar
   'symbol-name
   (append (current-local-vars)
           (mapcar 'car *scheme-r5rs-info*)
           (current-scheme-globals nil nil t)
           (current-scheme-imports nil nil t))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun scheme-lookup-spec (proc)
  (let ((info (assq proc *scheme-r5rs-info*))
        (lim (length *scheme-srfi-info*))
        (i 0))
    (while (and (< i lim) (not info))
      (setq info (assq proc (cdr (aref *scheme-srfi-info* i))))
      (incf i))
    info))

(defun scheme-translate-type (type)
  (if (not (symbolp type))
      type
    (case type
      ((pred proc thunk handler dispatch producer consumer f fn g kons)
       'procedure)
      ((num) 'number)
      ((z) 'complex)
      ((x y timeout seconds nanoseconds) 'real)
      ((i j k n m int index size count len length bound nchars start end
        pid uid gid fd fileno)
       'integer)
      ((ch) 'char)
      ((str name pattern) 'string)
      ((file path pathname) 'filename)
      ((dir dirname) 'directory)
      ((sym id identifier) 'symbol)
      ((ls alist lists) 'list)
      ((vec) 'vector)
      ((exc excn err error) 'exception)
      ((ptr) 'pointer)
      ((char string boolean number complex real integer procedure char-set
        port input-port output-port pair list vector array stream hash-table
        thread mutex condition-variable time exception date duration locative
        random-source state condition condition-type queue sequence pointer
        u8vector s8vector u16vector s16vector u32vector s32vector
        u64vector s64vector f32vector f64vector
        block filename directory mmap listener non-procedure)
       type)
      ((parent seed option mode) 'non-procedure)
      (t
       (let* ((str (symbol-name type))
              (i (string-match "-?[0-9]+$" str)))
         (if i
             (scheme-translate-type (intern (substring str 0 i)))
           (let ((i (string-match "-\\([^-]+\\)$" str)))
             (if i
                 (scheme-translate-type (intern (substring str i)))
               (if (string-match "\\?$" str)
                   'boolean
                 'object)))))))))

(defun scheme-lookup-type (proc pos)
  (let ((spec (cadr (scheme-lookup-spec proc)))
        (i 1)
        (type nil))
    (while (and (consp spec) (< i pos))
      (case (car spec)
        ((:syntax)
         (setq spec nil))
        ((:optional)
         (decf i))
        ((:rest)
         (setq type (cadr spec))
         (setq spec nil))
        (t
         (when (eq '... (cadr spec))
           (setq type (car spec))
           (setq spec nil))))
      (setq spec (cdr spec))
      (incf i))
    (if (and (not type) (= i pos))
        (setq type (car (remove ':optional spec))))
    (if type
        (setq type (scheme-translate-type type)))
    type))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; completion

(unless (fboundp 'event-matches-key-specifier-p)
  (defalias 'event-matches-key-specifier-p 'eq))

(unless (fboundp 'read-event)
  (defun read-event ()
    (aref (read-key-sequence nil) 0)))

(defun do-completion (str coll &rest args)
  (let ((completion (apply 'try-completion str coll args)))
    (message "completion: \"%s\"" completion)
    (cond
     ((eq completion t))
     ((not completion)
      (message "Can't find completion for \"%s\"" str)
      (ding))
     ((not (string= str completion))
      (message "Inserting completion")
      (insert (substring completion (length str))))
     (t
      (let ((win-config (current-window-configuration))
            (done nil))
        (message "Hit space to flush")
        (with-output-to-temp-buffer "*Completions*"
          (display-completion-list (all-completions str coll)))
        (while (not done)
          (let ((event
                 (with-current-buffer (get-buffer "*Completions*")
                   (read-event))))
            (cond
             ((or (event-matches-key-specifier-p event 'tab)
                  (event-matches-key-specifier-p event 9))
              (save-selected-window
                (select-window (get-buffer-window "*Completions*"))
                (if (pos-visible-in-window-p (point-max))
                    (goto-char (point-min))
                  (scroll-up))))
             (t
              (set-window-configuration win-config)
              (setq unread-command-events (list event))
              (setq done t))))))
      ))))

(defun enclosing-sexp-prefix ()
  (let ((pos 0))
    (save-excursion
      (skip-syntax-backward "w_")
      (while (and (not (bobp)) (not (eq 40 (char-before))))
        (beginning-of-sexp)
        (incf pos))
      (cons (symbol-at-point) pos))))

(defun chicken-available-modules ()
  (append
   (mapcar 'symbol-name (mapcar 'car *scheme-chicken-modules*))
   (mapcar
    'file-name-sans-extension
    (directory-files "/usr/local/lib/chicken/1/"
                     nil
                     ".*\\.\\(so\\|scm\\)$"
                     t))))

(defun gauche-available-modules ()
  (let ((version-dir (concat
                      (car (directory-files "/usr/local/share/gauche/"
                                            t
                                            "^[0-9]"))
                      "/lib"))
        (site-dir "/usr/local/share/gauche/site/lib"))
    (mapcar
     #'(lambda (f) (subst-char-in-string ?/ ?. f))
     (mapcar
      'file-name-sans-extension
      (append (mapcar #'(lambda (f) (substring f (+ 1 (length version-dir))))
                      (directory-tree-files version-dir t "\\.scm"))
              (mapcar #'(lambda (f) (substring f (+ 1 (length site-dir))))
                      (directory-tree-files site-dir t "\\.scm")))))))

(defun scheme-smart-complete ()
  (interactive)
  (let* ((end (point))
         (start (save-excursion (skip-syntax-backward "w_") (point)))
         (sym (buffer-substring-no-properties start end))
         (x (enclosing-sexp-prefix))
         (proc (car x))
         (pos (cdr x)))
    (cond
     ((in-string-p)
      (let ((file (file-name-nondirectory sym))
            (dir (or (file-name-directory sym) ".")))
        (do-completion file (file-name-all-completions file dir))))
     ((and proc (not (zerop pos)))
      (case proc
        ((use require-extension)
         (if (eq 'gauche (current-scheme-implementation))
             (do-completion sym (gauche-available-modules))
           (do-completion sym (chicken-available-modules))))
        (t
         (let ((type (scheme-lookup-type proc pos)))
           (cond
            ((consp type)
             (do-completion sym (append type (scheme-bound-non-procedures))))
            ((and type (not (memq type '(object procedure))))
             (do-completion sym (scheme-bound-non-procedures)))
            (t
             (do-completion sym (scheme-bound-non-syntax))))))))
     ((zerop pos)
      (do-completion sym (scheme-bound-non-variables)))
     (t
      (do-completion sym (scheme-bound-identifiers))))))

(defun scheme-complete-or-indent ()
  (interactive)
  (let* ((end (point))
         (func
          (save-excursion
            (beginning-of-line)
            (if (re-search-forward "\\S-" end t)
                'scheme-smart-complete
              'lisp-indent-line))))
    (funcall func)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; optional eldoc function

(defun scheme-get-current-symbol-info ()
  (let* ((sym (eldoc-current-symbol))
         (fnsym (eldoc-fnsym-in-current-sexp))
         (spec (or (and sym (scheme-lookup-spec sym))
                   (scheme-lookup-spec fnsym))))
    (and spec
         (concat (if (nth 3 spec)
                     ""
                   (with-output-to-string
                     (princ (cons (car spec)
                                  (if (memq (caadr spec) '(:syntax :variable))
                                      (cdadr spec)
                                    (cadr spec))))))
                 (if (and (not (nth 3 spec)) (nth 4 spec)) " - " "")
                 (or (nth 4 spec) "")))))

(provide 'scheme-complete)
